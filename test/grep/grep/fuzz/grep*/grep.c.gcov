        -:    0:Source:grep.c
        -:    0:Graph:grep.gcno
        -:    0:Data:grep.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* grep.c - main driver file for grep.
        -:    2:   Copyright (C) 1992 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation; either version 2, or (at your option)
        -:    7:   any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program; if not, write to the Free Software
        -:   16:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
        -:   17:
        -:   18:   Written July 1992 by Mike Haertel.  */
        -:   19:
        -:   20:/* I added a series define from makefile here in order to run cfe */
        -:   21:#define GREP 1
        -:   22:#define STDC_HEADERS 1
        -:   23:#define HAVE_STRING_H 1
        -:   24:#define HAVE_SYS_PARAM_H 1
        -:   25:#define HAVE_UNISTD_H 1
        -:   26:#define HAVE_ALLOCA_H 1
        -:   27:#define HAVE_GETPAGESIZE 1
        -:   28:#define HAVE_MEMCHR 1
        -:   29:#define HAVE_STRERROR 1
        -:   30:#define HAVE_VALLOC 1
        -:   31:#define HAVE_WORKING_MMAP 1
        -:   32:#define LINUX 1
        -:   33:/*** end of cfe purpose **/
        -:   34:
        -:   35:#include <errno.h>
        -:   36:#include <stdio.h>
        -:   37:
        -:   38:/*******IMPORTANT CHANGE for let stderr redirect to a file *******/
        -:   39:#undef stderr
        -:   40:#define stderr stdout
        -:   41:/******* FINISH IMPORTANT CHANGE *********/
        -:   42:
        -:   43:#ifndef errno
        -:   44:extern int errno;
        -:   45:#endif
        -:   46:
        -:   47:#ifdef STDC_HEADERS
        -:   48:#include <stdlib.h>
        -:   49:#define flag_stdlib 1
        -:   50:#else
        -:   51:#include <sys/types.h>
        -:   52:#define flag_systypes 1
        -:   53:extern char *malloc(), *realloc();
        -:   54:extern void free();
        -:   55:#endif
        -:   56:
        -:   57:#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
        -:   58:#include <string.h>
        -:   59:#define flag_string 1
        -:   60:#ifdef NEED_MEMORY_H
        -:   61:#include <memory.h>
        -:   62:#define flag_memory 1
        -:   63:#endif
        -:   64:#else
        -:   65:#include <strings.h>
        -:   66:#define flag_strings 1
        -:   67:#ifdef __STDC__
        -:   68:extern void *memchr();
        -:   69:#else
        -:   70:extern char *memchr();
        -:   71:#endif
        -:   72:#define strrchr rindex
        -:   73:#endif
        -:   74:
        -:   75:#ifdef HAVE_UNISTD_H
        -:   76:#if flag_systypes==0
        -:   77:#include <sys/types.h>
        -:   78:#define flag_systypes 1
        -:   79:#endif
        -:   80:#include <fcntl.h>
        -:   81:#include <unistd.h>
        -:   82:#else
        -:   83:#define O_RDONLY 0
        -:   84:extern int open(), read(), close();
        -:   85:#endif
        -:   86:
        -:   87:#include "getpagesize.h"
        -:   88:#include "grep.h"
        -:   89:#include "/home/cheong/afl-2.52b/experimental/argv_fuzzing/argv-fuzz-inl.h"
        -:   90:
        -:   91:#undef MAX
        -:   92:#define MAX(A,B) ((A) > (B) ? (A) : (B))
        -:   93:
        -:   94:/* Provide missing ANSI features if necessary. */
        -:   95:
        -:   96:#ifndef HAVE_STRERROR
        -:   97:extern int sys_nerr;
        -:   98:extern char *sys_errlist[];
        -:   99:#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
        -:  100:#endif
        -:  101:
        -:  102:#ifndef HAVE_MEMCHR
        -:  103:#ifdef __STDC__
        -:  104:#define VOID void
        -:  105:#else
        -:  106:#define VOID char
        -:  107:#endif
        -:  108:VOID *
        -:  109:memchr(vp, c, n)
        -:  110:     VOID *vp;
        -:  111:     int c;
        -:  112:     size_t n;
        -:  113:{
        -:  114:  unsigned char *p;
        -:  115:
        -:  116:  for (p = (unsigned char *) vp; n--; ++p)
        -:  117:    if (*p == c)
        -:  118:      return (VOID *) p;
        -:  119:  return 0;
        -:  120:}
        -:  121:#endif
        -:  122:    
        -:  123:/* Define flags declared in grep.h. */
        -:  124:char *matcher;
        -:  125:int match_icase;
        -:  126:int match_words;
        -:  127:int match_lines;
        -:  128:
        -:  129:/* Functions we'll use to search. */
        -:  130:static void (*compile)();
        -:  131:static char *(*execute)();
        -:  132:
        -:  133:/* For error messages. */
        -:  134:static char *prog;
        -:  135:static char *filename;
        -:  136:static int errseen;
        -:  137:
        -:  138:/* Print a message and possibly an error string.  Remember
        -:  139:   that something awful happened. */
        -:  140:static void
    #####:  141:error(mesg, errnum)
        -:  142:#ifdef __STDC__
        -:  143:     const
        -:  144:#endif
        -:  145:     char *mesg;
        -:  146:     int errnum;
        -:  147:{
    #####:  148:  if (errnum)
    #####:  149:    fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
        -:  150:  else
    #####:  151:    fprintf(stderr, "%s: %s\n", prog, mesg);
    #####:  152:  errseen = 1;
    #####:  153:}
        -:  154:
        -:  155:/* Like error(), but die horribly after printing. */
        -:  156:void
    #####:  157:fatal(mesg, errnum)
        -:  158:#ifdef __STDC__
        -:  159:     const
        -:  160:#endif
        -:  161:     char *mesg;
        -:  162:     int errnum;
        -:  163:{
    #####:  164:  error(mesg, errnum);
    #####:  165:  exit(2);
        -:  166:}
        -:  167:
        -:  168:/* Interface to handle errors and fix library lossage. */
        -:  169:char *
    #####:  170:xmalloc(size)
        -:  171:     size_t size;
        -:  172:{
        -:  173:  char *result;
        -:  174:
    #####:  175:  result = malloc(size);
    #####:  176:  if (size && !result)
    #####:  177:    fatal("memory exhausted", 0);
    #####:  178:  return result;
        -:  179:}
        -:  180:
        -:  181:/* Interface to handle errors and fix some library lossage. */
        -:  182:char *
    #####:  183:xrealloc(ptr, size)
        -:  184:     char *ptr;
        -:  185:     size_t size;
        -:  186:{
        -:  187:  char *result;
        -:  188:
    #####:  189:  if (ptr)
    #####:  190:    result = realloc(ptr, size);
        -:  191:  else
    #####:  192:    result = malloc(size);
    #####:  193:  if (size && !result)
    #####:  194:    fatal("memory exhausted", 0);
    #####:  195:  return result;
        -:  196:}
        -:  197:
        -:  198:#if !defined(HAVE_VALLOC)
        -:  199:#define valloc malloc
        -:  200:#else
        -:  201:#ifdef __STDC__
        -:  202:extern void *valloc(size_t);
        -:  203:#else
        -:  204:extern char *valloc();
        -:  205:#endif
        -:  206:#endif
        -:  207:
        -:  208:/* Hairy buffering mechanism for grep.  The intent is to keep
        -:  209:   all reads aligned on a page boundary and multiples of the
        -:  210:   page size. */
        -:  211:
        -:  212:static char *buffer;		/* Base of buffer. */
        -:  213:static size_t bufsalloc;	/* Allocated size of buffer save region. */
        -:  214:static size_t bufalloc;		/* Total buffer size. */
        -:  215:static int bufdesc;		/* File descriptor. */
        -:  216:static char *bufbeg;		/* Beginning of user-visible stuff. */
        -:  217:static char *buflim;		/* Limit of user-visible stuff. */
        -:  218:
        -:  219:#if defined(HAVE_WORKING_MMAP)
        -:  220:#if flag_systypes==0
        -:  221:#include <sys/types.h>
        -:  222:#define flag_systypes 1
        -:  223:#endif
        -:  224:#include <sys/stat.h>
        -:  225:#include <sys/mman.h>
        -:  226:
        -:  227:static int bufmapped;		/* True for ordinary files. */
        -:  228:static struct stat bufstat;	/* From fstat(). */
        -:  229:static off_t bufoffset;		/* What read() normally remembers. */
        -:  230:#endif
        -:  231:
        -:  232:/* Reset the buffer for a new file.  Initialize
        -:  233:   on the first time through. */
        -:  234:void
    #####:  235:reset(fd)
        -:  236:     int fd;
        -:  237:{
        -:  238:  static int initialized;
        -:  239:
    #####:  240:  if (!initialized)
        -:  241:    {
    #####:  242:      initialized = 1;
        -:  243:#ifndef BUFSALLOC
    #####:  244:      bufsalloc = MAX(8192, getpagesize());
        -:  245:#else
        -:  246:      bufsalloc = BUFSALLOC;
        -:  247:#endif
    #####:  248:      bufalloc = 5 * bufsalloc;
        -:  249:      /* The 1 byte of overflow is a kludge for dfaexec(), which
        -:  250:	 inserts a sentinel newline at the end of the buffer
        -:  251:	 being searched.  There's gotta be a better way... */
    #####:  252:      buffer = valloc(bufalloc + 1);
    #####:  253:      if (!buffer)
    #####:  254:	fatal("memory exhausted", 0);
    #####:  255:      bufbeg = buffer;
    #####:  256:      buflim = buffer;
        -:  257:    }
    #####:  258:  bufdesc = fd;
        -:  259:#if defined(HAVE_WORKING_MMAP)
    #####:  260:  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
    #####:  261:    bufmapped = 0;
        -:  262:  else
        -:  263:    {
    #####:  264:      bufmapped = 1;
    #####:  265:      bufoffset = lseek(fd, 0, 1);
        -:  266:    }
        -:  267:#endif
    #####:  268:}
        -:  269:
        -:  270:/* Read new stuff into the buffer, saving the specified
        -:  271:   amount of old stuff.  When we're done, 'bufbeg' points
        -:  272:   to the beginning of the buffer contents, and 'buflim'
        -:  273:   points just after the end.  Return count of new stuff. */
        -:  274:static int
    #####:  275:fillbuf(save)
        -:  276:     size_t save;
        -:  277:{
        -:  278:  char *nbuffer, *dp, *sp;
        -:  279:  int cc;
        -:  280:#if defined(HAVE_WORKING_MMAP)
        -:  281:  caddr_t maddr;
        -:  282:#endif
        -:  283:  static int pagesize;
        -:  284:
    #####:  285:  if (pagesize == 0 && (pagesize = getpagesize()) == 0)
    #####:  286:    abort();
        -:  287:
    #####:  288:  if (save > bufsalloc)
        -:  289:    {
    #####:  290:      while (save > bufsalloc)
    #####:  291:	bufsalloc *= 2;
    #####:  292:      bufalloc = 5 * bufsalloc;
    #####:  293:      nbuffer = valloc(bufalloc + 1);
    #####:  294:      if (!nbuffer)
    #####:  295:	fatal("memory exhausted", 0);
        -:  296:    }
        -:  297:  else
    #####:  298:    nbuffer = buffer;
        -:  299:
    #####:  300:  sp = buflim - save;
    #####:  301:  dp = nbuffer + bufsalloc - save;
    #####:  302:  bufbeg = dp;
    #####:  303:  while (save--)
    #####:  304:    *dp++ = *sp++;
        -:  305:
        -:  306:  /* We may have allocated a new, larger buffer.  Since
        -:  307:     there is no portable vfree(), we just have to forget
        -:  308:     about the old one.  Sorry. */
    #####:  309:  buffer = nbuffer;
        -:  310:
        -:  311:#if defined(HAVE_WORKING_MMAP)
    #####:  312:  if (bufmapped && bufoffset % pagesize == 0
    #####:  313:      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
        -:  314:    {
    #####:  315:      maddr = buffer + bufsalloc;
    #####:  316:      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
        -:  317:		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
    #####:  318:      if (maddr == (caddr_t) -1)
        -:  319:	{
    #####:  320:	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
    #####:  321:		  strerror(errno));
    #####:  322:	  goto tryread;
        -:  323:	}
        -:  324:#if 0
        -:  325:      /* You might thing this (or MADV_WILLNEED) would help,
        -:  326:	 but it doesn't, at least not on a Sun running 4.1.
        -:  327:	 In fact, it actually slows us down about 30%! */
        -:  328:      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
        -:  329:#endif
    #####:  330:      cc = bufalloc - bufsalloc;
    #####:  331:      bufoffset += cc;
        -:  332:    }
        -:  333:  else
        -:  334:    {
        -:  335:    tryread:
        -:  336:      /* We come here when we're not going to use mmap() any more.
        -:  337:	 Note that we need to synchronize the file offset the
        -:  338:	 first time through. */
    #####:  339:      if (bufmapped)
        -:  340:	{
    #####:  341:	  bufmapped = 0;
    #####:  342:	  lseek(bufdesc, bufoffset, 0);
        -:  343:	}
    #####:  344:      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
        -:  345:    }
        -:  346:#else
        -:  347:  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
        -:  348:#endif
    #####:  349:  if (cc > 0)
    #####:  350:    buflim = buffer + bufsalloc + cc;
        -:  351:  else
    #####:  352:    buflim = buffer + bufsalloc;
    #####:  353:  return cc;
        -:  354:}
        -:  355:
        -:  356:/* Flags controlling the style of output. */
        -:  357:static int out_quiet;		/* Suppress all normal output. */
        -:  358:static int out_invert;		/* Print nonmatching stuff. */
        -:  359:static int out_file;		/* Print filenames. */
        -:  360:static int out_line;		/* Print line numbers. */
        -:  361:static int out_byte;		/* Print byte offsets. */
        -:  362:static int out_before;		/* Lines of leading context. */
        -:  363:static int out_after;		/* Lines of trailing context. */
        -:  364:
        -:  365:/* Internal variables to keep track of byte count, context, etc. */
        -:  366:static size_t totalcc;		/* Total character count before bufbeg. */
        -:  367:static char *lastnl;		/* Pointer after last newline counted. */
        -:  368:static char *lastout;		/* Pointer after last character output;
        -:  369:				   NULL if no character has been output
        -:  370:				   or if it's conceptually before bufbeg. */
        -:  371:static size_t totalnl;		/* Total newline count before lastnl. */
        -:  372:static int pending;		/* Pending lines of output. */
        -:  373:
        -:  374:static void
    #####:  375:nlscan(lim)
        -:  376:     char *lim;
        -:  377:{
        -:  378:  char *beg;
        -:  379:
    #####:  380:  for (beg = lastnl; beg < lim; ++beg)
    #####:  381:    if (*beg == '\n')
    #####:  382:      ++totalnl;
    #####:  383:  lastnl = beg;
    #####:  384:}
        -:  385:
        -:  386:static void
    #####:  387:prline(beg, lim, sep)
        -:  388:     char *beg;
        -:  389:     char *lim;
        -:  390:     char sep;
        -:  391:{
    #####:  392:  if (out_file)
    #####:  393:    printf("%s%c", filename, sep);
    #####:  394:  if (out_line)
        -:  395:    {
    #####:  396:      nlscan(beg);
    #####:  397:      printf("%d%c", ++totalnl, sep);
    #####:  398:      lastnl = lim;
        -:  399:    }
    #####:  400:  if (out_byte)
    #####:  401:    printf("%lu%c", totalcc + (beg - bufbeg), sep);
    #####:  402:  fwrite(beg, 1, lim - beg, stdout);
    #####:  403:  if (ferror(stdout))
    #####:  404:    error("writing output", errno);
    #####:  405:  lastout = lim;
    #####:  406:}
        -:  407:
        -:  408:/* Print pending lines of trailing context prior to LIM. */
        -:  409:static void
    #####:  410:prpending(lim)
        -:  411:     char *lim;
        -:  412:{
        -:  413:  char *nl;
        -:  414:
    #####:  415:  if (!lastout)
    #####:  416:    lastout = bufbeg;
    #####:  417:  while (pending > 0 && lastout < lim)
        -:  418:    {
    #####:  419:      --pending;
    #####:  420:      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
    #####:  421:	++nl;
        -:  422:      else
    #####:  423:	nl = lim;
    #####:  424:      prline(lastout, nl, '-');
        -:  425:    }
    #####:  426:}
        -:  427:
        -:  428:/* Print the lines between BEG and LIM.  Deal with context crap.
        -:  429:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
        -:  430:static void
    #####:  431:prtext(beg, lim, nlinesp)
        -:  432:     char *beg;
        -:  433:     char *lim;
        -:  434:     int *nlinesp;
        -:  435:{
        -:  436:  static int used;		/* avoid printing "--" before any output */
        -:  437:  char *bp, *p, *nl;
        -:  438:  int i, n;
        -:  439:
    #####:  440:  if (!out_quiet && pending > 0)
    #####:  441:    prpending(beg);
        -:  442:
    #####:  443:  p = beg;
        -:  444:
    #####:  445:  if (!out_quiet)
        -:  446:    {
        -:  447:      /* Deal with leading context crap. */
        -:  448:
    #####:  449:      bp = lastout ? lastout : bufbeg;
    #####:  450:      for (i = 0; i < out_before; ++i)
    #####:  451:	if (p > bp)
        -:  452:	  do
    #####:  453:	    --p;
    #####:  454:	  while (p > bp && p[-1] != '\n');
        -:  455:
        -:  456:      /* We only print the "--" separator if our output is
        -:  457:	 discontiguous from the last output in the file. */
    #####:  458:      if ((out_before || out_after) && used && p != lastout)
    #####:  459:	puts("--");
        -:  460:
    #####:  461:      while (p < beg)
        -:  462:	{
    #####:  463:	  nl = memchr(p, '\n', beg - p);
    #####:  464:	  prline(p, nl + 1, '-');
    #####:  465:	  p = nl + 1;
        -:  466:	}
        -:  467:    }
        -:  468:
    #####:  469:  if (nlinesp)
        -:  470:    {
        -:  471:      /* Caller wants a line count. */
    #####:  472:      for (n = 0; p < lim; ++n)
        -:  473:	{
    #####:  474:	  if ((nl = memchr(p, '\n', lim - p)) != 0)
    #####:  475:	    ++nl;
        -:  476:	  else
    #####:  477:	    nl = lim;
    #####:  478:	  if (!out_quiet)
    #####:  479:	    prline(p, nl, ':');
    #####:  480:	  p = nl;
        -:  481:	}
    #####:  482:      *nlinesp = n;
        -:  483:    }
        -:  484:  else
    #####:  485:    if (!out_quiet)
    #####:  486:      prline(beg, lim, ':');
        -:  487:
    #####:  488:  pending = out_after;
    #####:  489:  used = 1;
    #####:  490:}
        -:  491:
        -:  492:/* Scan the specified portion of the buffer, matching lines (or
        -:  493:   between matching lines if OUT_INVERT is true).  Return a count of
        -:  494:   lines printed. */
        -:  495:static int
    #####:  496:grepbuf(beg, lim)
        -:  497:     char *beg;
        -:  498:     char *lim;
        -:  499:{
        -:  500:  int nlines, n;
        -:  501:  register char *p, *b;
        -:  502:  char *endp;
        -:  503:
    #####:  504:  nlines = 0;
    #####:  505:  p = beg;
    #####:  506:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
        -:  507:    {
        -:  508:      /* Avoid matching the empty line at the end of the buffer. */
    #####:  509:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
        -:  510:	break;
    #####:  511:      if (!out_invert)
        -:  512:	{
    #####:  513:	  prtext(b, endp, (int *) 0);
    #####:  514:	  nlines += 1;
        -:  515:	}
    #####:  516:      else if (p < b)
        -:  517:	{
    #####:  518:	  prtext(p, b, &n);
    #####:  519:	  nlines += n;
        -:  520:	}
    #####:  521:      p = endp;
        -:  522:    }
    #####:  523:  if (out_invert && p < lim)
        -:  524:    {
    #####:  525:      prtext(p, lim, &n);
    #####:  526:      nlines += n;
        -:  527:    }
    #####:  528:  return nlines;
        -:  529:}
        -:  530:
        -:  531:/* Search a given file.  Return a count of lines printed. */
        -:  532:static int
    #####:  533:grep(fd)
        -:  534:     int fd;
        -:  535:{
        -:  536:  int nlines, i;
        -:  537:  size_t residue, save;
        -:  538:  char *beg, *lim;
        -:  539:
    #####:  540:  reset(fd);
        -:  541:
    #####:  542:  totalcc = 0;
    #####:  543:  lastout = 0;
    #####:  544:  totalnl = 0;
    #####:  545:  pending = 0;
        -:  546:
    #####:  547:  nlines = 0;
    #####:  548:  residue = 0;
    #####:  549:  save = 0;
        -:  550:
        -:  551:  for (;;)
        -:  552:    {
    #####:  553:      if (fillbuf(save) < 0)
        -:  554:	{
    #####:  555:	  error(filename, errno);
    #####:  556:	  return nlines;
        -:  557:	}
    #####:  558:      lastnl = bufbeg;
    #####:  559:      if (lastout)
    #####:  560:	lastout = bufbeg;
    #####:  561:      if (buflim - bufbeg == save)
    #####:  562:	break;
    #####:  563:      beg = bufbeg + save - residue;
    #####:  564:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
        -:  565:	;
    #####:  566:      residue = buflim - lim;
    #####:  567:      if (beg < lim)
        -:  568:	{
    #####:  569:	  nlines += grepbuf(beg, lim);
    #####:  570:	  if (pending)
    #####:  571:	    prpending(lim);
        -:  572:	}
    #####:  573:      i = 0;
    #####:  574:      beg = lim;
    #####:  575:      while (i < out_before && beg > bufbeg && beg != lastout)
        -:  576:	{
    #####:  577:	  ++i;
        -:  578:	  do
    #####:  579:	    --beg;
    #####:  580:	  while (beg > bufbeg && beg[-1] != '\n');
        -:  581:	}
    #####:  582:      if (beg != lastout)
    #####:  583:	lastout = 0;
    #####:  584:      save = residue + lim - beg;
    #####:  585:      totalcc += buflim - bufbeg - save;
    #####:  586:      if (out_line)
    #####:  587:	nlscan(beg);
    #####:  588:    }
    #####:  589:  if (residue)
        -:  590:    {
    #####:  591:      nlines += grepbuf(bufbeg + save - residue, buflim);
    #####:  592:      if (pending)
    #####:  593:	prpending(buflim);
        -:  594:    }
    #####:  595:  return nlines;
        -:  596:}
        -:  597:
        -:  598:static char version[] = "GNU grep version 2.0";
        -:  599:
        -:  600:#define USAGE \
        -:  601:  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
        -:  602:
        -:  603:static void
        1:  604:usage()
        -:  605:{
        1:  606:  fprintf(stderr, USAGE, prog);
        1:  607:  exit(2);
        -:  608:}
        -:  609:
        -:  610:/* Go through the matchers vector and look for the specified matcher.
        -:  611:   If we find it, install it in compile and execute, and return 1.  */
        -:  612:int
    #####:  613:setmatcher(name)
        -:  614:     char *name;
        -:  615:{
        -:  616:  int i;
        -:  617:
    #####:  618:  for (i = 0; matchers[i].name; ++i)
    #####:  619:    if (strcmp(name, matchers[i].name) == 0)
        -:  620:      {
    #####:  621:	compile = matchers[i].compile;
    #####:  622:	execute = matchers[i].execute;
    #####:  623:	return 1;
        -:  624:      }
    #####:  625:  return 0;
        -:  626:}  
        -:  627:
        -:  628:int
        1:  629:main(argc, argv)
        -:  630:     int argc;
        -:  631:     char *argv[];
        -:  632:{
        -:  633:  char *keys;
        -:  634:  size_t keycc, oldcc, keyalloc;
        -:  635:  int keyfound, count_matches, no_filenames, list_files, suppress_errors;
        -:  636:  int opt, cc, desc, count, status;
        -:  637:  FILE *fp;
        -:  638:  extern char *optarg;
        -:  639:  extern int optind;
        -:  640:  /* add this line for diff between *.c and *.int.c */
        1:  641:  argv[0] = "target";
        1:  642:	argv[argc-1] = "/home/cheong/afl-2.52b/test/grep/grep/inputs/grep*.dat";
        -:  643:	//AFL_INIT_SET0("./grep");
        -:  644:
        1:  645:  prog = argv[0];
        1:  646:  if (prog && strrchr(prog, '/'))
        1:  647:    prog = strrchr(prog, '/') + 1;
        -:  648:
        1:  649:  keys = NULL;
        1:  650:  keycc = 0;
        1:  651:  keyfound = 0;
        1:  652:  count_matches = 0;
        1:  653:  no_filenames = 0;
        1:  654:  list_files = 0;
        1:  655:  suppress_errors = 0;
        1:  656:  matcher = NULL;
        -:  657:
        2:  658:  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
        -:  659:	 != EOF)
    #####:  660:    switch (opt)
        -:  661:      {
        -:  662:      case '0':
        -:  663:      case '1':
        -:  664:      case '2':
        -:  665:      case '3':
        -:  666:      case '4':
        -:  667:      case '5':
        -:  668:      case '6':
        -:  669:      case '7':
        -:  670:      case '8':
        -:  671:      case '9':
    #####:  672:	out_before = 10 * out_before + opt - '0';
    #####:  673:	out_after = 10 * out_after + opt - '0';
    #####:  674:	break;
        -:  675:      case 'A':
    #####:  676:	out_after = atoi(optarg);
    #####:  677:	if (out_after < 0)
    #####:  678:	  usage();
    #####:  679:	break;
        -:  680:      case 'B':
    #####:  681:	out_before = atoi(optarg);
    #####:  682:	if (out_before < 0)
    #####:  683:	  usage();
    #####:  684:	break;
        -:  685:      case 'C':
    #####:  686:	out_before = out_after = 2;
    #####:  687:	break;
        -:  688:      case 'E':
    #####:  689:	if (matcher && strcmp(matcher, "egrep") != 0)
    #####:  690:	  fatal("you may specify only one of -E, -F, or -G", 0);
    #####:  691:	matcher = "posix-egrep";
    #####:  692:	break;
        -:  693:      case 'F':
    #####:  694:	if (matcher && strcmp(matcher, "fgrep") != 0)
    #####:  695:	  fatal("you may specify only one of -E, -F, or -G", 0);;
    #####:  696:	matcher = "fgrep";
    #####:  697:	break;
        -:  698:      case 'G':
    #####:  699:	if (matcher && strcmp(matcher, "grep") != 0)
    #####:  700:	  fatal("you may specify only one of -E, -F, or -G", 0);
    #####:  701:	matcher = "grep";
    #####:  702:	break;
        -:  703:      case 'V':
    #####:  704:	fprintf(stderr, "%s\n", version);
    #####:  705:	break;
        -:  706:      case 'X':
    #####:  707:	if (matcher)
    #####:  708:	  fatal("matcher already specified", 0);
    #####:  709:	matcher = optarg;
    #####:  710:	break;
        -:  711:      case 'b':
    #####:  712:	out_byte = 1;
    #####:  713:	break;
        -:  714:      case 'c':
    #####:  715:	out_quiet = 1;
    #####:  716:	count_matches = 1;
    #####:  717:	break;
        -:  718:      case 'e':
    #####:  719:	cc = strlen(optarg);
    #####:  720:	keys = xrealloc(keys, keycc + cc + 1);
    #####:  721:	if (keyfound)
    #####:  722:	  keys[keycc++] = '\n';
    #####:  723:	strcpy(&keys[keycc], optarg);
    #####:  724:	keycc += cc;
    #####:  725:	keyfound = 1;
    #####:  726:	break;
        -:  727:      case 'f':
    #####:  728:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
    #####:  729:	if (!fp)
    #####:  730:	  fatal(optarg, errno);
    #####:  731:	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
        -:  732:	  ;
    #####:  733:	keys = xrealloc(keys, keyalloc);
    #####:  734:	oldcc = keycc;
    #####:  735:	if (keyfound)
    #####:  736:	  keys[keycc++] = '\n';
    #####:  737:	while (!feof(fp)
    #####:  738:	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
        -:  739:	  {
    #####:  740:	    keycc += cc;
    #####:  741:	    if (keycc == keyalloc)
    #####:  742:	      keys = xrealloc(keys, keyalloc *= 2);
        -:  743:	  }
    #####:  744:	if (fp != stdin)
    #####:  745:	  fclose(fp);
        -:  746:	/* Nuke the final newline to avoid matching a null string. */
    #####:  747:	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
    #####:  748:	  --keycc;
    #####:  749:	keyfound = 1;
    #####:  750:	break;
        -:  751:      case 'h':
    #####:  752:	no_filenames = 1;
    #####:  753:	break;
        -:  754:      case 'i':
        -:  755:      case 'y':			/* For old-timers . . . */
    #####:  756:	match_icase = 1;
    #####:  757:	break;
        -:  758:      case 'L':
        -:  759:	/* Like -l, except list files that don't contain matches.
        -:  760:	   Inspired by the same option in Hume's gre. */
    #####:  761:	out_quiet = 1;
    #####:  762:	list_files = -1;
    #####:  763:	break;
        -:  764:      case 'l':
    #####:  765:	out_quiet = 1;
    #####:  766:	list_files = 1;
    #####:  767:	break;
        -:  768:      case 'n':
    #####:  769:	out_line = 1;
    #####:  770:	break;
        -:  771:      case 'q':
    #####:  772:	out_quiet = 1;
    #####:  773:	break;
        -:  774:      case 's':
    #####:  775:	suppress_errors = 1;
    #####:  776:	break;
        -:  777:      case 'v':
    #####:  778:	out_invert = 1;
    #####:  779:	break;
        -:  780:      case 'w':
    #####:  781:	match_words = 1;
    #####:  782:	break;
        -:  783:      case 'x':
    #####:  784:	match_lines = 1;
    #####:  785:	break;
        -:  786:      default:
    #####:  787:	usage();
    #####:  788:	break;
        -:  789:      }
        -:  790:
        1:  791:  if (!keyfound)
        1:  792:    if (optind < argc)
        -:  793:      {
    #####:  794:	keys = argv[optind++];
    #####:  795:	keycc = strlen(keys);
        -:  796:      }
        -:  797:    else
        1:  798:      usage();
        -:  799:
    #####:  800:  if (!matcher)
    #####:  801:    matcher = prog;
        -:  802:
    #####:  803:  if (!setmatcher(matcher) && !setmatcher("default"))
    #####:  804:    abort();
        -:  805:
    #####:  806:  (*compile)(keys, keycc);
        -:  807:
    #####:  808:  if (argc - optind > 1 && !no_filenames)
    #####:  809:    out_file = 1;
        -:  810:
    #####:  811:  status = 1;
        -:  812:
    #####:  813:  if (optind < argc)
    #####:  814:    while (optind < argc)
        -:  815:      {
    #####:  816:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
    #####:  817:	if (desc < 0)
        -:  818:	  {
    #####:  819:	    if (!suppress_errors)
    #####:  820:	      error(argv[optind], errno);
        -:  821:	  }
        -:  822:	else
        -:  823:	  {
    #####:  824:	    filename = desc == 0 ? "(standard input)" : argv[optind];
    #####:  825:	    count = grep(desc);
    #####:  826:	    if (count_matches)
        -:  827:	      {
    #####:  828:		if (out_file)
    #####:  829:		  printf("%s:", filename);
    #####:  830:		printf("%d\n", count);
        -:  831:	      }
    #####:  832:	    if (count)
        -:  833:	      {
    #####:  834:		status = 0;
    #####:  835:		if (list_files == 1)
    #####:  836:		  printf("%s\n", filename);
        -:  837:	      }
    #####:  838:	    else if (list_files == -1)
    #####:  839:	      printf("%s\n", filename);
        -:  840:	  }
    #####:  841:	if (desc != 0)
    #####:  842:	  close(desc);
    #####:  843:	++optind;
        -:  844:      }
        -:  845:  else
        -:  846:    {
    #####:  847:      filename = "(standard input)";
    #####:  848:      count = grep(0);
    #####:  849:      if (count_matches)
    #####:  850:	printf("%d\n", count);
    #####:  851:      if (count)
        -:  852:	{
    #####:  853:	  status = 0;
    #####:  854:	  if (list_files == 1)
    #####:  855:	    printf("(standard input)\n");
        -:  856:	}
    #####:  857:      else if (list_files == -1)
    #####:  858:	printf("(standard input)\n");
        -:  859:    }
        -:  860:
    #####:  861:  exit(errseen ? 2 : status);
        -:  862:}
        -:  863:/* Getopt for GNU.
        -:  864:   NOTE: getopt is now part of the C library, so if you don't know what
        -:  865:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
        -:  866:   before changing it!
        -:  867:
        -:  868:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
        -:  869:   	Free Software Foundation, Inc.
        -:  870:
        -:  871:   This program is free software; you can redistribute it and/or modify it
        -:  872:   under the terms of the GNU General Public License as published by the
        -:  873:   Free Software Foundation; either version 2, or (at your option) any
        -:  874:   later version.
        -:  875:
        -:  876:   This program is distributed in the hope that it will be useful,
        -:  877:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:  878:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:  879:   GNU General Public License for more details.
        -:  880:
        -:  881:   You should have received a copy of the GNU General Public License
        -:  882:   along with this program; if not, write to the Free Software
        -:  883:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -:  884:
        -:  885:/* NOTE!!!  AIX requires this to be the first thing in the file.
        -:  886:   Do not put ANYTHING before it!  */
        -:  887:#if !defined (__GNUC__) && defined (_AIX)
        -:  888: #pragma alloca
        -:  889:#endif
        -:  890:
        -:  891:#ifdef HAVE_CONFIG_H
        -:  892:#include "config.h"
        -:  893:#define flag_config 1
        -:  894:#endif
        -:  895:
        -:  896:#if (defined( __GNUC__) && (!defined(LINUX)))
        -:  897:#define alloca __builtin_alloca
        -:  898:#else /* not __GNUC__ */
        -:  899:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
        -:  900:#include <alloca.h>
        -:  901:#define flag_alloca 1
        -:  902:#else
        -:  903:#ifndef _AIX
        -:  904:char *alloca ();
        -:  905:#endif
        -:  906:#endif /* alloca.h */
        -:  907:#endif /* not __GNUC__ */
        -:  908:
        -:  909:#if !__STDC__ && !defined(const) && IN_GCC
        -:  910:#define const
        -:  911:#endif
        -:  912:
        -:  913:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
        -:  914:#ifndef _NO_PROTO
        -:  915:#define _NO_PROTO
        -:  916:#endif
        -:  917:
        -:  918:/*#include <stdio.h> */
        -:  919:
        -:  920:/* Comment out all this code if we are using the GNU C Library, and are not
        -:  921:   actually compiling the library itself.  This code is part of the GNU C
        -:  922:   Library, but also included in many other GNU distributions.  Compiling
        -:  923:   and linking in this code is a waste when using the GNU C library
        -:  924:   (especially if it is a shared library).  Rather than having every GNU
        -:  925:   program understand `configure --with-gnu-libc' and omit the object files,
        -:  926:   it is simpler to just do this in the source for each such file.  */
        -:  927:
        -:  928:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -:  929:
        -:  930:
        -:  931:/* This needs to come after some library #include
        -:  932:   to get __GNU_LIBRARY__ defined.  */
        -:  933:#ifdef	__GNU_LIBRARY__
        -:  934:#undef	alloca
        -:  935:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -:  936:   contain conflicting prototypes for getopt.  */
        -:  937:#if flag_stdlib==0   
        -:  938:#include <stdlib.h>
        -:  939:#define flag_stdlib 1
        -:  940:#endif
        -:  941:#else	/* Not GNU C library.  */
        -:  942:#define	__alloca	alloca
        -:  943:#endif	/* GNU C library.  */
        -:  944:
        -:  945:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
        -:  946:   long-named option.  Because this is not POSIX.2 compliant, it is
        -:  947:   being phased out.  */
        -:  948:/* #define GETOPT_COMPAT */
        -:  949:
        -:  950:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -:  951:   but it behaves differently for the user, since it allows the user
        -:  952:   to intersperse the options with the other arguments.
        -:  953:
        -:  954:   As `getopt' works, it permutes the elements of ARGV so that,
        -:  955:   when it is done, all the options precede everything else.  Thus
        -:  956:   all application programs are extended to handle flexible argument order.
        -:  957:
        -:  958:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -:  959:   Then the behavior is completely standard.
        -:  960:
        -:  961:   GNU application programs can use a third alternative mode in which
        -:  962:   they can distinguish the relative order of options and other arguments.  */
        -:  963:
        -:  964:#include "getopt.h"
        -:  965:
        -:  966:/* For communication from `getopt' to the caller.
        -:  967:   When `getopt' finds an option that takes an argument,
        -:  968:   the argument value is returned here.
        -:  969:   Also, when `ordering' is RETURN_IN_ORDER,
        -:  970:   each non-option ARGV-element is returned here.  */
        -:  971:
        -:  972:char *optarg = 0;
        -:  973:
        -:  974:/* Index in ARGV of the next element to be scanned.
        -:  975:   This is used for communication to and from the caller
        -:  976:   and for communication between successive calls to `getopt'.
        -:  977:
        -:  978:   On entry to `getopt', zero means this is the first call; initialize.
        -:  979:
        -:  980:   When `getopt' returns EOF, this is the index of the first of the
        -:  981:   non-option elements that the caller should itself scan.
        -:  982:
        -:  983:   Otherwise, `optind' communicates from one call to the next
        -:  984:   how much of ARGV has been scanned so far.  */
        -:  985:
        -:  986:/* XXX 1003.2 says this must be 1 before any call.  */
        -:  987:int optind = 0;
        -:  988:
        -:  989:/* The next char to be scanned in the option-element
        -:  990:   in which the last option character we returned was found.
        -:  991:   This allows us to pick up the scan where we left off.
        -:  992:
        -:  993:   If this is zero, or a null string, it means resume the scan
        -:  994:   by advancing to the next ARGV-element.  */
        -:  995:
        -:  996:static char *nextchar;
        -:  997:
        -:  998:/* Callers store zero here to inhibit the error message
        -:  999:   for unrecognized options.  */
        -: 1000:
        -: 1001:int opterr = 1;
        -: 1002:
        -: 1003:/* Set to an option character which was unrecognized.
        -: 1004:   This must be initialized on some systems to avoid linking in the
        -: 1005:   system's own getopt implementation.  */
        -: 1006:
        -: 1007:int optopt = '?';
        -: 1008:
        -: 1009:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 1010:
        -: 1011:   If the caller did not specify anything,
        -: 1012:   the default is REQUIRE_ORDER if the environment variable
        -: 1013:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 1014:
        -: 1015:   REQUIRE_ORDER means don't recognize them as options;
        -: 1016:   stop option processing when the first non-option is seen.
        -: 1017:   This is what Unix does.
        -: 1018:   This mode of operation is selected by either setting the environment
        -: 1019:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 1020:   of the list of option characters.
        -: 1021:
        -: 1022:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 1023:   so that eventually all the non-options are at the end.  This allows options
        -: 1024:   to be given in any order, even with programs that were not written to
        -: 1025:   expect this.
        -: 1026:
        -: 1027:   RETURN_IN_ORDER is an option available to programs that were written
        -: 1028:   to expect options and other ARGV-elements in any order and that care about
        -: 1029:   the ordering of the two.  We describe each non-option ARGV-element
        -: 1030:   as if it were the argument of an option with character code 1.
        -: 1031:   Using `-' as the first character of the list of option characters
        -: 1032:   selects this mode of operation.
        -: 1033:
        -: 1034:   The special argument `--' forces an end of option-scanning regardless
        -: 1035:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 1036:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
        -: 1037:
        -: 1038:static enum
        -: 1039:{
        -: 1040:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 1041:} ordering;
        -: 1042:
        -: 1043:#ifdef	__GNU_LIBRARY__
        -: 1044:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 1045:   because there are many ways it can cause trouble.
        -: 1046:   On some systems, it contains special magic macros that don't work
        -: 1047:   in GCC.  */
        -: 1048:#if flag_string==0   
        -: 1049:#include <string.h>
        -: 1050:#define flag_string 1
        -: 1051:#endif
        -: 1052:#define	my_index	strchr
        -: 1053:#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
        -: 1054:#else
        -: 1055:
        -: 1056:/* Avoid depending on library functions or files
        -: 1057:   whose names are inconsistent.  */
        -: 1058:
        -: 1059:char *getenv ();
        -: 1060:
        -: 1061:static char *
        -: 1062:my_index (str, chr)
        -: 1063:     const char *str;
        -: 1064:     int chr;
        -: 1065:{
        -: 1066:  while (*str)
        -: 1067:    {
        -: 1068:      if (*str == chr)
        -: 1069:	return (char *) str;
        -: 1070:      str++;
        -: 1071:    }
        -: 1072:  return 0;
        -: 1073:}
        -: 1074:
        -: 1075:static void
        -: 1076:my_bcopy (from, to, size)
        -: 1077:     const char *from;
        -: 1078:     char *to;
        -: 1079:     int size;
        -: 1080:{
        -: 1081:  int i;
        -: 1082:  for (i = 0; i < size; i++)
        -: 1083:    to[i] = from[i];
        -: 1084:}
        -: 1085:#endif				/* GNU C library.  */
        -: 1086:
        -: 1087:/* Handle permutation of arguments.  */
        -: 1088:
        -: 1089:/* Describe the part of ARGV that contains non-options that have
        -: 1090:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 1091:   `last_nonopt' is the index after the last of them.  */
        -: 1092:
        -: 1093:static int first_nonopt;
        -: 1094:static int last_nonopt;
        -: 1095:
        -: 1096:/* Exchange two adjacent subsequences of ARGV.
        -: 1097:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 1098:   which contains all the non-options that have been skipped so far.
        -: 1099:   The other is elements [last_nonopt,optind), which contains all
        -: 1100:   the options processed since those non-options were skipped.
        -: 1101:
        -: 1102:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 1103:   the new indices of the non-options in ARGV after they are moved.  */
        -: 1104:
        -: 1105:static void
        -: 1106:exchange (argv)
        -: 1107:     char **argv;
        -: 1108:{
        -: 1109:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
        -: 1110:  char **temp = (char **) __alloca (nonopts_size);
        -: 1111:
        -: 1112:  /* Interchange the two blocks of data in ARGV.  */
        -: 1113:
        -: 1114:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
        -: 1115:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
        -: 1116:	    (optind - last_nonopt) * sizeof (char *));
        -: 1117:  my_bcopy ((char *) temp,
        -: 1118:	    (char *) &argv[first_nonopt + optind - last_nonopt],
        -: 1119:	    nonopts_size);
        -: 1120:
        -: 1121:  /* Update records for the slots the non-options now occupy.  */
        -: 1122:
        -: 1123:  first_nonopt += (optind - last_nonopt);
        -: 1124:  last_nonopt = optind;
        -: 1125:}
        -: 1126:
        -: 1127:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 1128:   given in OPTSTRING.
        -: 1129:
        -: 1130:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 1131:   then it is an option element.  The characters of this element
        -: 1132:   (aside from the initial '-') are option characters.  If `getopt'
        -: 1133:   is called repeatedly, it returns successively each of the option characters
        -: 1134:   from each of the option elements.
        -: 1135:
        -: 1136:   If `getopt' finds another option character, it returns that character,
        -: 1137:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 1138:   resume the scan with the following option character or ARGV-element.
        -: 1139:
        -: 1140:   If there are no more option characters, `getopt' returns `EOF'.
        -: 1141:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 1142:   that is not an option.  (The ARGV-elements have been permuted
        -: 1143:   so that those that are not options now come last.)
        -: 1144:
        -: 1145:   OPTSTRING is a string containing the legitimate option characters.
        -: 1146:   If an option character is seen that is not listed in OPTSTRING,
        -: 1147:   return '?' after printing an error message.  If you set `opterr' to
        -: 1148:   zero, the error message is suppressed but we still return '?'.
        -: 1149:
        -: 1150:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 1151:   so the following text in the same ARGV-element, or the text of the following
        -: 1152:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 1153:   wants an optional arg; if there is text in the current ARGV-element,
        -: 1154:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 1155:
        -: 1156:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 1157:   handling the non-option ARGV-elements.
        -: 1158:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 1159:
        -: 1160:   Long-named options begin with `--' instead of `-'.
        -: 1161:   Their names may be abbreviated as long as the abbreviation is unique
        -: 1162:   or is an exact match for some defined option.  If they have an
        -: 1163:   argument, it follows the option name in the same ARGV-element, separated
        -: 1164:   from the option name by a `=', or else the in next ARGV-element.
        -: 1165:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 1166:   `flag' field is nonzero, the value of the option's `val' field
        -: 1167:   if the `flag' field is zero.
        -: 1168:
        -: 1169:   The elements of ARGV aren't really const, because we permute them.
        -: 1170:   But we pretend they're const in the prototype to be compatible
        -: 1171:   with other systems.
        -: 1172:
        -: 1173:   LONGOPTS is a vector of `struct option' terminated by an
        -: 1174:   element containing a name which is zero.
        -: 1175:
        -: 1176:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 1177:   It is only valid when a long-named option has been found by the most
        -: 1178:   recent call.
        -: 1179:
        -: 1180:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 1181:   long-named options.  */
        -: 1182:
        -: 1183:int
        -: 1184:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 1185:     int argc;
        -: 1186:     char *const *argv;
        -: 1187:     const char *optstring;
        -: 1188:     const struct option *longopts;
        -: 1189:     int *longind;
        -: 1190:     int long_only;
        -: 1191:{
        -: 1192:  int option_index;
        -: 1193:
        -: 1194:  optarg = 0;
        -: 1195:
        -: 1196:  /* Initialize the internal data when the first call is made.
        -: 1197:     Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 1198:     is the program name); the sequence of previously skipped
        -: 1199:     non-option ARGV-elements is empty.  */
        -: 1200:
        -: 1201:  if (optind == 0)
        -: 1202:    {
        -: 1203:      first_nonopt = last_nonopt = optind = 1;
        -: 1204:
        -: 1205:      nextchar = NULL;
        -: 1206:
        -: 1207:      /* Determine how to handle the ordering of options and nonoptions.  */
        -: 1208:
        -: 1209:      if (optstring[0] == '-')
        -: 1210:	{
        -: 1211:	  ordering = RETURN_IN_ORDER;
        -: 1212:	  ++optstring;
        -: 1213:	}
        -: 1214:      else if (optstring[0] == '+')
        -: 1215:	{
        -: 1216:	  ordering = REQUIRE_ORDER;
        -: 1217:	  ++optstring;
        -: 1218:	}
        -: 1219:      else if (getenv ("POSIXLY_CORRECT") != NULL)
        -: 1220:	ordering = REQUIRE_ORDER;
        -: 1221:      else
        -: 1222:	ordering = PERMUTE;
        -: 1223:    }
        -: 1224:
        -: 1225:  if (nextchar == NULL || *nextchar == '\0')
        -: 1226:    {
        -: 1227:      if (ordering == PERMUTE)
        -: 1228:	{
        -: 1229:	  /* If we have just processed some options following some non-options,
        -: 1230:	     exchange them so that the options come first.  */
        -: 1231:
        -: 1232:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 1233:	    exchange ((char **) argv);
        -: 1234:	  else if (last_nonopt != optind)
        -: 1235:	    first_nonopt = optind;
        -: 1236:
        -: 1237:	  /* Now skip any additional non-options
        -: 1238:	     and extend the range of non-options previously skipped.  */
        -: 1239:
        -: 1240:	  while (optind < argc
        -: 1241:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 1242:#ifdef GETOPT_COMPAT
        -: 1243:		 && (longopts == NULL
        -: 1244:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -: 1245:#endif				/* GETOPT_COMPAT */
        -: 1246:		 )
        -: 1247:	    optind++;
        -: 1248:	  last_nonopt = optind;
        -: 1249:	}
        -: 1250:
        -: 1251:      /* Special ARGV-element `--' means premature end of options.
        -: 1252:	 Skip it like a null option,
        -: 1253:	 then exchange with previous non-options as if it were an option,
        -: 1254:	 then skip everything else like a non-option.  */
        -: 1255:
        -: 1256:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 1257:	{
        -: 1258:	  optind++;
        -: 1259:
        -: 1260:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 1261:	    exchange ((char **) argv);
        -: 1262:	  else if (first_nonopt == last_nonopt)
        -: 1263:	    first_nonopt = optind;
        -: 1264:	  last_nonopt = argc;
        -: 1265:
        -: 1266:	  optind = argc;
        -: 1267:	}
        -: 1268:
        -: 1269:      /* If we have done all the ARGV-elements, stop the scan
        -: 1270:	 and back over any non-options that we skipped and permuted.  */
        -: 1271:
        -: 1272:      if (optind == argc)
        -: 1273:	{
        -: 1274:	  /* Set the next-arg-index to point at the non-options
        -: 1275:	     that we previously skipped, so the caller will digest them.  */
        -: 1276:	  if (first_nonopt != last_nonopt)
        -: 1277:	    optind = first_nonopt;
        -: 1278:	  return EOF;
        -: 1279:	}
        -: 1280:
        -: 1281:      /* If we have come to a non-option and did not permute it,
        -: 1282:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 1283:
        -: 1284:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 1285:#ifdef GETOPT_COMPAT
        -: 1286:	  && (longopts == NULL
        -: 1287:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
        -: 1288:#endif				/* GETOPT_COMPAT */
        -: 1289:	  )
        -: 1290:	{
        -: 1291:	  if (ordering == REQUIRE_ORDER)
        -: 1292:	    return EOF;
        -: 1293:	  optarg = argv[optind++];
        -: 1294:	  return 1;
        -: 1295:	}
        -: 1296:
        -: 1297:      /* We have found another option-ARGV-element.
        -: 1298:	 Start decoding its characters.  */
        -: 1299:
        -: 1300:      nextchar = (argv[optind] + 1
        -: 1301:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 1302:    }
        -: 1303:
        -: 1304:  if (longopts != NULL
        -: 1305:      && ((argv[optind][0] == '-'
        -: 1306:	   && (argv[optind][1] == '-' || long_only))
        -: 1307:#ifdef GETOPT_COMPAT
        -: 1308:	  || argv[optind][0] == '+'
        -: 1309:#endif				/* GETOPT_COMPAT */
        -: 1310:	  ))
        -: 1311:    {
        -: 1312:      const struct option *p;
        -: 1313:      char *s = nextchar;
        -: 1314:      int exact = 0;
        -: 1315:      int ambig = 0;
        -: 1316:      const struct option *pfound = NULL;
        -: 1317:      int indfound;
        -: 1318:
        -: 1319:      while (*s && *s != '=')
        -: 1320:	s++;
        -: 1321:
        -: 1322:      /* Test all options for either exact match or abbreviated matches.  */
        -: 1323:      for (p = longopts, option_index = 0; p->name;
        -: 1324:	   p++, option_index++)
        -: 1325:	if (!strncmp (p->name, nextchar, s - nextchar))
        -: 1326:	  {
        -: 1327:	    if (s - nextchar == strlen (p->name))
        -: 1328:	      {
        -: 1329:		/* Exact match found.  */
        -: 1330:		pfound = p;
        -: 1331:		indfound = option_index;
        -: 1332:		exact = 1;
        -: 1333:		break;
        -: 1334:	      }
        -: 1335:	    else if (pfound == NULL)
        -: 1336:	      {
        -: 1337:		/* First nonexact match found.  */
        -: 1338:		pfound = p;
        -: 1339:		indfound = option_index;
        -: 1340:	      }
        -: 1341:	    else
        -: 1342:	      /* Second nonexact match found.  */
        -: 1343:	      ambig = 1;
        -: 1344:	  }
        -: 1345:
        -: 1346:      if (ambig && !exact)
        -: 1347:	{
        -: 1348:	  if (opterr)
        -: 1349:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
        -: 1350:		     argv[0], argv[optind]);
        -: 1351:	  nextchar += strlen (nextchar);
        -: 1352:	  optind++;
        -: 1353:	  return '?';
        -: 1354:	}
        -: 1355:
        -: 1356:      if (pfound != NULL)
        -: 1357:	{
        -: 1358:	  option_index = indfound;
        -: 1359:	  optind++;
        -: 1360:	  if (*s)
        -: 1361:	    {
        -: 1362:	      /* Don't test has_arg with >, because some C compilers don't
        -: 1363:		 allow it to be used on enums.  */
        -: 1364:	      if (pfound->has_arg)
        -: 1365:		optarg = s + 1;
        -: 1366:	      else
        -: 1367:		{
        -: 1368:		  if (opterr)
        -: 1369:		    {
        -: 1370:		      if (argv[optind - 1][1] == '-')
        -: 1371:			/* --option */
        -: 1372:			fprintf (stderr,
        -: 1373:				 "%s: option `--%s' doesn't allow an argument\n",
        -: 1374:				 argv[0], pfound->name);
        -: 1375:		      else
        -: 1376:			/* +option or -option */
        -: 1377:			fprintf (stderr,
        -: 1378:			     "%s: option `%c%s' doesn't allow an argument\n",
        -: 1379:			     argv[0], argv[optind - 1][0], pfound->name);
        -: 1380:		    }
        -: 1381:		  nextchar += strlen (nextchar);
        -: 1382:		  return '?';
        -: 1383:		}
        -: 1384:	    }
        -: 1385:	  else if (pfound->has_arg == 1)
        -: 1386:	    {
        -: 1387:	      if (optind < argc)
        -: 1388:		optarg = argv[optind++];
        -: 1389:	      else
        -: 1390:		{
        -: 1391:		  if (opterr)
        -: 1392:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
        -: 1393:			     argv[0], argv[optind - 1]);
        -: 1394:		  nextchar += strlen (nextchar);
        -: 1395:		  return optstring[0] == ':' ? ':' : '?';
        -: 1396:		}
        -: 1397:	    }
        -: 1398:	  nextchar += strlen (nextchar);
        -: 1399:	  if (longind != NULL)
        -: 1400:	    *longind = option_index;
        -: 1401:	  if (pfound->flag)
        -: 1402:	    {
        -: 1403:	      *(pfound->flag) = pfound->val;
        -: 1404:	      return 0;
        -: 1405:	    }
        -: 1406:	  return pfound->val;
        -: 1407:	}
        -: 1408:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 1409:	 or the option starts with '--' or is not a valid short
        -: 1410:	 option, then it's an error.
        -: 1411:	 Otherwise interpret it as a short option.  */
        -: 1412:      if (!long_only || argv[optind][1] == '-'
        -: 1413:#ifdef GETOPT_COMPAT
        -: 1414:	  || argv[optind][0] == '+'
        -: 1415:#endif				/* GETOPT_COMPAT */
        -: 1416:	  || my_index (optstring, *nextchar) == NULL)
        -: 1417:	{
        -: 1418:	  if (opterr)
        -: 1419:	    {
        -: 1420:	      if (argv[optind][1] == '-')
        -: 1421:		/* --option */
        -: 1422:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
        -: 1423:			 argv[0], nextchar);
        -: 1424:	      else
        -: 1425:		/* +option or -option */
        -: 1426:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
        -: 1427:			 argv[0], argv[optind][0], nextchar);
        -: 1428:	    }
        -: 1429:	  nextchar = (char *) "";
        -: 1430:	  optind++;
        -: 1431:	  return '?';
        -: 1432:	}
        -: 1433:    }
        -: 1434:
        -: 1435:  /* Look at and handle the next option-character.  */
        -: 1436:
        -: 1437:  {
        -: 1438:    char c = *nextchar++;
        -: 1439:    char *temp = my_index (optstring, c);
        -: 1440:
        -: 1441:    /* Increment `optind' when we start to process its last character.  */
        -: 1442:    if (*nextchar == '\0')
        -: 1443:      ++optind;
        -: 1444:
        -: 1445:    if (temp == NULL || c == ':')
        -: 1446:      {
        -: 1447:	if (opterr)
        -: 1448:	  {
        -: 1449:#if 0
        -: 1450:	    if (c < 040 || c >= 0177)
        -: 1451:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
        -: 1452:		       argv[0], c);
        -: 1453:	    else
        -: 1454:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
        -: 1455:#else
        -: 1456:	    /* 1003.2 specifies the format of this message.  */
        -: 1457:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
        -: 1458:#endif
        -: 1459:	  }
        -: 1460:	optopt = c;
        -: 1461:	return '?';
        -: 1462:      }
        -: 1463:    if (temp[1] == ':')
        -: 1464:      {
        -: 1465:	if (temp[2] == ':')
        -: 1466:	  {
        -: 1467:	    /* This is an option that accepts an argument optionally.  */
        -: 1468:	    if (*nextchar != '\0')
        -: 1469:	      {
        -: 1470:		optarg = nextchar;
        -: 1471:		optind++;
        -: 1472:	      }
        -: 1473:	    else
        -: 1474:	      optarg = 0;
        -: 1475:	    nextchar = NULL;
        -: 1476:	  }
        -: 1477:	else
        -: 1478:	  {
        -: 1479:	    /* This is an option that requires an argument.  */
        -: 1480:	    if (*nextchar != '\0')
        -: 1481:	      {
        -: 1482:		optarg = nextchar;
        -: 1483:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 1484:		   we must advance to the next element now.  */
        -: 1485:		optind++;
        -: 1486:	      }
        -: 1487:	    else if (optind == argc)
        -: 1488:	      {
        -: 1489:		if (opterr)
        -: 1490:		  {
        -: 1491:#if 0
        -: 1492:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
        -: 1493:			     argv[0], c);
        -: 1494:#else
        -: 1495:		    /* 1003.2 specifies the format of this message.  */
        -: 1496:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
        -: 1497:			     argv[0], c);
        -: 1498:#endif
        -: 1499:		  }
        -: 1500:		optopt = c;
        -: 1501:		if (optstring[0] == ':')
        -: 1502:		  c = ':';
        -: 1503:		else
        -: 1504:		  c = '?';
        -: 1505:	      }
        -: 1506:	    else
        -: 1507:	      /* We already incremented `optind' once;
        -: 1508:		 increment it again when taking next ARGV-elt as argument.  */
        -: 1509:	      optarg = argv[optind++];
        -: 1510:	    nextchar = NULL;
        -: 1511:	  }
        -: 1512:      }
        -: 1513:    return c;
        -: 1514:  }
        -: 1515:}
        -: 1516:
        -: 1517:int
        -: 1518:getopt (argc, argv, optstring)
        -: 1519:     int argc;
        -: 1520:     char *const *argv;
        -: 1521:     const char *optstring;
        -: 1522:{
        -: 1523:  return _getopt_internal (argc, argv, optstring,
        -: 1524:			   (const struct option *) 0,
        -: 1525:			   (int *) 0,
        -: 1526:			   0);
        -: 1527:}
        -: 1528:
        -: 1529:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -: 1530:
        -: 1531:#ifdef TEST
        -: 1532:
        -: 1533:/* Compile with -DTEST to make an executable for use in testing
        -: 1534:   the above definition of `getopt'.  */
        -: 1535:
        -: 1536:int
        -: 1537:main (argc, argv)
        -: 1538:     int argc;
        -: 1539:     char **argv;
        -: 1540:{
        -: 1541:  int c;
        -: 1542:  int digit_optind = 0;
        -: 1543:
        -: 1544:  while (1)
        -: 1545:    {
        -: 1546:      int this_option_optind = optind ? optind : 1;
        -: 1547:
        -: 1548:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 1549:      if (c == EOF)
        -: 1550:	break;
        -: 1551:
        -: 1552:      switch (c)
        -: 1553:	{
        -: 1554:	case '0':
        -: 1555:	case '1':
        -: 1556:	case '2':
        -: 1557:	case '3':
        -: 1558:	case '4':
        -: 1559:	case '5':
        -: 1560:	case '6':
        -: 1561:	case '7':
        -: 1562:	case '8':
        -: 1563:	case '9':
        -: 1564:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 1565:	    printf ("digits occur in two different argv-elements.\n");
        -: 1566:	  digit_optind = this_option_optind;
        -: 1567:	  printf ("option %c\n", c);
        -: 1568:	  break;
        -: 1569:
        -: 1570:	case 'a':
        -: 1571:	  printf ("option a\n");
        -: 1572:	  break;
        -: 1573:
        -: 1574:	case 'b':
        -: 1575:	  printf ("option b\n");
        -: 1576:	  break;
        -: 1577:
        -: 1578:	case 'c':
        -: 1579:	  printf ("option c with value `%s'\n", optarg);
        -: 1580:	  break;
        -: 1581:
        -: 1582:	case '?':
        -: 1583:	  break;
        -: 1584:
        -: 1585:	default:
        -: 1586:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 1587:	}
        -: 1588:    }
        -: 1589:
        -: 1590:  if (optind < argc)
        -: 1591:    {
        -: 1592:      printf ("non-option ARGV-elements: ");
        -: 1593:      while (optind < argc)
        -: 1594:	printf ("%s ", argv[optind++]);
        -: 1595:      printf ("\n");
        -: 1596:    }
        -: 1597:
        -: 1598:  exit (0);
        -: 1599:}
        -: 1600:
        -: 1601:#endif /* TEST */
        -: 1602:/* Extended regular expression matching and search library,
        -: 1603:   version 0.12.
        -: 1604:   (Implements POSIX draft P10003.2/D11.2, except for
        -: 1605:   internationalization features.)
        -: 1606:
        -: 1607:   Copyright (C) 1993 Free Software Foundation, Inc.
        -: 1608:
        -: 1609:   This program is free software; you can redistribute it and/or modify
        -: 1610:   it under the terms of the GNU General Public License as published by
        -: 1611:   the Free Software Foundation; either version 2, or (at your option)
        -: 1612:   any later version.
        -: 1613:
        -: 1614:   This program is distributed in the hope that it will be useful,
        -: 1615:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1616:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1617:   GNU General Public License for more details.
        -: 1618:
        -: 1619:   You should have received a copy of the GNU General Public License
        -: 1620:   along with this program; if not, write to the Free Software
        -: 1621:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 1622:
        -: 1623:/* AIX requires this to be the first thing in the file. */
        -: 1624:#if defined (_AIX) && !defined (REGEX_MALLOC)
        -: 1625:  #pragma alloca
        -: 1626:#endif
        -: 1627:
        -: 1628:#define _GNU_SOURCE
        -: 1629:
        -: 1630:/* We need this for `regex.h', and perhaps for the Emacs include files.  */
        -: 1631:#if flag_systypes==0
        -: 1632:#include <sys/types.h>
        -: 1633:#define flag_systypes 1
        -: 1634:#endif
        -: 1635:
        -: 1636:#ifdef HAVE_CONFIG_H
        -: 1637:#if flag_config==0
        -: 1638:#include "config.h"
        -: 1639:#define flag_config 1
        -: 1640:#endif
        -: 1641:#endif
        -: 1642:
        -: 1643:/* The `emacs' switch turns on certain matching commands
        -: 1644:   that make sense only in Emacs. */
        -: 1645:#ifdef emacs
        -: 1646:
        -: 1647:#include "lisp.h"
        -: 1648:#include "buffer.h"
        -: 1649:#include "syntax.h"
        -: 1650:
        -: 1651:/* Emacs uses `NULL' as a predicate.  */
        -: 1652:#undef NULL
        -: 1653:
        -: 1654:#else  /* not emacs */
        -: 1655:
        -: 1656:/* We used to test for `BSTRING' here, but only GCC and Emacs define
        -: 1657:   `BSTRING', as far as I know, and neither of them use this code.  */
        -: 1658:#if HAVE_STRING_H || STDC_HEADERS
        -: 1659:#if flag_string==0
        -: 1660:#include <string.h>
        -: 1661:#define flag_string 1
        -: 1662:#endif
        -: 1663:#ifndef bcmp
        -: 1664:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
        -: 1665:#endif
        -: 1666:#ifndef bcopy
        -: 1667:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
        -: 1668:#endif
        -: 1669:#ifndef bzero
        -: 1670:#define bzero(s, n)	memset ((s), 0, (n))
        -: 1671:#endif
        -: 1672:#else
        -: 1673:#if flag_strings==0
        -: 1674:#include <strings.h>
        -: 1675:#define flag_strings 1
        -: 1676:#endif
        -: 1677:#endif
        -: 1678:
        -: 1679:#ifdef STDC_HEADERS
        -: 1680:#if flag_stdlib==0 
        -: 1681:#include <stdlib.h>
        -: 1682:#define flag_stdlib 1
        -: 1683:#endif
        -: 1684:#else
        -: 1685:char *malloc ();
        -: 1686:char *realloc ();
        -: 1687:#endif
        -: 1688:
        -: 1689:
        -: 1690:/* Define the syntax stuff for \<, \>, etc.  */
        -: 1691:
        -: 1692:/* This must be nonzero for the wordchar and notwordchar pattern
        -: 1693:   commands in re_match_2.  */
        -: 1694:#ifndef Sword 
        -: 1695:#define Sword 1
        -: 1696:#endif
        -: 1697:
        -: 1698:#ifdef SYNTAX_TABLE
        -: 1699:
        -: 1700:extern char *re_syntax_table;
        -: 1701:
        -: 1702:#else /* not SYNTAX_TABLE */
        -: 1703:
        -: 1704:/* How many characters in the character set.  */
        -: 1705:#define CHAR_SET_SIZE 256
        -: 1706:
        -: 1707:static char re_syntax_table[CHAR_SET_SIZE];
        -: 1708:
        -: 1709:static void
    #####: 1710:init_syntax_once ()
        -: 1711:{
        -: 1712:   register int c;
        -: 1713:   static int done = 0;
        -: 1714:
    #####: 1715:   if (done)
    #####: 1716:     return;
        -: 1717:
    #####: 1718:   bzero (re_syntax_table, sizeof re_syntax_table);
        -: 1719:
    #####: 1720:   for (c = 'a'; c <= 'z'; c++)
    #####: 1721:     re_syntax_table[c] = Sword;
        -: 1722:
    #####: 1723:   for (c = 'A'; c <= 'Z'; c++)
    #####: 1724:     re_syntax_table[c] = Sword;
        -: 1725:
    #####: 1726:   for (c = '0'; c <= '9'; c++)
    #####: 1727:     re_syntax_table[c] = Sword;
        -: 1728:
    #####: 1729:   re_syntax_table['_'] = Sword;
        -: 1730:
    #####: 1731:   done = 1;
        -: 1732:}
        -: 1733:
        -: 1734:#endif /* not SYNTAX_TABLE */
        -: 1735:
        -: 1736:#define SYNTAX(c) re_syntax_table[c]
        -: 1737:
        -: 1738:#endif /* not emacs */
        -: 1739:
        -: 1740:/* Get the interface, including the syntax bits.  */
        -: 1741:#include "regex.h"
        -: 1742:
        -: 1743:/* isalpha etc. are used for the character classes.  */
        -: 1744:#include <ctype.h>
        -: 1745:
        -: 1746:/* Jim Meyering writes:
        -: 1747:
        -: 1748:   "... Some ctype macros are valid only for character codes that
        -: 1749:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
        -: 1750:   using /bin/cc or gcc but without giving an ansi option).  So, all
        -: 1751:   ctype uses should be through macros like ISPRINT...  If
        -: 1752:   STDC_HEADERS is defined, then autoconf has verified that the ctype
        -: 1753:   macros don't need to be guarded with references to isascii. ...
        -: 1754:   Defining isascii to 1 should let any compiler worth its salt
        -: 1755:   eliminate the && through constant folding."  */
        -: 1756:#if ! defined (isascii) || defined (STDC_HEADERS)
        -: 1757:#undef isascii
        -: 1758:#define isascii(c) 1
        -: 1759:#endif
        -: 1760:
        -: 1761:#ifdef isblank
        -: 1762:#define ISBLANK(c) (isascii (c) && isblank (c))
        -: 1763:#else
        -: 1764:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
        -: 1765:#endif
        -: 1766:#ifdef isgraph
        -: 1767:#define ISGRAPH(c) (isascii (c) && isgraph (c))
        -: 1768:#else
        -: 1769:#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
        -: 1770:#endif
        -: 1771:
        -: 1772:#define ISPRINT(c) (isascii (c) && isprint (c))
        -: 1773:#define ISDIGIT(c) (isascii (c) && isdigit (c))
        -: 1774:#define ISALNUM(c) (isascii (c) && isalnum (c))
        -: 1775:#define ISALPHA(c) (isascii (c) && isalpha (c))
        -: 1776:#define ISCNTRL(c) (isascii (c) && iscntrl (c))
        -: 1777:#define ISLOWER(c) (isascii (c) && islower (c))
        -: 1778:#define ISPUNCT(c) (isascii (c) && ispunct (c))
        -: 1779:#define ISSPACE(c) (isascii (c) && isspace (c))
        -: 1780:#define ISUPPER(c) (isascii (c) && isupper (c))
        -: 1781:#define ISXDIGIT(c) (isascii (c) && isxdigit (c))
        -: 1782:
        -: 1783:#ifndef NULL
        -: 1784:#define NULL 0
        -: 1785:#endif
        -: 1786:
        -: 1787:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
        -: 1788:   since ours (we hope) works properly with all combinations of
        -: 1789:   machines, compilers, `char' and `unsigned char' argument types.
        -: 1790:   (Per Bothner suggested the basic approach.)  */
        -: 1791:#undef SIGN_EXTEND_CHAR
        -: 1792:#if __STDC__
        -: 1793:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
        -: 1794:#else  /* not __STDC__ */
        -: 1795:/* As in Harbison and Steele.  */
        -: 1796:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
        -: 1797:#endif
        -: 1798:
        -: 1799:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
        -: 1800:   use `alloca' instead of `malloc'.  This is because using malloc in
        -: 1801:   re_search* or re_match* could cause memory leaks when C-g is used in
        -: 1802:   Emacs; also, malloc is slower and causes storage fragmentation.  On
        -: 1803:   the other hand, malloc is more portable, and easier to debug.  
        -: 1804:   
        -: 1805:   Because we sometimes use alloca, some routines have to be macros,
        -: 1806:   not functions -- `alloca'-allocated space disappears at the end of the
        -: 1807:   function it is called in.  */
        -: 1808:
        -: 1809:#ifdef REGEX_MALLOC
        -: 1810:
        -: 1811:#define REGEX_ALLOCATE malloc
        -: 1812:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
        -: 1813:
        -: 1814:#else /* not REGEX_MALLOC  */
        -: 1815:
        -: 1816:/* Emacs already defines alloca, sometimes.  */
        -: 1817:#ifndef alloca
        -: 1818:
        -: 1819:/* Make alloca work the best possible way.  */
        -: 1820:#ifdef __GNUC__
        -: 1821:#define alloca __builtin_alloca
        -: 1822:#else /* not __GNUC__ */
        -: 1823:#if HAVE_ALLOCA_H
        -: 1824:#if flag_alloca==0
        -: 1825:#include <alloca.h>
        -: 1826:#define flag_alloca 1
        -: 1827:#endif 
        -: 1828:#else /* not __GNUC__ or HAVE_ALLOCA_H */
        -: 1829:#ifndef _AIX /* Already did AIX, up at the top.  */
        -: 1830:char *alloca ();
        -: 1831:#endif /* not _AIX */
        -: 1832:#endif /* not HAVE_ALLOCA_H */ 
        -: 1833:#endif /* not __GNUC__ */
        -: 1834:
        -: 1835:#endif /* not alloca */
        -: 1836:
        -: 1837:#define REGEX_ALLOCATE alloca
        -: 1838:
        -: 1839:/* Assumes a `char *destination' variable.  */
        -: 1840:#define REGEX_REALLOCATE(source, osize, nsize)				\
        -: 1841:  (destination = (char *) alloca (nsize),				\
        -: 1842:   bcopy (source, destination, osize),					\
        -: 1843:   destination)
        -: 1844:
        -: 1845:#endif /* not REGEX_MALLOC */
        -: 1846:
        -: 1847:
        -: 1848:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
        -: 1849:   `string1' or just past its end.  This works if PTR is NULL, which is
        -: 1850:   a good thing.  */
        -: 1851:#define FIRST_STRING_P(ptr) 					\
        -: 1852:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
        -: 1853:
        -: 1854:/* (Re)Allocate N items of type T using malloc, or fail.  */
        -: 1855:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
        -: 1856:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
        -: 1857:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
        -: 1858:
        -: 1859:#define BYTEWIDTH 8 /* In bits.  */
        -: 1860:
        -: 1861:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
        -: 1862:
        -: 1863:#undef MAX               /****** added later *******/
        -: 1864:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -: 1865:#define MIN(a, b) ((a) < (b) ? (a) : (b))
        -: 1866:
        -: 1867:typedef char boolean;
        -: 1868:#define false 0
        -: 1869:#define true 1
        -: 1870:
        -: 1871:/* These are the command codes that appear in compiled regular
        -: 1872:   expressions.  Some opcodes are followed by argument bytes.  A
        -: 1873:   command code can specify any interpretation whatsoever for its
        -: 1874:   arguments.  Zero bytes may appear in the compiled regular expression.
        -: 1875:
        -: 1876:   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
        -: 1877:   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
        -: 1878:   `exactn' we use here must also be 1.  */
        -: 1879:
        -: 1880:typedef enum
        -: 1881:{
        -: 1882:  no_op = 0,
        -: 1883:
        -: 1884:        /* Followed by one byte giving n, then by n literal bytes.  */
        -: 1885:  exactn = 1,
        -: 1886:
        -: 1887:        /* Matches any (more or less) character.  */
        -: 1888:  anychar,
        -: 1889:
        -: 1890:        /* Matches any one char belonging to specified set.  First
        -: 1891:           following byte is number of bitmap bytes.  Then come bytes
        -: 1892:           for a bitmap saying which chars are in.  Bits in each byte
        -: 1893:           are ordered low-bit-first.  A character is in the set if its
        -: 1894:           bit is 1.  A character too large to have a bit in the map is
        -: 1895:           automatically not in the set.  */
        -: 1896:  charset,
        -: 1897:
        -: 1898:        /* Same parameters as charset, but match any character that is
        -: 1899:           not one of those specified.  */
        -: 1900:  charset_not,
        -: 1901:
        -: 1902:        /* Start remembering the text that is matched, for storing in a
        -: 1903:           register.  Followed by one byte with the register number, in
        -: 1904:           the range 0 to one less than the pattern buffer's re_nsub
        -: 1905:           field.  Then followed by one byte with the number of groups
        -: 1906:           inner to this one.  (This last has to be part of the
        -: 1907:           start_memory only because we need it in the on_failure_jump
        -: 1908:           of re_match_2.)  */
        -: 1909:  start_memory,
        -: 1910:
        -: 1911:        /* Stop remembering the text that is matched and store it in a
        -: 1912:           memory register.  Followed by one byte with the register
        -: 1913:           number, in the range 0 to one less than `re_nsub' in the
        -: 1914:           pattern buffer, and one byte with the number of inner groups,
        -: 1915:           just like `start_memory'.  (We need the number of inner
        -: 1916:           groups here because we don't have any easy way of finding the
        -: 1917:           corresponding start_memory when we're at a stop_memory.)  */
        -: 1918:  stop_memory,
        -: 1919:
        -: 1920:        /* Match a duplicate of something remembered. Followed by one
        -: 1921:           byte containing the register number.  */
        -: 1922:  duplicate,
        -: 1923:
        -: 1924:        /* Fail unless at beginning of line.  */
        -: 1925:  begline,
        -: 1926:
        -: 1927:        /* Fail unless at end of line.  */
        -: 1928:  endline,
        -: 1929:
        -: 1930:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
        -: 1931:           of string to be matched (if not).  */
        -: 1932:  begbuf,
        -: 1933:
        -: 1934:        /* Analogously, for end of buffer/string.  */
        -: 1935:  endbuf,
        -: 1936: 
        -: 1937:        /* Followed by two byte relative address to which to jump.  */
        -: 1938:  jump, 
        -: 1939:
        -: 1940:	/* Same as jump, but marks the end of an alternative.  */
        -: 1941:  jump_past_alt,
        -: 1942:
        -: 1943:        /* Followed by two-byte relative address of place to resume at
        -: 1944:           in case of failure.  */
        -: 1945:  on_failure_jump,
        -: 1946:	
        -: 1947:        /* Like on_failure_jump, but pushes a placeholder instead of the
        -: 1948:           current string position when executed.  */
        -: 1949:  on_failure_keep_string_jump,
        -: 1950:  
        -: 1951:        /* Throw away latest failure point and then jump to following
        -: 1952:           two-byte relative address.  */
        -: 1953:  pop_failure_jump,
        -: 1954:
        -: 1955:        /* Change to pop_failure_jump if know won't have to backtrack to
        -: 1956:           match; otherwise change to jump.  This is used to jump
        -: 1957:           back to the beginning of a repeat.  If what follows this jump
        -: 1958:           clearly won't match what the repeat does, such that we can be
        -: 1959:           sure that there is no use backtracking out of repetitions
        -: 1960:           already matched, then we change it to a pop_failure_jump.
        -: 1961:           Followed by two-byte address.  */
        -: 1962:  maybe_pop_jump,
        -: 1963:
        -: 1964:        /* Jump to following two-byte address, and push a dummy failure
        -: 1965:           point. This failure point will be thrown away if an attempt
        -: 1966:           is made to use it for a failure.  A `+' construct makes this
        -: 1967:           before the first repeat.  Also used as an intermediary kind
        -: 1968:           of jump when compiling an alternative.  */
        -: 1969:  dummy_failure_jump,
        -: 1970:
        -: 1971:	/* Push a dummy failure point and continue.  Used at the end of
        -: 1972:	   alternatives.  */
        -: 1973:  push_dummy_failure,
        -: 1974:
        -: 1975:        /* Followed by two-byte relative address and two-byte number n.
        -: 1976:           After matching N times, jump to the address upon failure.  */
        -: 1977:  succeed_n,
        -: 1978:
        -: 1979:        /* Followed by two-byte relative address, and two-byte number n.
        -: 1980:           Jump to the address N times, then fail.  */
        -: 1981:  jump_n,
        -: 1982:
        -: 1983:        /* Set the following two-byte relative address to the
        -: 1984:           subsequent two-byte number.  The address *includes* the two
        -: 1985:           bytes of number.  */
        -: 1986:  set_number_at,
        -: 1987:
        -: 1988:  wordchar,	/* Matches any word-constituent character.  */
        -: 1989:  notwordchar,	/* Matches any char that is not a word-constituent.  */
        -: 1990:
        -: 1991:  wordbeg,	/* Succeeds if at word beginning.  */
        -: 1992:  wordend,	/* Succeeds if at word end.  */
        -: 1993:
        -: 1994:  wordbound,	/* Succeeds if at a word boundary.  */
        -: 1995:  notwordbound	/* Succeeds if not at a word boundary.  */
        -: 1996:
        -: 1997:#ifdef emacs
        -: 1998:  ,before_dot,	/* Succeeds if before point.  */
        -: 1999:  at_dot,	/* Succeeds if at point.  */
        -: 2000:  after_dot,	/* Succeeds if after point.  */
        -: 2001:
        -: 2002:	/* Matches any character whose syntax is specified.  Followed by
        -: 2003:           a byte which contains a syntax code, e.g., Sword.  */
        -: 2004:  syntaxspec,
        -: 2005:
        -: 2006:	/* Matches any character whose syntax is not that specified.  */
        -: 2007:  notsyntaxspec
        -: 2008:#endif /* emacs */
        -: 2009:} re_opcode_t;
        -: 2010:
        -: 2011:/* Common operations on the compiled pattern.  */
        -: 2012:
        -: 2013:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
        -: 2014:
        -: 2015:#define STORE_NUMBER(destination, number)				\
        -: 2016:  do {									\
        -: 2017:    (destination)[0] = (number) & 0377;					\
        -: 2018:    (destination)[1] = (number) >> 8;					\
        -: 2019:  } while (0)
        -: 2020:
        -: 2021:/* Same as STORE_NUMBER, except increment DESTINATION to
        -: 2022:   the byte after where the number is stored.  Therefore, DESTINATION
        -: 2023:   must be an lvalue.  */
        -: 2024:
        -: 2025:#define STORE_NUMBER_AND_INCR(destination, number)			\
        -: 2026:  do {									\
        -: 2027:    STORE_NUMBER (destination, number);					\
        -: 2028:    (destination) += 2;							\
        -: 2029:  } while (0)
        -: 2030:
        -: 2031:/* Put into DESTINATION a number stored in two contiguous bytes starting
        -: 2032:   at SOURCE.  */
        -: 2033:
        -: 2034:#define EXTRACT_NUMBER(destination, source)				\
        -: 2035:  do {									\
        -: 2036:    (destination) = *(source) & 0377;					\
        -: 2037:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
        -: 2038:  } while (0)
        -: 2039:
        -: 2040:#ifdef DEBUG
        -: 2041:static void
        -: 2042:extract_number (dest, source)
        -: 2043:    int *dest;
        -: 2044:    unsigned char *source;
        -: 2045:{
        -: 2046:  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
        -: 2047:  *dest = *source & 0377;
        -: 2048:  *dest += temp << 8;
        -: 2049:}
        -: 2050:
        -: 2051:#ifndef EXTRACT_MACROS /* To debug the macros.  */
        -: 2052:#undef EXTRACT_NUMBER
        -: 2053:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
        -: 2054:#endif /* not EXTRACT_MACROS */
        -: 2055:
        -: 2056:#endif /* DEBUG */
        -: 2057:
        -: 2058:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
        -: 2059:   SOURCE must be an lvalue.  */
        -: 2060:
        -: 2061:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
        -: 2062:  do {									\
        -: 2063:    EXTRACT_NUMBER (destination, source);				\
        -: 2064:    (source) += 2; 							\
        -: 2065:  } while (0)
        -: 2066:
        -: 2067:#ifdef DEBUG
        -: 2068:static void
        -: 2069:extract_number_and_incr (destination, source)
        -: 2070:    int *destination;
        -: 2071:    unsigned char **source;
        -: 2072:{ 
        -: 2073:  extract_number (destination, *source);
        -: 2074:  *source += 2;
        -: 2075:}
        -: 2076:
        -: 2077:#ifndef EXTRACT_MACROS
        -: 2078:#undef EXTRACT_NUMBER_AND_INCR
        -: 2079:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
        -: 2080:  extract_number_and_incr (&dest, &src)
        -: 2081:#endif /* not EXTRACT_MACROS */
        -: 2082:
        -: 2083:#endif /* DEBUG */
        -: 2084:
        -: 2085:/* If DEBUG is defined, Regex prints many voluminous messages about what
        -: 2086:   it is doing (if the variable `debug' is nonzero).  If linked with the
        -: 2087:   main program in `iregex.c', you can enter patterns and strings
        -: 2088:   interactively.  And if linked with the main program in `main.c' and
        -: 2089:   the other test files, you can run the already-written tests.  */
        -: 2090:
        -: 2091:#ifdef DEBUG
        -: 2092:
        -: 2093:/* We use standard I/O for debugging.  */
        -: 2094:/*#include <stdio.h>*/
        -: 2095:
        -: 2096:/* It is useful to test things that ``must'' be true when debugging.  */
        -: 2097:#include <assert.h>
        -: 2098:
        -: 2099:static int debug = 0;
        -: 2100:
        -: 2101:#define DEBUG_STATEMENT(e) e
        -: 2102:#define DEBUG_PRINT1(x) if (debug) printf (x)
        -: 2103:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
        -: 2104:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
        -: 2105:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
        -: 2106:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
        -: 2107:  if (debug) print_partial_compiled_pattern (s, e)
        -: 2108:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
        -: 2109:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
        -: 2110:
        -: 2111:
        -: 2112:extern void printchar ();
        -: 2113:
        -: 2114:/* Print the fastmap in human-readable form.  */
        -: 2115:
        -: 2116:void
        -: 2117:print_fastmap (fastmap)
        -: 2118:    char *fastmap;
        -: 2119:{
        -: 2120:  unsigned was_a_range = 0;
        -: 2121:  unsigned i = 0;  
        -: 2122:  
        -: 2123:  while (i < (1 << BYTEWIDTH))
        -: 2124:    {
        -: 2125:      if (fastmap[i++])
        -: 2126:	{
        -: 2127:	  was_a_range = 0;
        -: 2128:          printchar (i - 1);
        -: 2129:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
        -: 2130:            {
        -: 2131:              was_a_range = 1;
        -: 2132:              i++;
        -: 2133:            }
        -: 2134:	  if (was_a_range)
        -: 2135:            {
        -: 2136:              printf ("-");
        -: 2137:              printchar (i - 1);
        -: 2138:            }
        -: 2139:        }
        -: 2140:    }
        -: 2141:  putchar ('\n'); 
        -: 2142:}
        -: 2143:
        -: 2144:
        -: 2145:/* Print a compiled pattern string in human-readable form, starting at
        -: 2146:   the START pointer into it and ending just before the pointer END.  */
        -: 2147:
        -: 2148:void
        -: 2149:print_partial_compiled_pattern (start, end)
        -: 2150:    unsigned char *start;
        -: 2151:    unsigned char *end;
        -: 2152:{
        -: 2153:  int mcnt, mcnt2;
        -: 2154:  unsigned char *p = start;
        -: 2155:  unsigned char *pend = end;
        -: 2156:
        -: 2157:  if (start == NULL)
        -: 2158:    {
        -: 2159:      printf ("(null)\n");
        -: 2160:      return;
        -: 2161:    }
        -: 2162:    
        -: 2163:  /* Loop over pattern commands.  */
        -: 2164:  while (p < pend)
        -: 2165:    {
        -: 2166:      printf ("%d:\t", p - start);
        -: 2167:
        -: 2168:      switch ((re_opcode_t) *p++)
        -: 2169:	{
        -: 2170:        case no_op:
        -: 2171:          printf ("/no_op");
        -: 2172:          break;
        -: 2173:
        -: 2174:	case exactn:
        -: 2175:	  mcnt = *p++;
        -: 2176:          printf ("/exactn/%d", mcnt);
        -: 2177:          do
        -: 2178:	    {
        -: 2179:              putchar ('/');
        -: 2180:	      printchar (*p++);
        -: 2181:            }
        -: 2182:          while (--mcnt);
        -: 2183:          break;
        -: 2184:
        -: 2185:	case start_memory:
        -: 2186:          mcnt = *p++;
        -: 2187:          printf ("/start_memory/%d/%d", mcnt, *p++);
        -: 2188:          break;
        -: 2189:
        -: 2190:	case stop_memory:
        -: 2191:          mcnt = *p++;
        -: 2192:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
        -: 2193:          break;
        -: 2194:
        -: 2195:	case duplicate:
        -: 2196:	  printf ("/duplicate/%d", *p++);
        -: 2197:	  break;
        -: 2198:
        -: 2199:	case anychar:
        -: 2200:	  printf ("/anychar");
        -: 2201:	  break;
        -: 2202:
        -: 2203:	case charset:
        -: 2204:        case charset_not:
        -: 2205:          {
        -: 2206:            register int c, last = -100;
        -: 2207:	    register int in_range = 0;
        -: 2208:
        -: 2209:	    printf ("/charset [%s",
        -: 2210:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
        -: 2211:            
        -: 2212:            assert (p + *p < pend);
        -: 2213:
        -: 2214:            for (c = 0; c < 256; c++)
        -: 2215:	      if (c / 8 < *p
        -: 2216:		  && (p[1 + (c/8)] & (1 << (c % 8))))
        -: 2217:		{
        -: 2218:		  /* Are we starting a range?  */
        -: 2219:		  if (last + 1 == c && ! in_range)
        -: 2220:		    {
        -: 2221:		      putchar ('-');
        -: 2222:		      in_range = 1;
        -: 2223:		    }
        -: 2224:		  /* Have we broken a range?  */
        -: 2225:		  else if (last + 1 != c && in_range)
        -: 2226:              {
        -: 2227:		      printchar (last);
        -: 2228:		      in_range = 0;
        -: 2229:		    }
        -: 2230:                
        -: 2231:		  if (! in_range)
        -: 2232:		    printchar (c);
        -: 2233:
        -: 2234:		  last = c;
        -: 2235:              }
        -: 2236:
        -: 2237:	    if (in_range)
        -: 2238:	      printchar (last);
        -: 2239:
        -: 2240:	    putchar (']');
        -: 2241:
        -: 2242:	    p += 1 + *p;
        -: 2243:	  }
        -: 2244:	  break;
        -: 2245:
        -: 2246:	case begline:
        -: 2247:	  printf ("/begline");
        -: 2248:          break;
        -: 2249:
        -: 2250:	case endline:
        -: 2251:          printf ("/endline");
        -: 2252:          break;
        -: 2253:
        -: 2254:	case on_failure_jump:
        -: 2255:          extract_number_and_incr (&mcnt, &p);
        -: 2256:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
        -: 2257:          break;
        -: 2258:
        -: 2259:	case on_failure_keep_string_jump:
        -: 2260:          extract_number_and_incr (&mcnt, &p);
        -: 2261:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
        -: 2262:          break;
        -: 2263:
        -: 2264:	case dummy_failure_jump:
        -: 2265:          extract_number_and_incr (&mcnt, &p);
        -: 2266:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
        -: 2267:          break;
        -: 2268:
        -: 2269:	case push_dummy_failure:
        -: 2270:          printf ("/push_dummy_failure");
        -: 2271:          break;
        -: 2272:          
        -: 2273:        case maybe_pop_jump:
        -: 2274:          extract_number_and_incr (&mcnt, &p);
        -: 2275:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
        -: 2276:	  break;
        -: 2277:
        -: 2278:        case pop_failure_jump:
        -: 2279:	  extract_number_and_incr (&mcnt, &p);
        -: 2280:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
        -: 2281:	  break;          
        -: 2282:          
        -: 2283:        case jump_past_alt:
        -: 2284:	  extract_number_and_incr (&mcnt, &p);
        -: 2285:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
        -: 2286:	  break;          
        -: 2287:          
        -: 2288:        case jump:
        -: 2289:	  extract_number_and_incr (&mcnt, &p);
        -: 2290:  	  printf ("/jump to %d", p + mcnt - start);
        -: 2291:	  break;
        -: 2292:
        -: 2293:        case succeed_n: 
        -: 2294:          extract_number_and_incr (&mcnt, &p);
        -: 2295:          extract_number_and_incr (&mcnt2, &p);
        -: 2296:	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
        -: 2297:          break;
        -: 2298:        
        -: 2299:        case jump_n: 
        -: 2300:          extract_number_and_incr (&mcnt, &p);
        -: 2301:          extract_number_and_incr (&mcnt2, &p);
        -: 2302:	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
        -: 2303:          break;
        -: 2304:        
        -: 2305:        case set_number_at: 
        -: 2306:          extract_number_and_incr (&mcnt, &p);
        -: 2307:          extract_number_and_incr (&mcnt2, &p);
        -: 2308:	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
        -: 2309:          break;
        -: 2310:        
        -: 2311:        case wordbound:
        -: 2312:	  printf ("/wordbound");
        -: 2313:	  break;
        -: 2314:
        -: 2315:	case notwordbound:
        -: 2316:	  printf ("/notwordbound");
        -: 2317:          break;
        -: 2318:
        -: 2319:	case wordbeg:
        -: 2320:	  printf ("/wordbeg");
        -: 2321:	  break;
        -: 2322:          
        -: 2323:	case wordend:
        -: 2324:	  printf ("/wordend");
        -: 2325:          
        -: 2326:#ifdef emacs
        -: 2327:	case before_dot:
        -: 2328:	  printf ("/before_dot");
        -: 2329:          break;
        -: 2330:
        -: 2331:	case at_dot:
        -: 2332:	  printf ("/at_dot");
        -: 2333:          break;
        -: 2334:
        -: 2335:	case after_dot:
        -: 2336:	  printf ("/after_dot");
        -: 2337:          break;
        -: 2338:
        -: 2339:	case syntaxspec:
        -: 2340:          printf ("/syntaxspec");
        -: 2341:	  mcnt = *p++;
        -: 2342:	  printf ("/%d", mcnt);
        -: 2343:          break;
        -: 2344:	  
        -: 2345:	case notsyntaxspec:
        -: 2346:          printf ("/notsyntaxspec");
        -: 2347:	  mcnt = *p++;
        -: 2348:	  printf ("/%d", mcnt);
        -: 2349:	  break;
        -: 2350:#endif /* emacs */
        -: 2351:
        -: 2352:	case wordchar:
        -: 2353:	  printf ("/wordchar");
        -: 2354:          break;
        -: 2355:	  
        -: 2356:	case notwordchar:
        -: 2357:	  printf ("/notwordchar");
        -: 2358:          break;
        -: 2359:
        -: 2360:	case begbuf:
        -: 2361:	  printf ("/begbuf");
        -: 2362:          break;
        -: 2363:
        -: 2364:	case endbuf:
        -: 2365:	  printf ("/endbuf");
        -: 2366:          break;
        -: 2367:
        -: 2368:        default:
        -: 2369:          printf ("?%d", *(p-1));
        -: 2370:	}
        -: 2371:
        -: 2372:      putchar ('\n');
        -: 2373:    }
        -: 2374:
        -: 2375:  printf ("%d:\tend of pattern.\n", p - start);
        -: 2376:}
        -: 2377:
        -: 2378:
        -: 2379:void
        -: 2380:print_compiled_pattern (bufp)
        -: 2381:    struct re_pattern_buffer *bufp;
        -: 2382:{
        -: 2383:  unsigned char *buffer = bufp->buffer;
        -: 2384:
        -: 2385:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
        -: 2386:  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
        -: 2387:
        -: 2388:  if (bufp->fastmap_accurate && bufp->fastmap)
        -: 2389:    {
        -: 2390:      printf ("fastmap: ");
        -: 2391:      print_fastmap (bufp->fastmap);
        -: 2392:    }
        -: 2393:
        -: 2394:  printf ("re_nsub: %d\t", bufp->re_nsub);
        -: 2395:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
        -: 2396:  printf ("can_be_null: %d\t", bufp->can_be_null);
        -: 2397:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
        -: 2398:  printf ("no_sub: %d\t", bufp->no_sub);
        -: 2399:  printf ("not_bol: %d\t", bufp->not_bol);
        -: 2400:  printf ("not_eol: %d\t", bufp->not_eol);
        -: 2401:  printf ("syntax: %d\n", bufp->syntax);
        -: 2402:  /* Perhaps we should print the translate table?  */
        -: 2403:}
        -: 2404:
        -: 2405:
        -: 2406:void
        -: 2407:print_double_string (where, string1, size1, string2, size2)
        -: 2408:    const char *where;
        -: 2409:    const char *string1;
        -: 2410:    const char *string2;
        -: 2411:    int size1;
        -: 2412:    int size2;
        -: 2413:{
        -: 2414:  unsigned this_char;
        -: 2415:  
        -: 2416:  if (where == NULL)
        -: 2417:    printf ("(null)");
        -: 2418:  else
        -: 2419:    {
        -: 2420:      if (FIRST_STRING_P (where))
        -: 2421:        {
        -: 2422:          for (this_char = where - string1; this_char < size1; this_char++)
        -: 2423:            printchar (string1[this_char]);
        -: 2424:
        -: 2425:          where = string2;    
        -: 2426:        }
        -: 2427:
        -: 2428:      for (this_char = where - string2; this_char < size2; this_char++)
        -: 2429:        printchar (string2[this_char]);
        -: 2430:    }
        -: 2431:}
        -: 2432:
        -: 2433:#else /* not DEBUG */
        -: 2434:
        -: 2435:#undef assert
        -: 2436:#define assert(e)
        -: 2437:
        -: 2438:#define DEBUG_STATEMENT(e)
        -: 2439:#define DEBUG_PRINT1(x)
        -: 2440:#define DEBUG_PRINT2(x1, x2)
        -: 2441:#define DEBUG_PRINT3(x1, x2, x3)
        -: 2442:#define DEBUG_PRINT4(x1, x2, x3, x4)
        -: 2443:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
        -: 2444:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
        -: 2445:
        -: 2446:#endif /* not DEBUG */
        -: 2447:
        -: 2448:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
        -: 2449:   also be assigned to arbitrarily: each pattern buffer stores its own
        -: 2450:   syntax, so it can be changed between regex compilations.  */
        -: 2451:reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
        -: 2452:
        -: 2453:
        -: 2454:/* Specify the precise syntax of regexps for compilation.  This provides
        -: 2455:   for compatibility for various utilities which historically have
        -: 2456:   different, incompatible syntaxes.
        -: 2457:
        -: 2458:   The argument SYNTAX is a bit mask comprised of the various bits
        -: 2459:   defined in regex.h.  We return the old syntax.  */
        -: 2460:
        -: 2461:reg_syntax_t
    #####: 2462:re_set_syntax (syntax)
        -: 2463:    reg_syntax_t syntax;
        -: 2464:{
    #####: 2465:  reg_syntax_t ret = re_syntax_options;
        -: 2466:  
    #####: 2467:  re_syntax_options = syntax;
    #####: 2468:  return ret;
        -: 2469:}
        -: 2470:
        -: 2471:/* This table gives an error message for each of the error codes listed
        -: 2472:   in regex.h.  Obviously the order here has to be same as there.  */
        -: 2473:
        -: 2474:static const char *re_error_msg[] =
        -: 2475:  { NULL,					/* REG_NOERROR */
        -: 2476:    "No match",					/* REG_NOMATCH */
        -: 2477:    "Invalid regular expression",		/* REG_BADPAT */
        -: 2478:    "Invalid collation character",		/* REG_ECOLLATE */
        -: 2479:    "Invalid character class name",		/* REG_ECTYPE */
        -: 2480:    "Trailing backslash",			/* REG_EESCAPE */
        -: 2481:    "Invalid back reference",			/* REG_ESUBREG */
        -: 2482:    "Unmatched [ or [^",			/* REG_EBRACK */
        -: 2483:    "Unmatched ( or \\(",			/* REG_EPAREN */
        -: 2484:    "Unmatched \\{",				/* REG_EBRACE */
        -: 2485:    "Invalid content of \\{\\}",		/* REG_BADBR */
        -: 2486:    "Invalid range end",			/* REG_ERANGE */
        -: 2487:    "Memory exhausted",				/* REG_ESPACE */
        -: 2488:    "Invalid preceding regular expression",	/* REG_BADRPT */
        -: 2489:    "Premature end of regular expression",	/* REG_EEND */
        -: 2490:    "Regular expression too big",		/* REG_ESIZE */
        -: 2491:    "Unmatched ) or \\)",			/* REG_ERPAREN */
        -: 2492:  };
        -: 2493:
        -: 2494:/* Subroutine declarations and macros for regex_compile.  */
        -: 2495:
        -: 2496:static void store_op1 (), store_op2 ();
        -: 2497:static void insert_op1 (), insert_op2 ();
        -: 2498:static boolean at_begline_loc_p (), at_endline_loc_p ();
        -: 2499:static boolean group_in_compile_stack ();
        -: 2500:static reg_errcode_t compile_range ();
        -: 2501:
        -: 2502:/* Fetch the next character in the uncompiled pattern---translating it 
        -: 2503:   if necessary.  Also cast from a signed character in the constant
        -: 2504:   string passed to us by the user to an unsigned char that we can use
        -: 2505:   as an array index (in, e.g., `translate').  */
        -: 2506:#define PATFETCH(c)							\
        -: 2507:  do {if (p == pend) return REG_EEND;					\
        -: 2508:    c = (unsigned char) *p++;						\
        -: 2509:    if (translate) c = translate[c]; 					\
        -: 2510:  } while (0)
        -: 2511:
        -: 2512:/* Fetch the next character in the uncompiled pattern, with no
        -: 2513:   translation.  */
        -: 2514:#define PATFETCH_RAW(c)							\
        -: 2515:  do {if (p == pend) return REG_EEND;					\
        -: 2516:    c = (unsigned char) *p++; 						\
        -: 2517:  } while (0)
        -: 2518:
        -: 2519:/* Go backwards one character in the pattern.  */
        -: 2520:#define PATUNFETCH p--
        -: 2521:
        -: 2522:
        -: 2523:/* If `translate' is non-null, return translate[D], else just D.  We
        -: 2524:   cast the subscript to translate because some data is declared as
        -: 2525:   `char *', to avoid warnings when a string constant is passed.  But
        -: 2526:   when we use a character as a subscript we must make it unsigned.  */
        -: 2527:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
        -: 2528:
        -: 2529:
        -: 2530:/* Macros for outputting the compiled pattern into `buffer'.  */
        -: 2531:
        -: 2532:/* If the buffer isn't allocated when it comes in, use this.  */
        -: 2533:#define INIT_BUF_SIZE  32
        -: 2534:
        -: 2535:/* Make sure we have at least N more bytes of space in buffer.  */
        -: 2536:#define GET_BUFFER_SPACE(n)						\
        -: 2537:    while (b - bufp->buffer + (n) > bufp->allocated)			\
        -: 2538:      EXTEND_BUFFER ()
        -: 2539:
        -: 2540:/* Make sure we have one more byte of buffer space and then add C to it.  */
        -: 2541:#define BUF_PUSH(c)							\
        -: 2542:  do {									\
        -: 2543:    GET_BUFFER_SPACE (1);						\
        -: 2544:    *b++ = (unsigned char) (c);						\
        -: 2545:  } while (0)
        -: 2546:
        -: 2547:
        -: 2548:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
        -: 2549:#define BUF_PUSH_2(c1, c2)						\
        -: 2550:  do {									\
        -: 2551:    GET_BUFFER_SPACE (2);						\
        -: 2552:    *b++ = (unsigned char) (c1);					\
        -: 2553:    *b++ = (unsigned char) (c2);					\
        -: 2554:  } while (0)
        -: 2555:
        -: 2556:
        -: 2557:/* As with BUF_PUSH_2, except for three bytes.  */
        -: 2558:#define BUF_PUSH_3(c1, c2, c3)						\
        -: 2559:  do {									\
        -: 2560:    GET_BUFFER_SPACE (3);						\
        -: 2561:    *b++ = (unsigned char) (c1);					\
        -: 2562:    *b++ = (unsigned char) (c2);					\
        -: 2563:    *b++ = (unsigned char) (c3);					\
        -: 2564:  } while (0)
        -: 2565:
        -: 2566:
        -: 2567:/* Store a jump with opcode OP at LOC to location TO.  We store a
        -: 2568:   relative address offset by the three bytes the jump itself occupies.  */
        -: 2569:#define STORE_JUMP(op, loc, to) \
        -: 2570:  store_op1 (op, loc, (to) - (loc) - 3)
        -: 2571:
        -: 2572:/* Likewise, for a two-argument jump.  */
        -: 2573:#define STORE_JUMP2(op, loc, to, arg) \
        -: 2574:  store_op2 (op, loc, (to) - (loc) - 3, arg)
        -: 2575:
        -: 2576:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
        -: 2577:#define INSERT_JUMP(op, loc, to) \
        -: 2578:  insert_op1 (op, loc, (to) - (loc) - 3, b)
        -: 2579:
        -: 2580:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
        -: 2581:#define INSERT_JUMP2(op, loc, to, arg) \
        -: 2582:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
        -: 2583:
        -: 2584:
        -: 2585:/* This is not an arbitrary limit: the arguments which represent offsets
        -: 2586:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
        -: 2587:   be too small, many things would have to change.  */
        -: 2588:#define MAX_BUF_SIZE (1L << 16)
        -: 2589:
        -: 2590:
        -: 2591:/* Extend the buffer by twice its current size via realloc and
        -: 2592:   reset the pointers that pointed into the old block to point to the
        -: 2593:   correct places in the new one.  If extending the buffer results in it
        -: 2594:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
        -: 2595:#define EXTEND_BUFFER()							\
        -: 2596:  do { 									\
        -: 2597:    unsigned char *old_buffer = bufp->buffer;				\
        -: 2598:    if (bufp->allocated == MAX_BUF_SIZE) 				\
        -: 2599:      return REG_ESIZE;							\
        -: 2600:    bufp->allocated <<= 1;						\
        -: 2601:    if (bufp->allocated > MAX_BUF_SIZE)					\
        -: 2602:      bufp->allocated = MAX_BUF_SIZE; 					\
        -: 2603:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
        -: 2604:    if (bufp->buffer == NULL)						\
        -: 2605:      return REG_ESPACE;						\
        -: 2606:    /* If the buffer moved, move all the pointers into it.  */		\
        -: 2607:    if (old_buffer != bufp->buffer)					\
        -: 2608:      {									\
        -: 2609:        b = (b - old_buffer) + bufp->buffer;				\
        -: 2610:        begalt = (begalt - old_buffer) + bufp->buffer;			\
        -: 2611:        if (fixup_alt_jump)						\
        -: 2612:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
        -: 2613:        if (laststart)							\
        -: 2614:          laststart = (laststart - old_buffer) + bufp->buffer;		\
        -: 2615:        if (pending_exact)						\
        -: 2616:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
        -: 2617:      }									\
        -: 2618:  } while (0)
        -: 2619:
        -: 2620:
        -: 2621:/* Since we have one byte reserved for the register number argument to
        -: 2622:   {start,stop}_memory, the maximum number of groups we can report
        -: 2623:   things about is what fits in that byte.  */
        -: 2624:#define MAX_REGNUM 255
        -: 2625:
        -: 2626:/* But patterns can have more than `MAX_REGNUM' registers.  We just
        -: 2627:   ignore the excess.  */
        -: 2628:typedef unsigned regnum_t;
        -: 2629:
        -: 2630:
        -: 2631:/* Macros for the compile stack.  */
        -: 2632:
        -: 2633:/* Since offsets can go either forwards or backwards, this type needs to
        -: 2634:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
        -: 2635:typedef int pattern_offset_t;
        -: 2636:
        -: 2637:typedef struct
        -: 2638:{
        -: 2639:  pattern_offset_t begalt_offset;
        -: 2640:  pattern_offset_t fixup_alt_jump;
        -: 2641:  pattern_offset_t inner_group_offset;
        -: 2642:  pattern_offset_t laststart_offset;  
        -: 2643:  regnum_t regnum;
        -: 2644:} compile_stack_elt_t;
        -: 2645:
        -: 2646:
        -: 2647:typedef struct
        -: 2648:{
        -: 2649:  compile_stack_elt_t *stack;
        -: 2650:  unsigned size;
        -: 2651:  unsigned avail;			/* Offset of next open position.  */
        -: 2652:} compile_stack_type;
        -: 2653:
        -: 2654:
        -: 2655:#define INIT_COMPILE_STACK_SIZE 32
        -: 2656:
        -: 2657:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
        -: 2658:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
        -: 2659:
        -: 2660:/* The next available element.  */
        -: 2661:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
        -: 2662:
        -: 2663:
        -: 2664:/* Set the bit for character C in a list.  */
        -: 2665:#define SET_LIST_BIT(c)                               \
        -: 2666:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
        -: 2667:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
        -: 2668:
        -: 2669:
        -: 2670:/* Get the next unsigned number in the uncompiled pattern.  */
        -: 2671:#define GET_UNSIGNED_NUMBER(num) 					\
        -: 2672:  { if (p != pend)							\
        -: 2673:     {									\
        -: 2674:       PATFETCH (c); 							\
        -: 2675:       while (ISDIGIT (c)) 						\
        -: 2676:         { 								\
        -: 2677:           if (num < 0)							\
        -: 2678:              num = 0;							\
        -: 2679:           num = num * 10 + c - '0'; 					\
        -: 2680:           if (p == pend) 						\
        -: 2681:              break; 							\
        -: 2682:           PATFETCH (c);						\
        -: 2683:         } 								\
        -: 2684:       } 								\
        -: 2685:    }		
        -: 2686:
        -: 2687:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
        -: 2688:
        -: 2689:#define IS_CHAR_CLASS(string)						\
        -: 2690:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
        -: 2691:    || STREQ (string, "lower") || STREQ (string, "digit")		\
        -: 2692:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
        -: 2693:    || STREQ (string, "space") || STREQ (string, "print")		\
        -: 2694:    || STREQ (string, "punct") || STREQ (string, "graph")		\
        -: 2695:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
        -: 2696:
        -: 2697:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
        -: 2698:   Returns one of error codes defined in `regex.h', or zero for success.
        -: 2699:
        -: 2700:   Assumes the `allocated' (and perhaps `buffer') and `translate'
        -: 2701:   fields are set in BUFP on entry.
        -: 2702:
        -: 2703:   If it succeeds, results are put in BUFP (if it returns an error, the
        -: 2704:   contents of BUFP are undefined):
        -: 2705:     `buffer' is the compiled pattern;
        -: 2706:     `syntax' is set to SYNTAX;
        -: 2707:     `used' is set to the length of the compiled pattern;
        -: 2708:     `fastmap_accurate' is zero;
        -: 2709:     `re_nsub' is the number of subexpressions in PATTERN;
        -: 2710:     `not_bol' and `not_eol' are zero;
        -: 2711:   
        -: 2712:   The `fastmap' and `newline_anchor' fields are neither
        -: 2713:   examined nor set.  */
        -: 2714:
        -: 2715:static reg_errcode_t
    #####: 2716:regex_compile (pattern, size, syntax, bufp)
        -: 2717:     const char *pattern;
        -: 2718:     int size;
        -: 2719:     reg_syntax_t syntax;
        -: 2720:     struct re_pattern_buffer *bufp;
        -: 2721:{
        -: 2722:  /* We fetch characters from PATTERN here.  Even though PATTERN is
        -: 2723:     `char *' (i.e., signed), we declare these variables as unsigned, so
        -: 2724:     they can be reliably used as array indices.  */
        -: 2725:  register unsigned char c, c1;
        -: 2726:  
        -: 2727:  /* A random tempory spot in PATTERN.  */
        -: 2728:  const char *p1;
        -: 2729:
        -: 2730:  /* Points to the end of the buffer, where we should append.  */
        -: 2731:  register unsigned char *b;
        -: 2732:  
        -: 2733:  /* Keeps track of unclosed groups.  */
        -: 2734:  compile_stack_type compile_stack;
        -: 2735:
        -: 2736:  /* Points to the current (ending) position in the pattern.  */
    #####: 2737:  const char *p = pattern;
    #####: 2738:  const char *pend = pattern + size;
        -: 2739:  
        -: 2740:  /* How to translate the characters in the pattern.  */
    #####: 2741:  char *translate = bufp->translate;
        -: 2742:
        -: 2743:  /* Address of the count-byte of the most recently inserted `exactn'
        -: 2744:     command.  This makes it possible to tell if a new exact-match
        -: 2745:     character can be added to that command or if the character requires
        -: 2746:     a new `exactn' command.  */
    #####: 2747:  unsigned char *pending_exact = 0;
        -: 2748:
        -: 2749:  /* Address of start of the most recently finished expression.
        -: 2750:     This tells, e.g., postfix * where to find the start of its
        -: 2751:     operand.  Reset at the beginning of groups and alternatives.  */
    #####: 2752:  unsigned char *laststart = 0;
        -: 2753:
        -: 2754:  /* Address of beginning of regexp, or inside of last group.  */
        -: 2755:  unsigned char *begalt;
        -: 2756:
        -: 2757:  /* Place in the uncompiled pattern (i.e., the {) to
        -: 2758:     which to go back if the interval is invalid.  */
        -: 2759:  const char *beg_interval;
        -: 2760:                
        -: 2761:  /* Address of the place where a forward jump should go to the end of
        -: 2762:     the containing expression.  Each alternative of an `or' -- except the
        -: 2763:     last -- ends with a forward jump of this sort.  */
    #####: 2764:  unsigned char *fixup_alt_jump = 0;
        -: 2765:
        -: 2766:  /* Counts open-groups as they are encountered.  Remembered for the
        -: 2767:     matching close-group on the compile stack, so the same register
        -: 2768:     number is put in the stop_memory as the start_memory.  */
    #####: 2769:  regnum_t regnum = 0;
        -: 2770:
        -: 2771:#ifdef DEBUG
        -: 2772:  DEBUG_PRINT1 ("\nCompiling pattern: ");
        -: 2773:  if (debug)
        -: 2774:    {
        -: 2775:      unsigned debug_count;
        -: 2776:      
        -: 2777:      for (debug_count = 0; debug_count < size; debug_count++)
        -: 2778:        printchar (pattern[debug_count]);
        -: 2779:      putchar ('\n');
        -: 2780:    }
        -: 2781:#endif /* DEBUG */
        -: 2782:
        -: 2783:  /* Initialize the compile stack.  */
    #####: 2784:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
    #####: 2785:  if (compile_stack.stack == NULL)
    #####: 2786:    return REG_ESPACE;
        -: 2787:
    #####: 2788:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
    #####: 2789:  compile_stack.avail = 0;
        -: 2790:
        -: 2791:  /* Initialize the pattern buffer.  */
    #####: 2792:  bufp->syntax = syntax;
    #####: 2793:  bufp->fastmap_accurate = 0;
    #####: 2794:  bufp->not_bol = bufp->not_eol = 0;
        -: 2795:
        -: 2796:  /* Set `used' to zero, so that if we return an error, the pattern
        -: 2797:     printer (for debugging) will think there's no pattern.  We reset it
        -: 2798:     at the end.  */
    #####: 2799:  bufp->used = 0;
        -: 2800:  
        -: 2801:  /* Always count groups, whether or not bufp->no_sub is set.  */
    #####: 2802:  bufp->re_nsub = 0;				
        -: 2803:
        -: 2804:#if !defined (emacs) && !defined (SYNTAX_TABLE)
        -: 2805:  /* Initialize the syntax table.  */
    #####: 2806:   init_syntax_once ();
        -: 2807:#endif
        -: 2808:
    #####: 2809:  if (bufp->allocated == 0)
        -: 2810:    {
    #####: 2811:      if (bufp->buffer)
        -: 2812:	{ /* If zero allocated, but buffer is non-null, try to realloc
        -: 2813:             enough space.  This loses if buffer's address is bogus, but
        -: 2814:             that is the user's responsibility.  */
    #####: 2815:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        -: 2816:        }
        -: 2817:      else
        -: 2818:        { /* Caller did not allocate a buffer.  Do it for them.  */
    #####: 2819:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
        -: 2820:        }
    #####: 2821:      if (!bufp->buffer) return REG_ESPACE;
        -: 2822:
    #####: 2823:      bufp->allocated = INIT_BUF_SIZE;
        -: 2824:    }
        -: 2825:
    #####: 2826:  begalt = b = bufp->buffer;
        -: 2827:
        -: 2828:  /* Loop through the uncompiled pattern until we're at the end.  */
    #####: 2829:  while (p != pend)
        -: 2830:    {
    #####: 2831:      PATFETCH (c);
        -: 2832:
    #####: 2833:      switch (c)
        -: 2834:        {
        -: 2835:        case '^':
        -: 2836:          {
    #####: 2837:            if (   /* If at start of pattern, it's an operator.  */
    #####: 2838:                   p == pattern + 1
        -: 2839:                   /* If context independent, it's an operator.  */
    #####: 2840:                || syntax & RE_CONTEXT_INDEP_ANCHORS
        -: 2841:                   /* Otherwise, depends on what's come before.  */
    #####: 2842:                || at_begline_loc_p (pattern, p, syntax))
    #####: 2843:              BUF_PUSH (begline);
        -: 2844:            else
        -: 2845:              goto normal_char;
        -: 2846:          }
    #####: 2847:          break;
        -: 2848:
        -: 2849:
        -: 2850:        case '$':
        -: 2851:          {
    #####: 2852:            if (   /* If at end of pattern, it's an operator.  */
    #####: 2853:                   p == pend 
        -: 2854:                   /* If context independent, it's an operator.  */
    #####: 2855:                || syntax & RE_CONTEXT_INDEP_ANCHORS
        -: 2856:                   /* Otherwise, depends on what's next.  */
    #####: 2857:                || at_endline_loc_p (p, pend, syntax))
    #####: 2858:               BUF_PUSH (endline);
        -: 2859:             else
        -: 2860:               goto normal_char;
        -: 2861:           }
    #####: 2862:           break;
        -: 2863:
        -: 2864:
        -: 2865:	case '+':
        -: 2866:        case '?':
    #####: 2867:          if ((syntax & RE_BK_PLUS_QM)
    #####: 2868:              || (syntax & RE_LIMITED_OPS))
        -: 2869:            goto normal_char;
        -: 2870:        handle_plus:
        -: 2871:        case '*':
        -: 2872:          /* If there is no previous pattern... */
    #####: 2873:          if (!laststart)
        -: 2874:            {
    #####: 2875:              if (syntax & RE_CONTEXT_INVALID_OPS)
    #####: 2876:                return REG_BADRPT;
    #####: 2877:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
    #####: 2878:                goto normal_char;
        -: 2879:            }
        -: 2880:
        -: 2881:          {
        -: 2882:            /* Are we optimizing this jump?  */
    #####: 2883:            boolean keep_string_p = false;
        -: 2884:            
        -: 2885:            /* 1 means zero (many) matches is allowed.  */
    #####: 2886:            char zero_times_ok = 0, many_times_ok = 0;
        -: 2887:
        -: 2888:            /* If there is a sequence of repetition chars, collapse it
        -: 2889:               down to just one (the right one).  We can't combine
        -: 2890:               interval operators with these because of, e.g., `a{2}*',
        -: 2891:               which should only match an even number of `a's.  */
        -: 2892:
        -: 2893:            for (;;)
        -: 2894:              {
    #####: 2895:                zero_times_ok |= c != '+';
    #####: 2896:                many_times_ok |= c != '?';
        -: 2897:
    #####: 2898:                if (p == pend)
    #####: 2899:                  break;
        -: 2900:
    #####: 2901:                PATFETCH (c);
        -: 2902:
    #####: 2903:                if (c == '*'
    #####: 2904:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
        -: 2905:                  ;
        -: 2906:
    #####: 2907:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
        -: 2908:                  {
    #####: 2909:                    if (p == pend) return REG_EESCAPE;
        -: 2910:
    #####: 2911:                    PATFETCH (c1);
    #####: 2912:                    if (!(c1 == '+' || c1 == '?'))
        -: 2913:                      {
    #####: 2914:                        PATUNFETCH;
    #####: 2915:                        PATUNFETCH;
    #####: 2916:                        break;
        -: 2917:                      }
        -: 2918:
    #####: 2919:                    c = c1;
        -: 2920:                  }
        -: 2921:                else
        -: 2922:                  {
    #####: 2923:                    PATUNFETCH;
    #####: 2924:                    break;
        -: 2925:                  }
        -: 2926:
        -: 2927:                /* If we get here, we found another repeat character.  */
    #####: 2928:               }
        -: 2929:
        -: 2930:            /* Star, etc. applied to an empty pattern is equivalent
        -: 2931:               to an empty pattern.  */
    #####: 2932:            if (!laststart)  
    #####: 2933:              break;
        -: 2934:
        -: 2935:            /* Now we know whether or not zero matches is allowed
        -: 2936:               and also whether or not two or more matches is allowed.  */
    #####: 2937:            if (many_times_ok)
        -: 2938:              { /* More than one repetition is allowed, so put in at the
        -: 2939:                   end a backward relative jump from `b' to before the next
        -: 2940:                   jump we're going to put in below (which jumps from
        -: 2941:                   laststart to after this jump).  
        -: 2942:
        -: 2943:                   But if we are at the `*' in the exact sequence `.*\n',
        -: 2944:                   insert an unconditional jump backwards to the .,
        -: 2945:                   instead of the beginning of the loop.  This way we only
        -: 2946:                   push a failure point once, instead of every time
        -: 2947:                   through the loop.  */
        -: 2948:                assert (p - 1 > pattern);
        -: 2949:
        -: 2950:                /* Allocate the space for the jump.  */
    #####: 2951:                GET_BUFFER_SPACE (3);
        -: 2952:
        -: 2953:                /* We know we are not at the first character of the pattern,
        -: 2954:                   because laststart was nonzero.  And we've already
        -: 2955:                   incremented `p', by the way, to be the character after
        -: 2956:                   the `*'.  Do we have to do something analogous here
        -: 2957:                   for null bytes, because of RE_DOT_NOT_NULL?  */
    #####: 2958:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
    #####: 2959:		    && zero_times_ok
    #####: 2960:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
    #####: 2961:                    && !(syntax & RE_DOT_NEWLINE))
        -: 2962:                  { /* We have .*\n.  */
    #####: 2963:                    STORE_JUMP (jump, b, laststart);
    #####: 2964:                    keep_string_p = true;
        -: 2965:                  }
        -: 2966:                else
        -: 2967:                  /* Anything else.  */
    #####: 2968:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
        -: 2969:
        -: 2970:                /* We've added more stuff to the buffer.  */
    #####: 2971:                b += 3;
        -: 2972:              }
        -: 2973:
        -: 2974:            /* On failure, jump from laststart to b + 3, which will be the
        -: 2975:               end of the buffer after this jump is inserted.  */
    #####: 2976:            GET_BUFFER_SPACE (3);
    #####: 2977:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
        -: 2978:                                       : on_failure_jump,
        -: 2979:                         laststart, b + 3);
    #####: 2980:            pending_exact = 0;
    #####: 2981:            b += 3;
        -: 2982:
    #####: 2983:            if (!zero_times_ok)
        -: 2984:              {
        -: 2985:                /* At least one repetition is required, so insert a
        -: 2986:                   `dummy_failure_jump' before the initial
        -: 2987:                   `on_failure_jump' instruction of the loop. This
        -: 2988:                   effects a skip over that instruction the first time
        -: 2989:                   we hit that loop.  */
    #####: 2990:                GET_BUFFER_SPACE (3);
    #####: 2991:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
    #####: 2992:                b += 3;
        -: 2993:              }
        -: 2994:            }
    #####: 2995:	  break;
        -: 2996:
        -: 2997:
        -: 2998:	case '.':
    #####: 2999:          laststart = b;
    #####: 3000:          BUF_PUSH (anychar);
    #####: 3001:          break;
        -: 3002:
        -: 3003:
        -: 3004:        case '[':
        -: 3005:          {
    #####: 3006:            boolean had_char_class = false;
        -: 3007:
    #####: 3008:            if (p == pend) return REG_EBRACK;
        -: 3009:
        -: 3010:            /* Ensure that we have enough space to push a charset: the
        -: 3011:               opcode, the length count, and the bitset; 34 bytes in all.  */
    #####: 3012:	    GET_BUFFER_SPACE (34);
        -: 3013:
    #####: 3014:            laststart = b;
        -: 3015:
        -: 3016:            /* We test `*p == '^' twice, instead of using an if
        -: 3017:               statement, so we only need one BUF_PUSH.  */
    #####: 3018:            BUF_PUSH (*p == '^' ? charset_not : charset); 
    #####: 3019:            if (*p == '^')
    #####: 3020:              p++;
        -: 3021:
        -: 3022:            /* Remember the first position in the bracket expression.  */
    #####: 3023:            p1 = p;
        -: 3024:
        -: 3025:            /* Push the number of bytes in the bitmap.  */
    #####: 3026:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
        -: 3027:
        -: 3028:            /* Clear the whole map.  */
    #####: 3029:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
        -: 3030:
        -: 3031:            /* charset_not matches newline according to a syntax bit.  */
    #####: 3032:            if ((re_opcode_t) b[-2] == charset_not
    #####: 3033:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
    #####: 3034:              SET_LIST_BIT ('\n');
        -: 3035:
        -: 3036:            /* Read in characters and ranges, setting map bits.  */
        -: 3037:            for (;;)
        -: 3038:              {
    #####: 3039:                if (p == pend) return REG_EBRACK;
        -: 3040:
    #####: 3041:                PATFETCH (c);
        -: 3042:
        -: 3043:                /* \ might escape characters inside [...] and [^...].  */
    #####: 3044:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
        -: 3045:                  {
    #####: 3046:                    if (p == pend) return REG_EESCAPE;
        -: 3047:
    #####: 3048:                    PATFETCH (c1);
    #####: 3049:                    SET_LIST_BIT (c1);
    #####: 3050:                    continue;
        -: 3051:                  }
        -: 3052:
        -: 3053:                /* Could be the end of the bracket expression.  If it's
        -: 3054:                   not (i.e., when the bracket expression is `[]' so
        -: 3055:                   far), the ']' character bit gets set way below.  */
    #####: 3056:                if (c == ']' && p != p1 + 1)
    #####: 3057:                  break;
        -: 3058:
        -: 3059:                /* Look ahead to see if it's a range when the last thing
        -: 3060:                   was a character class.  */
    #####: 3061:                if (had_char_class && c == '-' && *p != ']')
    #####: 3062:                  return REG_ERANGE;
        -: 3063:
        -: 3064:                /* Look ahead to see if it's a range when the last thing
        -: 3065:                   was a character: if this is a hyphen not at the
        -: 3066:                   beginning or the end of a list, then it's the range
        -: 3067:                   operator.  */
    #####: 3068:                if (c == '-' 
    #####: 3069:                    && !(p - 2 >= pattern && p[-2] == '[') 
    #####: 3070:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
    #####: 3071:                    && *p != ']')
    #####: 3072:                  {
    #####: 3073:                    reg_errcode_t ret
        -: 3074:                      = compile_range (&p, pend, translate, syntax, b);
    #####: 3075:                    if (ret != REG_NOERROR) return ret;
        -: 3076:                  }
        -: 3077:
    #####: 3078:                else if (p[0] == '-' && p[1] != ']')
    #####: 3079:                  { /* This handles ranges made up of characters only.  */
        -: 3080:                    reg_errcode_t ret;
        -: 3081:
        -: 3082:		    /* Move past the `-'.  */
    #####: 3083:                    PATFETCH (c1);
        -: 3084:                    
    #####: 3085:                    ret = compile_range (&p, pend, translate, syntax, b);
    #####: 3086:                    if (ret != REG_NOERROR) return ret;
        -: 3087:                  }
        -: 3088:
        -: 3089:                /* See if we're at the beginning of a possible character
        -: 3090:                   class.  */
        -: 3091:
    #####: 3092:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
    #####: 3093:                  { /* Leave room for the null.  */
        -: 3094:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
        -: 3095:
    #####: 3096:                    PATFETCH (c);
    #####: 3097:                    c1 = 0;
        -: 3098:
        -: 3099:                    /* If pattern is `[[:'.  */
    #####: 3100:                    if (p == pend) return REG_EBRACK;
        -: 3101:
        -: 3102:                    for (;;)
        -: 3103:                      {
    #####: 3104:                        PATFETCH (c);
    #####: 3105:                        if (c == ':' || c == ']' || p == pend
    #####: 3106:                            || c1 == CHAR_CLASS_MAX_LENGTH)
        -: 3107:                          break;
    #####: 3108:                        str[c1++] = c;
    #####: 3109:                      }
    #####: 3110:                    str[c1] = '\0';
        -: 3111:
        -: 3112:                    /* If isn't a word bracketed by `[:' and:`]':
        -: 3113:                       undo the ending character, the letters, and leave 
        -: 3114:                       the leading `:' and `[' (but set bits for them).  */
    #####: 3115:                    if (c == ':' && *p == ']')
    #####: 3116:                      {
        -: 3117:                        int ch;
    #####: 3118:                        boolean is_alnum = STREQ (str, "alnum");
    #####: 3119:                        boolean is_alpha = STREQ (str, "alpha");
    #####: 3120:                        boolean is_blank = STREQ (str, "blank");
    #####: 3121:                        boolean is_cntrl = STREQ (str, "cntrl");
    #####: 3122:                        boolean is_digit = STREQ (str, "digit");
    #####: 3123:                        boolean is_graph = STREQ (str, "graph");
    #####: 3124:                        boolean is_lower = STREQ (str, "lower");
    #####: 3125:                        boolean is_print = STREQ (str, "print");
    #####: 3126:                        boolean is_punct = STREQ (str, "punct");
    #####: 3127:                        boolean is_space = STREQ (str, "space");
    #####: 3128:                        boolean is_upper = STREQ (str, "upper");
    #####: 3129:                        boolean is_xdigit = STREQ (str, "xdigit");
        -: 3130:                        
    #####: 3131:                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
        -: 3132:
        -: 3133:                        /* Throw away the ] at the end of the character
        -: 3134:                           class.  */
    #####: 3135:                        PATFETCH (c);					
        -: 3136:
    #####: 3137:                        if (p == pend) return REG_EBRACK;
        -: 3138:
    #####: 3139:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
        -: 3140:                          {
    #####: 3141:                            if (   (is_alnum  && ISALNUM (ch))
    #####: 3142:                                || (is_alpha  && ISALPHA (ch))
    #####: 3143:                                || (is_blank  && ISBLANK (ch))
    #####: 3144:                                || (is_cntrl  && ISCNTRL (ch))
    #####: 3145:                                || (is_digit  && ISDIGIT (ch))
    #####: 3146:                                || (is_graph  && ISGRAPH (ch))
    #####: 3147:                                || (is_lower  && ISLOWER (ch))
    #####: 3148:                                || (is_print  && ISPRINT (ch))
    #####: 3149:                                || (is_punct  && ISPUNCT (ch))
    #####: 3150:                                || (is_space  && ISSPACE (ch))
    #####: 3151:                                || (is_upper  && ISUPPER (ch))
    #####: 3152:                                || (is_xdigit && ISXDIGIT (ch)))
    #####: 3153:                            SET_LIST_BIT (ch);
        -: 3154:                          }
    #####: 3155:                        had_char_class = true;
        -: 3156:                      }
        -: 3157:                    else
        -: 3158:                      {
    #####: 3159:                        c1++;
    #####: 3160:                        while (c1--)    
    #####: 3161:                          PATUNFETCH;
    #####: 3162:                        SET_LIST_BIT ('[');
    #####: 3163:                        SET_LIST_BIT (':');
    #####: 3164:                        had_char_class = false;
        -: 3165:                      }
        -: 3166:                  }
        -: 3167:                else
        -: 3168:                  {
    #####: 3169:                    had_char_class = false;
    #####: 3170:                    SET_LIST_BIT (c);
        -: 3171:                  }
    #####: 3172:              }
        -: 3173:
        -: 3174:            /* Discard any (non)matching list bytes that are all 0 at the
        -: 3175:               end of the map.  Decrease the map-length byte too.  */
    #####: 3176:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
    #####: 3177:              b[-1]--; 
    #####: 3178:            b += b[-1];
        -: 3179:          }
    #####: 3180:          break;
        -: 3181:
        -: 3182:
        -: 3183:	case '(':
    #####: 3184:          if (syntax & RE_NO_BK_PARENS)
    #####: 3185:            goto handle_open;
        -: 3186:          else
    #####: 3187:            goto normal_char;
        -: 3188:
        -: 3189:
        -: 3190:        case ')':
    #####: 3191:          if (syntax & RE_NO_BK_PARENS)
    #####: 3192:            goto handle_close;
        -: 3193:          else
    #####: 3194:            goto normal_char;
        -: 3195:
        -: 3196:
        -: 3197:        case '\n':
    #####: 3198:          if (syntax & RE_NEWLINE_ALT)
    #####: 3199:            goto handle_alt;
        -: 3200:          else
    #####: 3201:            goto normal_char;
        -: 3202:
        -: 3203:
        -: 3204:	case '|':
    #####: 3205:          if (syntax & RE_NO_BK_VBAR)
    #####: 3206:            goto handle_alt;
        -: 3207:          else
    #####: 3208:            goto normal_char;
        -: 3209:
        -: 3210:
        -: 3211:        case '{':
    #####: 3212:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
        -: 3213:             goto handle_interval;
        -: 3214:           else
        -: 3215:             goto normal_char;
        -: 3216:
        -: 3217:
        -: 3218:        case '\\':
    #####: 3219:          if (p == pend) return REG_EESCAPE;
        -: 3220:
        -: 3221:          /* Do not translate the character after the \, so that we can
        -: 3222:             distinguish, e.g., \B from \b, even if we normally would
        -: 3223:             translate, e.g., B to b.  */
    #####: 3224:          PATFETCH_RAW (c);
        -: 3225:
    #####: 3226:          switch (c)
        -: 3227:            {
        -: 3228:            case '(':
    #####: 3229:              if (syntax & RE_NO_BK_PARENS)
    #####: 3230:                goto normal_backslash;
        -: 3231:
        -: 3232:            handle_open:
    #####: 3233:              bufp->re_nsub++;
    #####: 3234:              regnum++;
        -: 3235:
    #####: 3236:              if (COMPILE_STACK_FULL)
        -: 3237:                { 
    #####: 3238:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
        -: 3239:                            compile_stack_elt_t);
    #####: 3240:                  if (compile_stack.stack == NULL) return REG_ESPACE;
        -: 3241:
    #####: 3242:                  compile_stack.size <<= 1;
        -: 3243:                }
        -: 3244:
        -: 3245:              /* These are the values to restore when we hit end of this
        -: 3246:                 group.  They are all relative offsets, so that if the
        -: 3247:                 whole pattern moves because of realloc, they will still
        -: 3248:                 be valid.  */
    #####: 3249:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
    #####: 3250:              COMPILE_STACK_TOP.fixup_alt_jump 
    #####: 3251:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
    #####: 3252:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
    #####: 3253:              COMPILE_STACK_TOP.regnum = regnum;
        -: 3254:
        -: 3255:              /* We will eventually replace the 0 with the number of
        -: 3256:                 groups inner to this one.  But do not push a
        -: 3257:                 start_memory for groups beyond the last one we can
        -: 3258:                 represent in the compiled pattern.  */
    #####: 3259:              if (regnum <= MAX_REGNUM)
        -: 3260:                {
    #####: 3261:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
    #####: 3262:                  BUF_PUSH_3 (start_memory, regnum, 0);
        -: 3263:                }
        -: 3264:                
    #####: 3265:              compile_stack.avail++;
        -: 3266:
    #####: 3267:              fixup_alt_jump = 0;
    #####: 3268:              laststart = 0;
    #####: 3269:              begalt = b;
        -: 3270:	      /* If we've reached MAX_REGNUM groups, then this open
        -: 3271:		 won't actually generate any code, so we'll have to
        -: 3272:		 clear pending_exact explicitly.  */
    #####: 3273:	      pending_exact = 0;
    #####: 3274:              break;
        -: 3275:
        -: 3276:
        -: 3277:            case ')':
    #####: 3278:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
        -: 3279:
    #####: 3280:              if (COMPILE_STACK_EMPTY)
    #####: 3281:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
    #####: 3282:                  goto normal_backslash;
        -: 3283:                else
    #####: 3284:                  return REG_ERPAREN;
        -: 3285:
        -: 3286:            handle_close:
    #####: 3287:              if (fixup_alt_jump)
        -: 3288:                { /* Push a dummy failure point at the end of the
        -: 3289:                     alternative for a possible future
        -: 3290:                     `pop_failure_jump' to pop.  See comments at
        -: 3291:                     `push_dummy_failure' in `re_match_2'.  */
    #####: 3292:                  BUF_PUSH (push_dummy_failure);
        -: 3293:                  
        -: 3294:                  /* We allocated space for this jump when we assigned
        -: 3295:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
    #####: 3296:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
        -: 3297:                }
        -: 3298:
        -: 3299:              /* See similar code for backslashed left paren above.  */
    #####: 3300:              if (COMPILE_STACK_EMPTY)
    #####: 3301:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
    #####: 3302:                  goto normal_char;
        -: 3303:                else
    #####: 3304:                  return REG_ERPAREN;
        -: 3305:
        -: 3306:              /* Since we just checked for an empty stack above, this
        -: 3307:                 ``can't happen''.  */
        -: 3308:              assert (compile_stack.avail != 0);
        -: 3309:              {
        -: 3310:                /* We don't just want to restore into `regnum', because
        -: 3311:                   later groups should continue to be numbered higher,
        -: 3312:                   as in `(ab)c(de)' -- the second group is #2.  */
        -: 3313:                regnum_t this_group_regnum;
        -: 3314:
    #####: 3315:                compile_stack.avail--;		
    #####: 3316:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
        -: 3317:                fixup_alt_jump
    #####: 3318:                  = COMPILE_STACK_TOP.fixup_alt_jump
    #####: 3319:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
    #####: 3320:                    : 0;
    #####: 3321:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
    #####: 3322:                this_group_regnum = COMPILE_STACK_TOP.regnum;
        -: 3323:		/* If we've reached MAX_REGNUM groups, then this open
        -: 3324:		   won't actually generate any code, so we'll have to
        -: 3325:		   clear pending_exact explicitly.  */
    #####: 3326:		pending_exact = 0;
        -: 3327:
        -: 3328:                /* We're at the end of the group, so now we know how many
        -: 3329:                   groups were inside this one.  */
    #####: 3330:                if (this_group_regnum <= MAX_REGNUM)
        -: 3331:                  {
    #####: 3332:                    unsigned char *inner_group_loc
    #####: 3333:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
        -: 3334:                    
    #####: 3335:                    *inner_group_loc = regnum - this_group_regnum;
    #####: 3336:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
        -: 3337:                                regnum - this_group_regnum);
        -: 3338:                  }
        -: 3339:              }
    #####: 3340:              break;
        -: 3341:
        -: 3342:
        -: 3343:            case '|':					/* `\|'.  */
    #####: 3344:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
        -: 3345:                goto normal_backslash;
        -: 3346:            handle_alt:
    #####: 3347:              if (syntax & RE_LIMITED_OPS)
    #####: 3348:                goto normal_char;
        -: 3349:
        -: 3350:              /* Insert before the previous alternative a jump which
        -: 3351:                 jumps to this alternative if the former fails.  */
    #####: 3352:              GET_BUFFER_SPACE (3);
    #####: 3353:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
    #####: 3354:              pending_exact = 0;
    #####: 3355:              b += 3;
        -: 3356:
        -: 3357:              /* The alternative before this one has a jump after it
        -: 3358:                 which gets executed if it gets matched.  Adjust that
        -: 3359:                 jump so it will jump to this alternative's analogous
        -: 3360:                 jump (put in below, which in turn will jump to the next
        -: 3361:                 (if any) alternative's such jump, etc.).  The last such
        -: 3362:                 jump jumps to the correct final destination.  A picture:
        -: 3363:                          _____ _____ 
        -: 3364:                          |   | |   |   
        -: 3365:                          |   v |   v 
        -: 3366:                         a | b   | c   
        -: 3367:
        -: 3368:                 If we are at `b', then fixup_alt_jump right now points to a
        -: 3369:                 three-byte space after `a'.  We'll put in the jump, set
        -: 3370:                 fixup_alt_jump to right after `b', and leave behind three
        -: 3371:                 bytes which we'll fill in when we get to after `c'.  */
        -: 3372:
    #####: 3373:              if (fixup_alt_jump)
    #####: 3374:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
        -: 3375:
        -: 3376:              /* Mark and leave space for a jump after this alternative,
        -: 3377:                 to be filled in later either by next alternative or
        -: 3378:                 when know we're at the end of a series of alternatives.  */
    #####: 3379:              fixup_alt_jump = b;
    #####: 3380:              GET_BUFFER_SPACE (3);
    #####: 3381:              b += 3;
        -: 3382:
    #####: 3383:              laststart = 0;
    #####: 3384:              begalt = b;
    #####: 3385:              break;
        -: 3386:
        -: 3387:
        -: 3388:            case '{': 
        -: 3389:              /* If \{ is a literal.  */
    #####: 3390:              if (!(syntax & RE_INTERVALS)
        -: 3391:                     /* If we're at `\{' and it's not the open-interval 
        -: 3392:                        operator.  */
    #####: 3393:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
    #####: 3394:                  || (p - 2 == pattern  &&  p == pend))
        -: 3395:                goto normal_backslash;
        -: 3396:
        -: 3397:            handle_interval:
        -: 3398:              {
        -: 3399:                /* If got here, then the syntax allows intervals.  */
        -: 3400:
        -: 3401:                /* At least (most) this many matches must be made.  */
    #####: 3402:                int lower_bound = -1, upper_bound = -1;
        -: 3403:
    #####: 3404:                beg_interval = p - 1;
        -: 3405:
    #####: 3406:                if (p == pend)
        -: 3407:                  {
    #####: 3408:                    if (syntax & RE_NO_BK_BRACES)
    #####: 3409:                      goto unfetch_interval;
        -: 3410:                    else
    #####: 3411:                      return REG_EBRACE;
        -: 3412:                  }
        -: 3413:
    #####: 3414:                GET_UNSIGNED_NUMBER (lower_bound);
        -: 3415:
    #####: 3416:                if (c == ',')
        -: 3417:                  {
    #####: 3418:                    GET_UNSIGNED_NUMBER (upper_bound);
    #####: 3419:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
        -: 3420:                  }
        -: 3421:                else
        -: 3422:                  /* Interval such as `{1}' => match exactly once. */
    #####: 3423:                  upper_bound = lower_bound;
        -: 3424:
    #####: 3425:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
    #####: 3426:                    || lower_bound > upper_bound)
        -: 3427:                  {
    #####: 3428:                    if (syntax & RE_NO_BK_BRACES)
    #####: 3429:                      goto unfetch_interval;
        -: 3430:                    else 
    #####: 3431:                      return REG_BADBR;
        -: 3432:                  }
        -: 3433:
    #####: 3434:                if (!(syntax & RE_NO_BK_BRACES)) 
        -: 3435:                  {
    #####: 3436:                    if (c != '\\') return REG_EBRACE;
        -: 3437:
    #####: 3438:                    PATFETCH (c);
        -: 3439:                  }
        -: 3440:
    #####: 3441:                if (c != '}')
        -: 3442:                  {
    #####: 3443:                    if (syntax & RE_NO_BK_BRACES)
    #####: 3444:                      goto unfetch_interval;
        -: 3445:                    else 
    #####: 3446:                      return REG_BADBR;
        -: 3447:                  }
        -: 3448:
        -: 3449:                /* We just parsed a valid interval.  */
        -: 3450:
        -: 3451:                /* If it's invalid to have no preceding re.  */
    #####: 3452:                if (!laststart)
        -: 3453:                  {
    #####: 3454:                    if (syntax & RE_CONTEXT_INVALID_OPS)
    #####: 3455:                      return REG_BADRPT;
    #####: 3456:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
    #####: 3457:                      laststart = b;
        -: 3458:                    else
    #####: 3459:                      goto unfetch_interval;
        -: 3460:                  }
        -: 3461:
        -: 3462:                /* If the upper bound is zero, don't want to succeed at
        -: 3463:                   all; jump from `laststart' to `b + 3', which will be
        -: 3464:                   the end of the buffer after we insert the jump.  */
    #####: 3465:                 if (upper_bound == 0)
        -: 3466:                   {
    #####: 3467:                     GET_BUFFER_SPACE (3);
    #####: 3468:                     INSERT_JUMP (jump, laststart, b + 3);
    #####: 3469:                     b += 3;
        -: 3470:                   }
        -: 3471:
        -: 3472:                 /* Otherwise, we have a nontrivial interval.  When
        -: 3473:                    we're all done, the pattern will look like:
        -: 3474:                      set_number_at <jump count> <upper bound>
        -: 3475:                      set_number_at <succeed_n count> <lower bound>
        -: 3476:                      succeed_n <after jump addr> <succed_n count>
        -: 3477:                      <body of loop>
        -: 3478:                      jump_n <succeed_n addr> <jump count>
        -: 3479:                    (The upper bound and `jump_n' are omitted if
        -: 3480:                    `upper_bound' is 1, though.)  */
        -: 3481:                 else 
        -: 3482:                   { /* If the upper bound is > 1, we need to insert
        -: 3483:                        more at the end of the loop.  */
    #####: 3484:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
        -: 3485:
    #####: 3486:                     GET_BUFFER_SPACE (nbytes);
        -: 3487:
        -: 3488:                     /* Initialize lower bound of the `succeed_n', even
        -: 3489:                        though it will be set during matching by its
        -: 3490:                        attendant `set_number_at' (inserted next),
        -: 3491:                        because `re_compile_fastmap' needs to know.
        -: 3492:                        Jump to the `jump_n' we might insert below.  */
    #####: 3493:                     INSERT_JUMP2 (succeed_n, laststart,
        -: 3494:                                   b + 5 + (upper_bound > 1) * 5,
        -: 3495:                                   lower_bound);
    #####: 3496:                     b += 5;
        -: 3497:
        -: 3498:                     /* Code to initialize the lower bound.  Insert 
        -: 3499:                        before the `succeed_n'.  The `5' is the last two
        -: 3500:                        bytes of this `set_number_at', plus 3 bytes of
        -: 3501:                        the following `succeed_n'.  */
    #####: 3502:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
    #####: 3503:                     b += 5;
        -: 3504:
    #####: 3505:                     if (upper_bound > 1)
        -: 3506:                       { /* More than one repetition is allowed, so
        -: 3507:                            append a backward jump to the `succeed_n'
        -: 3508:                            that starts this interval.
        -: 3509:                            
        -: 3510:                            When we've reached this during matching,
        -: 3511:                            we'll have matched the interval once, so
        -: 3512:                            jump back only `upper_bound - 1' times.  */
    #####: 3513:                         STORE_JUMP2 (jump_n, b, laststart + 5,
        -: 3514:                                      upper_bound - 1);
    #####: 3515:                         b += 5;
        -: 3516:
        -: 3517:                         /* The location we want to set is the second
        -: 3518:                            parameter of the `jump_n'; that is `b-2' as
        -: 3519:                            an absolute address.  `laststart' will be
        -: 3520:                            the `set_number_at' we're about to insert;
        -: 3521:                            `laststart+3' the number to set, the source
        -: 3522:                            for the relative address.  But we are
        -: 3523:                            inserting into the middle of the pattern --
        -: 3524:                            so everything is getting moved up by 5.
        -: 3525:                            Conclusion: (b - 2) - (laststart + 3) + 5,
        -: 3526:                            i.e., b - laststart.
        -: 3527:                            
        -: 3528:                            We insert this at the beginning of the loop
        -: 3529:                            so that if we fail during matching, we'll
        -: 3530:                            reinitialize the bounds.  */
    #####: 3531:                         insert_op2 (set_number_at, laststart, b - laststart,
        -: 3532:                                     upper_bound - 1, b);
    #####: 3533:                         b += 5;
        -: 3534:                       }
        -: 3535:                   }
    #####: 3536:                pending_exact = 0;
    #####: 3537:                beg_interval = NULL;
        -: 3538:              }
    #####: 3539:              break;
        -: 3540:
        -: 3541:            unfetch_interval:
        -: 3542:              /* If an invalid interval, match the characters as literals.  */
        -: 3543:               assert (beg_interval);
    #####: 3544:               p = beg_interval;
    #####: 3545:               beg_interval = NULL;
        -: 3546:
        -: 3547:               /* normal_char and normal_backslash need `c'.  */
    #####: 3548:               PATFETCH (c);	
        -: 3549:
    #####: 3550:               if (!(syntax & RE_NO_BK_BRACES))
        -: 3551:                 {
    #####: 3552:                   if (p > pattern  &&  p[-1] == '\\')
    #####: 3553:                     goto normal_backslash;
        -: 3554:                 }
    #####: 3555:               goto normal_char;
        -: 3556:
        -: 3557:#ifdef emacs
        -: 3558:            /* There is no way to specify the before_dot and after_dot
        -: 3559:               operators.  rms says this is ok.  --karl  */
        -: 3560:            case '=':
        -: 3561:              BUF_PUSH (at_dot);
        -: 3562:              break;
        -: 3563:
        -: 3564:            case 's':	
        -: 3565:              laststart = b;
        -: 3566:              PATFETCH (c);
        -: 3567:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
        -: 3568:              break;
        -: 3569:
        -: 3570:            case 'S':
        -: 3571:              laststart = b;
        -: 3572:              PATFETCH (c);
        -: 3573:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
        -: 3574:              break;
        -: 3575:#endif /* emacs */
        -: 3576:
        -: 3577:
        -: 3578:            case 'w':
    #####: 3579:              laststart = b;
    #####: 3580:              BUF_PUSH (wordchar);
    #####: 3581:              break;
        -: 3582:
        -: 3583:
        -: 3584:            case 'W':
    #####: 3585:              laststart = b;
    #####: 3586:              BUF_PUSH (notwordchar);
    #####: 3587:              break;
        -: 3588:
        -: 3589:
        -: 3590:            case '<':
    #####: 3591:              BUF_PUSH (wordbeg);
    #####: 3592:              break;
        -: 3593:
        -: 3594:            case '>':
    #####: 3595:              BUF_PUSH (wordend);
    #####: 3596:              break;
        -: 3597:
        -: 3598:            case 'b':
    #####: 3599:              BUF_PUSH (wordbound);
    #####: 3600:              break;
        -: 3601:
        -: 3602:            case 'B':
    #####: 3603:              BUF_PUSH (notwordbound);
    #####: 3604:              break;
        -: 3605:
        -: 3606:            case '`':
    #####: 3607:              BUF_PUSH (begbuf);
    #####: 3608:              break;
        -: 3609:
        -: 3610:            case '\'':
    #####: 3611:              BUF_PUSH (endbuf);
    #####: 3612:              break;
        -: 3613:
        -: 3614:            case '1': case '2': case '3': case '4': case '5':
        -: 3615:            case '6': case '7': case '8': case '9':
    #####: 3616:              if (syntax & RE_NO_BK_REFS)
    #####: 3617:                goto normal_char;
        -: 3618:
    #####: 3619:              c1 = c - '0';
        -: 3620:
    #####: 3621:              if (c1 > regnum)
    #####: 3622:                return REG_ESUBREG;
        -: 3623:
        -: 3624:              /* Can't back reference to a subexpression if inside of it.  */
    #####: 3625:              if (group_in_compile_stack (compile_stack, c1))
    #####: 3626:                goto normal_char;
        -: 3627:
    #####: 3628:              laststart = b;
    #####: 3629:              BUF_PUSH_2 (duplicate, c1);
    #####: 3630:              break;
        -: 3631:
        -: 3632:
        -: 3633:            case '+':
        -: 3634:            case '?':
    #####: 3635:              if (syntax & RE_BK_PLUS_QM)
    #####: 3636:                goto handle_plus;
        -: 3637:              else
    #####: 3638:                goto normal_backslash;
        -: 3639:
        -: 3640:            default:
        -: 3641:            normal_backslash:
        -: 3642:              /* You might think it would be useful for \ to mean
        -: 3643:                 not to translate; but if we don't translate it
        -: 3644:                 it will never match anything.  */
    #####: 3645:              c = TRANSLATE (c);
    #####: 3646:              goto normal_char;
        -: 3647:            }
    #####: 3648:          break;
        -: 3649:
        -: 3650:
        -: 3651:	default:
        -: 3652:        /* Expects the character in `c'.  */
        -: 3653:	normal_char:
        -: 3654:	      /* If no exactn currently being built.  */
    #####: 3655:          if (!pending_exact 
        -: 3656:
        -: 3657:              /* If last exactn not at current position.  */
    #####: 3658:              || pending_exact + *pending_exact + 1 != b
        -: 3659:              
        -: 3660:              /* We have only one byte following the exactn for the count.  */
    #####: 3661:	      || *pending_exact == (1 << BYTEWIDTH) - 1
        -: 3662:
        -: 3663:              /* If followed by a repetition operator.  */
    #####: 3664:              || *p == '*' || *p == '^'
    #####: 3665:	      || ((syntax & RE_BK_PLUS_QM)
    #####: 3666:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
    #####: 3667:		  : (*p == '+' || *p == '?'))
    #####: 3668:	      || ((syntax & RE_INTERVALS)
    #####: 3669:                  && ((syntax & RE_NO_BK_BRACES)
        -: 3670:		      ? *p == '{'
    #####: 3671:                      : (p[0] == '\\' && p[1] == '{'))))
        -: 3672:	    {
        -: 3673:	      /* Start building a new exactn.  */
        -: 3674:              
    #####: 3675:              laststart = b;
        -: 3676:
    #####: 3677:	      BUF_PUSH_2 (exactn, 0);
    #####: 3678:	      pending_exact = b - 1;
        -: 3679:            }
        -: 3680:            
    #####: 3681:	  BUF_PUSH (c);
    #####: 3682:          (*pending_exact)++;
    #####: 3683:	  break;
        -: 3684:        } /* switch (c) */
        -: 3685:    } /* while p != pend */
        -: 3686:
        -: 3687:  
        -: 3688:  /* Through the pattern now.  */
        -: 3689:  
    #####: 3690:  if (fixup_alt_jump)
    #####: 3691:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
        -: 3692:
    #####: 3693:  if (!COMPILE_STACK_EMPTY) 
    #####: 3694:    return REG_EPAREN;
        -: 3695:
    #####: 3696:  free (compile_stack.stack);
        -: 3697:
        -: 3698:  /* We have succeeded; set the length of the buffer.  */
    #####: 3699:  bufp->used = b - bufp->buffer;
        -: 3700:
        -: 3701:#ifdef DEBUG
        -: 3702:  if (debug)
        -: 3703:    {
        -: 3704:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
        -: 3705:      print_compiled_pattern (bufp);
        -: 3706:    }
        -: 3707:#endif /* DEBUG */
        -: 3708:
    #####: 3709:  return REG_NOERROR;
        -: 3710:} /* regex_compile */
        -: 3711:
        -: 3712:/* Subroutines for `regex_compile'.  */
        -: 3713:
        -: 3714:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
        -: 3715:
        -: 3716:static void
    #####: 3717:store_op1 (op, loc, arg)
        -: 3718:    re_opcode_t op;
        -: 3719:    unsigned char *loc;
        -: 3720:    int arg;
        -: 3721:{
    #####: 3722:  *loc = (unsigned char) op;
    #####: 3723:  STORE_NUMBER (loc + 1, arg);
    #####: 3724:}
        -: 3725:
        -: 3726:
        -: 3727:/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
        -: 3728:
        -: 3729:static void
    #####: 3730:store_op2 (op, loc, arg1, arg2)
        -: 3731:    re_opcode_t op;
        -: 3732:    unsigned char *loc;
        -: 3733:    int arg1, arg2;
        -: 3734:{
    #####: 3735:  *loc = (unsigned char) op;
    #####: 3736:  STORE_NUMBER (loc + 1, arg1);
    #####: 3737:  STORE_NUMBER (loc + 3, arg2);
    #####: 3738:}
        -: 3739:
        -: 3740:
        -: 3741:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
        -: 3742:   for OP followed by two-byte integer parameter ARG.  */
        -: 3743:
        -: 3744:static void
    #####: 3745:insert_op1 (op, loc, arg, end)
        -: 3746:    re_opcode_t op;
        -: 3747:    unsigned char *loc;
        -: 3748:    int arg;
        -: 3749:    unsigned char *end;    
        -: 3750:{
    #####: 3751:  register unsigned char *pfrom = end;
    #####: 3752:  register unsigned char *pto = end + 3;
        -: 3753:
    #####: 3754:  while (pfrom != loc)
    #####: 3755:    *--pto = *--pfrom;
        -: 3756:    
    #####: 3757:  store_op1 (op, loc, arg);
    #####: 3758:}
        -: 3759:
        -: 3760:
        -: 3761:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 3762:
        -: 3763:static void
    #####: 3764:insert_op2 (op, loc, arg1, arg2, end)
        -: 3765:    re_opcode_t op;
        -: 3766:    unsigned char *loc;
        -: 3767:    int arg1, arg2;
        -: 3768:    unsigned char *end;    
        -: 3769:{
    #####: 3770:  register unsigned char *pfrom = end;
    #####: 3771:  register unsigned char *pto = end + 5;
        -: 3772:
    #####: 3773:  while (pfrom != loc)
    #####: 3774:    *--pto = *--pfrom;
        -: 3775:    
    #####: 3776:  store_op2 (op, loc, arg1, arg2);
    #####: 3777:}
        -: 3778:
        -: 3779:
        -: 3780:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
        -: 3781:   after an alternative or a begin-subexpression.  We assume there is at
        -: 3782:   least one character before the ^.  */
        -: 3783:
        -: 3784:static boolean
    #####: 3785:at_begline_loc_p (pattern, p, syntax)
        -: 3786:    const char *pattern, *p;
        -: 3787:    reg_syntax_t syntax;
        -: 3788:{
    #####: 3789:  const char *prev = p - 2;
    #####: 3790:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
        -: 3791:  
        -: 3792:  return
        -: 3793:       /* After a subexpression?  */
    #####: 3794:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
        -: 3795:       /* After an alternative?  */
    #####: 3796:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
        -: 3797:}
        -: 3798:
        -: 3799:
        -: 3800:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
        -: 3801:   at least one character after the $, i.e., `P < PEND'.  */
        -: 3802:
        -: 3803:static boolean
    #####: 3804:at_endline_loc_p (p, pend, syntax)
        -: 3805:    const char *p, *pend;
        -: 3806:    int syntax;
        -: 3807:{
    #####: 3808:  const char *next = p;
    #####: 3809:  boolean next_backslash = *next == '\\';
    #####: 3810:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
        -: 3811:  
        -: 3812:  return
        -: 3813:       /* Before a subexpression?  */
    #####: 3814:       (syntax & RE_NO_BK_PARENS ? *next == ')'
    #####: 3815:        : next_backslash && next_next && *next_next == ')')
        -: 3816:       /* Before an alternative?  */
    #####: 3817:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
    #####: 3818:        : next_backslash && next_next && *next_next == '|');
        -: 3819:}
        -: 3820:
        -: 3821:
        -: 3822:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
        -: 3823:   false if it's not.  */
        -: 3824:
        -: 3825:static boolean
    #####: 3826:group_in_compile_stack (compile_stack, regnum)
        -: 3827:    compile_stack_type compile_stack;
        -: 3828:    regnum_t regnum;
        -: 3829:{
        -: 3830:  int this_element;
        -: 3831:
    #####: 3832:  for (this_element = compile_stack.avail - 1;  
        -: 3833:       this_element >= 0; 
    #####: 3834:       this_element--)
    #####: 3835:    if (compile_stack.stack[this_element].regnum == regnum)
    #####: 3836:      return true;
        -: 3837:
    #####: 3838:  return false;
        -: 3839:}
        -: 3840:
        -: 3841:
        -: 3842:/* Read the ending character of a range (in a bracket expression) from the
        -: 3843:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
        -: 3844:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
        -: 3845:   Then we set the translation of all bits between the starting and
        -: 3846:   ending characters (inclusive) in the compiled pattern B.
        -: 3847:   
        -: 3848:   Return an error code.
        -: 3849:   
        -: 3850:   We use these short variable names so we can use the same macros as
        -: 3851:   `regex_compile' itself.  */
        -: 3852:
        -: 3853:static reg_errcode_t
    #####: 3854:compile_range (p_ptr, pend, translate, syntax, b)
        -: 3855:    const char **p_ptr, *pend;
        -: 3856:    char *translate;
        -: 3857:    reg_syntax_t syntax;
        -: 3858:    unsigned char *b;
        -: 3859:{
        -: 3860:  unsigned this_char;
        -: 3861:
    #####: 3862:  const char *p = *p_ptr;
        -: 3863:  int range_start, range_end;
        -: 3864:  
    #####: 3865:  if (p == pend)
    #####: 3866:    return REG_ERANGE;
        -: 3867:
        -: 3868:  /* Even though the pattern is a signed `char *', we need to fetch
        -: 3869:     with unsigned char *'s; if the high bit of the pattern character
        -: 3870:     is set, the range endpoints will be negative if we fetch using a
        -: 3871:     signed char *.
        -: 3872:
        -: 3873:     We also want to fetch the endpoints without translating them; the 
        -: 3874:     appropriate translation is done in the bit-setting loop below.  */
    #####: 3875:  range_start = ((unsigned char *) p)[-2];
    #####: 3876:  range_end   = ((unsigned char *) p)[0];
        -: 3877:
        -: 3878:  /* Have to increment the pointer into the pattern string, so the
        -: 3879:     caller isn't still at the ending character.  */
    #####: 3880:  (*p_ptr)++;
        -: 3881:
        -: 3882:  /* If the start is after the end, the range is empty.  */
    #####: 3883:  if (range_start > range_end)
    #####: 3884:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
        -: 3885:
        -: 3886:  /* Here we see why `this_char' has to be larger than an `unsigned
        -: 3887:     char' -- the range is inclusive, so if `range_end' == 0xff
        -: 3888:     (assuming 8-bit characters), we would otherwise go into an infinite
        -: 3889:     loop, since all characters <= 0xff.  */
    #####: 3890:  for (this_char = range_start; this_char <= range_end; this_char++)
        -: 3891:    {
    #####: 3892:      SET_LIST_BIT (TRANSLATE (this_char));
        -: 3893:    }
        -: 3894:  
    #####: 3895:  return REG_NOERROR;
        -: 3896:}
        -: 3897:
        -: 3898:/* Failure stack declarations and macros; both re_compile_fastmap and
        -: 3899:   re_match_2 use a failure stack.  These have to be macros because of
        -: 3900:   REGEX_ALLOCATE.  */
        -: 3901:   
        -: 3902:
        -: 3903:/* Number of failure points for which to initially allocate space
        -: 3904:   when matching.  If this number is exceeded, we allocate more
        -: 3905:   space, so it is not a hard limit.  */
        -: 3906:#ifndef INIT_FAILURE_ALLOC
        -: 3907:#define INIT_FAILURE_ALLOC 5
        -: 3908:#endif
        -: 3909:
        -: 3910:/* Roughly the maximum number of failure points on the stack.  Would be
        -: 3911:   exactly that if always used MAX_FAILURE_SPACE each time we failed.
        -: 3912:   This is a variable only so users of regex can assign to it; we never
        -: 3913:   change it ourselves.  */
        -: 3914:int re_max_failures = 2000;
        -: 3915:
        -: 3916:typedef const unsigned char *fail_stack_elt_t;
        -: 3917:
        -: 3918:typedef struct
        -: 3919:{
        -: 3920:  fail_stack_elt_t *stack;
        -: 3921:  unsigned size;
        -: 3922:  unsigned avail;			/* Offset of next open position.  */
        -: 3923:} fail_stack_type;
        -: 3924:
        -: 3925:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
        -: 3926:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
        -: 3927:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
        -: 3928:#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
        -: 3929:
        -: 3930:
        -: 3931:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
        -: 3932:
        -: 3933:#define INIT_FAIL_STACK()						\
        -: 3934:  do {									\
        -: 3935:    fail_stack.stack = (fail_stack_elt_t *)				\
        -: 3936:      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
        -: 3937:									\
        -: 3938:    if (fail_stack.stack == NULL)					\
        -: 3939:      return -2;							\
        -: 3940:									\
        -: 3941:    fail_stack.size = INIT_FAILURE_ALLOC;				\
        -: 3942:    fail_stack.avail = 0;						\
        -: 3943:  } while (0)
        -: 3944:
        -: 3945:
        -: 3946:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
        -: 3947:
        -: 3948:   Return 1 if succeeds, and 0 if either ran out of memory
        -: 3949:   allocating space for it or it was already too large.  
        -: 3950:   
        -: 3951:   REGEX_REALLOCATE requires `destination' be declared.   */
        -: 3952:
        -: 3953:#define DOUBLE_FAIL_STACK(fail_stack)					\
        -: 3954:  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
        -: 3955:   ? 0									\
        -: 3956:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
        -: 3957:        REGEX_REALLOCATE ((fail_stack).stack, 				\
        -: 3958:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
        -: 3959:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
        -: 3960:									\
        -: 3961:      (fail_stack).stack == NULL					\
        -: 3962:      ? 0								\
        -: 3963:      : ((fail_stack).size <<= 1, 					\
        -: 3964:         1)))
        -: 3965:
        -: 3966:
        -: 3967:/* Push PATTERN_OP on FAIL_STACK. 
        -: 3968:
        -: 3969:   Return 1 if was able to do so and 0 if ran out of memory allocating
        -: 3970:   space to do so.  */
        -: 3971:#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
        -: 3972:  ((FAIL_STACK_FULL ()							\
        -: 3973:    && !DOUBLE_FAIL_STACK (fail_stack))					\
        -: 3974:    ? 0									\
        -: 3975:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
        -: 3976:       1))
        -: 3977:
        -: 3978:/* This pushes an item onto the failure stack.  Must be a four-byte
        -: 3979:   value.  Assumes the variable `fail_stack'.  Probably should only
        -: 3980:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 3981:#define PUSH_FAILURE_ITEM(item)						\
        -: 3982:  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
        -: 3983:
        -: 3984:/* The complement operation.  Assumes `fail_stack' is nonempty.  */
        -: 3985:#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
        -: 3986:
        -: 3987:/* Used to omit pushing failure point id's when we're not debugging.  */
        -: 3988:#ifdef DEBUG
        -: 3989:#define DEBUG_PUSH PUSH_FAILURE_ITEM
        -: 3990:#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
        -: 3991:#else
        -: 3992:#define DEBUG_PUSH(item)
        -: 3993:#define DEBUG_POP(item_addr)
        -: 3994:#endif
        -: 3995:
        -: 3996:
        -: 3997:/* Push the information about the state we will need
        -: 3998:   if we ever fail back to it.  
        -: 3999:   
        -: 4000:   Requires variables fail_stack, regstart, regend, reg_info, and
        -: 4001:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
        -: 4002:   declared.
        -: 4003:   
        -: 4004:   Does `return FAILURE_CODE' if runs out of memory.  */
        -: 4005:
        -: 4006:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
        -: 4007:  do {									\
        -: 4008:    char *destination;							\
        -: 4009:    /* Must be int, so when we don't save any registers, the arithmetic	\
        -: 4010:       of 0 + -1 isn't done as unsigned.  */				\
        -: 4011:    int this_reg;							\
        -: 4012:    									\
        -: 4013:    DEBUG_STATEMENT (failure_id++);					\
        -: 4014:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
        -: 4015:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
        -: 4016:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
        -: 4017:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
        -: 4018:									\
        -: 4019:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
        -: 4020:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        -: 4021:									\
        -: 4022:    /* Ensure we have enough space allocated for what we will push.  */	\
        -: 4023:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
        -: 4024:      {									\
        -: 4025:        if (!DOUBLE_FAIL_STACK (fail_stack))			\
        -: 4026:          return failure_code;						\
        -: 4027:									\
        -: 4028:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        -: 4029:		       (fail_stack).size);				\
        -: 4030:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
        -: 4031:      }									\
        -: 4032:									\
        -: 4033:    /* Push the info, starting with the registers.  */			\
        -: 4034:    DEBUG_PRINT1 ("\n");						\
        -: 4035:									\
        -: 4036:    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
        -: 4037:         this_reg++)							\
        -: 4038:      {									\
        -: 4039:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
        -: 4040:        DEBUG_STATEMENT (num_regs_pushed++);				\
        -: 4041:									\
        -: 4042:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
        -: 4043:        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
        -: 4044:                                                                        \
        -: 4045:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
        -: 4046:        PUSH_FAILURE_ITEM (regend[this_reg]);				\
        -: 4047:									\
        -: 4048:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
        -: 4049:        DEBUG_PRINT2 (" match_null=%d",					\
        -: 4050:                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        -: 4051:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        -: 4052:        DEBUG_PRINT2 (" matched_something=%d",				\
        -: 4053:                      MATCHED_SOMETHING (reg_info[this_reg]));		\
        -: 4054:        DEBUG_PRINT2 (" ever_matched=%d",				\
        -: 4055:                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 4056:	DEBUG_PRINT1 ("\n");						\
        -: 4057:        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
        -: 4058:      }									\
        -: 4059:									\
        -: 4060:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
        -: 4061:    PUSH_FAILURE_ITEM (lowest_active_reg);				\
        -: 4062:									\
        -: 4063:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
        -: 4064:    PUSH_FAILURE_ITEM (highest_active_reg);				\
        -: 4065:									\
        -: 4066:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
        -: 4067:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
        -: 4068:    PUSH_FAILURE_ITEM (pattern_place);					\
        -: 4069:									\
        -: 4070:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
        -: 4071:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
        -: 4072:				 size2);				\
        -: 4073:    DEBUG_PRINT1 ("'\n");						\
        -: 4074:    PUSH_FAILURE_ITEM (string_place);					\
        -: 4075:									\
        -: 4076:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
        -: 4077:    DEBUG_PUSH (failure_id);						\
        -: 4078:  } while (0)
        -: 4079:
        -: 4080:/* This is the number of items that are pushed and popped on the stack
        -: 4081:   for each register.  */
        -: 4082:#define NUM_REG_ITEMS  3
        -: 4083:
        -: 4084:/* Individual items aside from the registers.  */
        -: 4085:#ifdef DEBUG
        -: 4086:#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
        -: 4087:#else
        -: 4088:#define NUM_NONREG_ITEMS 4
        -: 4089:#endif
        -: 4090:
        -: 4091:/* We push at most this many items on the stack.  */
        -: 4092:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
        -: 4093:
        -: 4094:/* We actually push this many items.  */
        -: 4095:#define NUM_FAILURE_ITEMS						\
        -: 4096:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
        -: 4097:    + NUM_NONREG_ITEMS)
        -: 4098:
        -: 4099:/* How many items can still be added to the stack without overflowing it.  */
        -: 4100:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
        -: 4101:
        -: 4102:
        -: 4103:/* Pops what PUSH_FAIL_STACK pushes.
        -: 4104:
        -: 4105:   We restore into the parameters, all of which should be lvalues:
        -: 4106:     STR -- the saved data position.
        -: 4107:     PAT -- the saved pattern position.
        -: 4108:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
        -: 4109:     REGSTART, REGEND -- arrays of string positions.
        -: 4110:     REG_INFO -- array of information about each subexpression.
        -: 4111:   
        -: 4112:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
        -: 4113:   `pend', `string1', `size1', `string2', and `size2'.  */
        -: 4114:
        -: 4115:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
        -: 4116:{									\
        -: 4117:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
        -: 4118:  int this_reg;								\
        -: 4119:  const unsigned char *string_temp;					\
        -: 4120:									\
        -: 4121:  assert (!FAIL_STACK_EMPTY ());					\
        -: 4122:									\
        -: 4123:  /* Remove failure points and point to how many regs pushed.  */	\
        -: 4124:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
        -: 4125:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
        -: 4126:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
        -: 4127:									\
        -: 4128:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
        -: 4129:									\
        -: 4130:  DEBUG_POP (&failure_id);						\
        -: 4131:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
        -: 4132:									\
        -: 4133:  /* If the saved string location is NULL, it came from an		\
        -: 4134:     on_failure_keep_string_jump opcode, and we want to throw away the	\
        -: 4135:     saved NULL, thus retaining our current position in the string.  */	\
        -: 4136:  string_temp = POP_FAILURE_ITEM ();					\
        -: 4137:  if (string_temp != NULL)						\
        -: 4138:    str = (const char *) string_temp;					\
        -: 4139:									\
        -: 4140:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
        -: 4141:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
        -: 4142:  DEBUG_PRINT1 ("'\n");							\
        -: 4143:									\
        -: 4144:  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
        -: 4145:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
        -: 4146:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
        -: 4147:									\
        -: 4148:  /* Restore register info.  */						\
        -: 4149:  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
        -: 4150:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
        -: 4151:									\
        -: 4152:  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
        -: 4153:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
        -: 4154:									\
        -: 4155:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
        -: 4156:    {									\
        -: 4157:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
        -: 4158:									\
        -: 4159:      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
        -: 4160:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
        -: 4161:									\
        -: 4162:      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
        -: 4163:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
        -: 4164:									\
        -: 4165:      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
        -: 4166:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
        -: 4167:    }									\
        -: 4168:									\
        -: 4169:  DEBUG_STATEMENT (nfailure_points_popped++);				\
        -: 4170:} /* POP_FAILURE_POINT */
        -: 4171:
        -: 4172:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
        -: 4173:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
        -: 4174:   characters can start a string that matches the pattern.  This fastmap
        -: 4175:   is used by re_search to skip quickly over impossible starting points.
        -: 4176:
        -: 4177:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
        -: 4178:   area as BUFP->fastmap.
        -: 4179:   
        -: 4180:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
        -: 4181:   the pattern buffer.
        -: 4182:
        -: 4183:   Returns 0 if we succeed, -2 if an internal error.   */
        -: 4184:
        -: 4185:int
    #####: 4186:re_compile_fastmap (bufp)
        -: 4187:     struct re_pattern_buffer *bufp;
        -: 4188:{
        -: 4189:  int j, k;
        -: 4190:  fail_stack_type fail_stack;
        -: 4191:#ifndef REGEX_MALLOC
        -: 4192:  char *destination;
        -: 4193:#endif
        -: 4194:  /* We don't push any register information onto the failure stack.  */
    #####: 4195:  unsigned num_regs = 0;
        -: 4196:  
    #####: 4197:  register char *fastmap = bufp->fastmap;
    #####: 4198:  unsigned char *pattern = bufp->buffer;
    #####: 4199:  unsigned long size = bufp->used;
    #####: 4200:  const unsigned char *p = pattern;
    #####: 4201:  register unsigned char *pend = pattern + size;
        -: 4202:
        -: 4203:  /* Assume that each path through the pattern can be null until
        -: 4204:     proven otherwise.  We set this false at the bottom of switch
        -: 4205:     statement, to which we get only if a particular path doesn't
        -: 4206:     match the empty string.  */
    #####: 4207:  boolean path_can_be_null = true;
        -: 4208:
        -: 4209:  /* We aren't doing a `succeed_n' to begin with.  */
    #####: 4210:  boolean succeed_n_p = false;
        -: 4211:
        -: 4212:  assert (fastmap != NULL && p != NULL);
        -: 4213:  
    #####: 4214:  INIT_FAIL_STACK ();
    #####: 4215:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
    #####: 4216:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
    #####: 4217:  bufp->can_be_null = 0;
        -: 4218:      
    #####: 4219:  while (p != pend || !FAIL_STACK_EMPTY ())
        -: 4220:    {
    #####: 4221:      if (p == pend)
        -: 4222:        {
    #####: 4223:          bufp->can_be_null |= path_can_be_null;
        -: 4224:          
        -: 4225:          /* Reset for next path.  */
    #####: 4226:          path_can_be_null = true;
        -: 4227:          
    #####: 4228:          p = fail_stack.stack[--fail_stack.avail];
        -: 4229:	}
        -: 4230:
        -: 4231:      /* We should never be about to go beyond the end of the pattern.  */
        -: 4232:      assert (p < pend);
        -: 4233:      
        -: 4234:#ifdef SWITCH_ENUM_BUG
        -: 4235:      switch ((int) ((re_opcode_t) *p++))
        -: 4236:#else
    #####: 4237:      switch ((re_opcode_t) *p++)
        -: 4238:#endif
        -: 4239:	{
        -: 4240:
        -: 4241:        /* I guess the idea here is to simply not bother with a fastmap
        -: 4242:           if a backreference is used, since it's too hard to figure out
        -: 4243:           the fastmap for the corresponding group.  Setting
        -: 4244:           `can_be_null' stops `re_search_2' from using the fastmap, so
        -: 4245:           that is all we do.  */
        -: 4246:	case duplicate:
    #####: 4247:	  bufp->can_be_null = 1;
    #####: 4248:          return 0;
        -: 4249:
        -: 4250:
        -: 4251:      /* Following are the cases which match a character.  These end
        -: 4252:         with `break'.  */
        -: 4253:
        -: 4254:	case exactn:
    #####: 4255:          fastmap[p[1]] = 1;
    #####: 4256:	  break;
        -: 4257:
        -: 4258:
        -: 4259:        case charset:
    #####: 4260:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
    #####: 4261:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
    #####: 4262:              fastmap[j] = 1;
    #####: 4263:	  break;
        -: 4264:
        -: 4265:
        -: 4266:	case charset_not:
        -: 4267:	  /* Chars beyond end of map must be allowed.  */
    #####: 4268:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
    #####: 4269:            fastmap[j] = 1;
        -: 4270:
    #####: 4271:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
    #####: 4272:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
    #####: 4273:              fastmap[j] = 1;
    #####: 4274:          break;
        -: 4275:
        -: 4276:
        -: 4277:	case wordchar:
    #####: 4278:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
    #####: 4279:	    if (SYNTAX (j) == Sword)
    #####: 4280:	      fastmap[j] = 1;
    #####: 4281:	  break;
        -: 4282:
        -: 4283:
        -: 4284:	case notwordchar:
    #####: 4285:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
    #####: 4286:	    if (SYNTAX (j) != Sword)
    #####: 4287:	      fastmap[j] = 1;
    #####: 4288:	  break;
        -: 4289:
        -: 4290:
        -: 4291:        case anychar:
        -: 4292:          /* `.' matches anything ...  */
    #####: 4293:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
    #####: 4294:            fastmap[j] = 1;
        -: 4295:
        -: 4296:          /* ... except perhaps newline.  */
    #####: 4297:          if (!(bufp->syntax & RE_DOT_NEWLINE))
    #####: 4298:            fastmap['\n'] = 0;
        -: 4299:
        -: 4300:          /* Return if we have already set `can_be_null'; if we have,
        -: 4301:             then the fastmap is irrelevant.  Something's wrong here.  */
    #####: 4302:	  else if (bufp->can_be_null)
    #####: 4303:	    return 0;
        -: 4304:
        -: 4305:          /* Otherwise, have to check alternative paths.  */
    #####: 4306:	  break;
        -: 4307:
        -: 4308:
        -: 4309:#ifdef emacs
        -: 4310:        case syntaxspec:
        -: 4311:	  k = *p++;
        -: 4312:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -: 4313:	    if (SYNTAX (j) == (enum syntaxcode) k)
        -: 4314:	      fastmap[j] = 1;
        -: 4315:	  break;
        -: 4316:
        -: 4317:
        -: 4318:	case notsyntaxspec:
        -: 4319:	  k = *p++;
        -: 4320:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -: 4321:	    if (SYNTAX (j) != (enum syntaxcode) k)
        -: 4322:	      fastmap[j] = 1;
        -: 4323:	  break;
        -: 4324:
        -: 4325:
        -: 4326:      /* All cases after this match the empty string.  These end with
        -: 4327:         `continue'.  */
        -: 4328:
        -: 4329:
        -: 4330:	case before_dot:
        -: 4331:	case at_dot:
        -: 4332:	case after_dot:
        -: 4333:          continue;
        -: 4334:#endif /* not emacs */
        -: 4335:
        -: 4336:
        -: 4337:        case no_op:
        -: 4338:        case begline:
        -: 4339:        case endline:
        -: 4340:	case begbuf:
        -: 4341:	case endbuf:
        -: 4342:	case wordbound:
        -: 4343:	case notwordbound:
        -: 4344:	case wordbeg:
        -: 4345:	case wordend:
        -: 4346:        case push_dummy_failure:
    #####: 4347:          continue;
        -: 4348:
        -: 4349:
        -: 4350:	case jump_n:
        -: 4351:        case pop_failure_jump:
        -: 4352:	case maybe_pop_jump:
        -: 4353:	case jump:
        -: 4354:        case jump_past_alt:
        -: 4355:	case dummy_failure_jump:
    #####: 4356:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####: 4357:	  p += j;	
    #####: 4358:	  if (j > 0)
    #####: 4359:	    continue;
        -: 4360:            
        -: 4361:          /* Jump backward implies we just went through the body of a
        -: 4362:             loop and matched nothing.  Opcode jumped to should be
        -: 4363:             `on_failure_jump' or `succeed_n'.  Just treat it like an
        -: 4364:             ordinary jump.  For a * loop, it has pushed its failure
        -: 4365:             point already; if so, discard that as redundant.  */
    #####: 4366:          if ((re_opcode_t) *p != on_failure_jump
    #####: 4367:	      && (re_opcode_t) *p != succeed_n)
    #####: 4368:	    continue;
        -: 4369:
    #####: 4370:          p++;
    #####: 4371:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####: 4372:          p += j;		
        -: 4373:	  
        -: 4374:          /* If what's on the stack is where we are now, pop it.  */
    #####: 4375:          if (!FAIL_STACK_EMPTY () 
    #####: 4376:	      && fail_stack.stack[fail_stack.avail - 1] == p)
    #####: 4377:            fail_stack.avail--;
        -: 4378:
    #####: 4379:          continue;
        -: 4380:
        -: 4381:
        -: 4382:        case on_failure_jump:
        -: 4383:        case on_failure_keep_string_jump:
        -: 4384:	handle_on_failure_jump:
    #####: 4385:          EXTRACT_NUMBER_AND_INCR (j, p);
        -: 4386:
        -: 4387:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
        -: 4388:             end of the pattern.  We don't want to push such a point,
        -: 4389:             since when we restore it above, entering the switch will
        -: 4390:             increment `p' past the end of the pattern.  We don't need
        -: 4391:             to push such a point since we obviously won't find any more
        -: 4392:             fastmap entries beyond `pend'.  Such a pattern can match
        -: 4393:             the null string, though.  */
    #####: 4394:          if (p + j < pend)
        -: 4395:            {
    #####: 4396:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
    #####: 4397:                return -2;
        -: 4398:            }
        -: 4399:          else
    #####: 4400:            bufp->can_be_null = 1;
        -: 4401:
    #####: 4402:          if (succeed_n_p)
        -: 4403:            {
    #####: 4404:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
    #####: 4405:              succeed_n_p = false;
        -: 4406:	    }
        -: 4407:
    #####: 4408:          continue;
        -: 4409:
        -: 4410:
        -: 4411:	case succeed_n:
        -: 4412:          /* Get to the number of times to succeed.  */
    #####: 4413:          p += 2;		
        -: 4414:
        -: 4415:          /* Increment p past the n for when k != 0.  */
    #####: 4416:          EXTRACT_NUMBER_AND_INCR (k, p);
    #####: 4417:          if (k == 0)
        -: 4418:	    {
    #####: 4419:              p -= 4;
    #####: 4420:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
    #####: 4421:              goto handle_on_failure_jump;
        -: 4422:            }
    #####: 4423:          continue;
        -: 4424:
        -: 4425:
        -: 4426:	case set_number_at:
    #####: 4427:          p += 4;
    #####: 4428:          continue;
        -: 4429:
        -: 4430:
        -: 4431:	case start_memory:
        -: 4432:        case stop_memory:
    #####: 4433:	  p += 2;
    #####: 4434:	  continue;
        -: 4435:
        -: 4436:
        -: 4437:	default:
    #####: 4438:          abort (); /* We have listed all the cases.  */
        -: 4439:        } /* switch *p++ */
        -: 4440:
        -: 4441:      /* Getting here means we have found the possible starting
        -: 4442:         characters for one path of the pattern -- and that the empty
        -: 4443:         string does not match.  We need not follow this path further.
        -: 4444:         Instead, look at the next alternative (remembered on the
        -: 4445:         stack), or quit if no more.  The test at the top of the loop
        -: 4446:         does these things.  */
    #####: 4447:      path_can_be_null = false;
    #####: 4448:      p = pend;
        -: 4449:    } /* while p */
        -: 4450:
        -: 4451:  /* Set `can_be_null' for the last path (also the first path, if the
        -: 4452:     pattern is empty).  */
    #####: 4453:  bufp->can_be_null |= path_can_be_null;
    #####: 4454:  return 0;
        -: 4455:} /* re_compile_fastmap */
        -: 4456:
        -: 4457:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -: 4458:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -: 4459:   this memory for recording register information.  STARTS and ENDS
        -: 4460:   must be allocated using the malloc library routine, and must each
        -: 4461:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -: 4462:
        -: 4463:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -: 4464:   register data.
        -: 4465:
        -: 4466:   Unless this function is called, the first search or match using
        -: 4467:   PATTERN_BUFFER will allocate its own register data, without
        -: 4468:   freeing the old data.  */
        -: 4469:
        -: 4470:void
    #####: 4471:re_set_registers (bufp, regs, num_regs, starts, ends)
        -: 4472:    struct re_pattern_buffer *bufp;
        -: 4473:    struct re_registers *regs;
        -: 4474:    unsigned num_regs;
        -: 4475:    regoff_t *starts, *ends;
        -: 4476:{
    #####: 4477:  if (num_regs)
        -: 4478:    {
    #####: 4479:      bufp->regs_allocated = REGS_REALLOCATE;
    #####: 4480:      regs->num_regs = num_regs;
    #####: 4481:      regs->start = starts;
    #####: 4482:      regs->end = ends;
        -: 4483:    }
        -: 4484:  else
        -: 4485:    {
    #####: 4486:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####: 4487:      regs->num_regs = 0;
    #####: 4488:      regs->start = regs->end = (regoff_t) 0;
        -: 4489:    }
    #####: 4490:}
        -: 4491:
        -: 4492:/* Searching routines.  */
        -: 4493:
        -: 4494:/* Like re_search_2, below, but only one string is specified, and
        -: 4495:   doesn't let you say where to stop matching. */
        -: 4496:
        -: 4497:int
    #####: 4498:re_search (bufp, string, size, startpos, range, regs)
        -: 4499:     struct re_pattern_buffer *bufp;
        -: 4500:     const char *string;
        -: 4501:     int size, startpos, range;
        -: 4502:     struct re_registers *regs;
        -: 4503:{
    #####: 4504:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
        -: 4505:		      regs, size);
        -: 4506:}
        -: 4507:
        -: 4508:
        -: 4509:/* Using the compiled pattern in BUFP->buffer, first tries to match the
        -: 4510:   virtual concatenation of STRING1 and STRING2, starting first at index
        -: 4511:   STARTPOS, then at STARTPOS + 1, and so on.
        -: 4512:   
        -: 4513:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
        -: 4514:   
        -: 4515:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
        -: 4516:   only at STARTPOS; in general, the last start tried is STARTPOS +
        -: 4517:   RANGE.
        -: 4518:   
        -: 4519:   In REGS, return the indices of the virtual concatenation of STRING1
        -: 4520:   and STRING2 that matched the entire BUFP->buffer and its contained
        -: 4521:   subexpressions.
        -: 4522:   
        -: 4523:   Do not consider matching one past the index STOP in the virtual
        -: 4524:   concatenation of STRING1 and STRING2.
        -: 4525:
        -: 4526:   We return either the position in the strings at which the match was
        -: 4527:   found, -1 if no match, or -2 if error (such as failure
        -: 4528:   stack overflow).  */
        -: 4529:
        -: 4530:int
    #####: 4531:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
        -: 4532:     struct re_pattern_buffer *bufp;
        -: 4533:     const char *string1, *string2;
        -: 4534:     int size1, size2;
        -: 4535:     int startpos;
        -: 4536:     int range;
        -: 4537:     struct re_registers *regs;
        -: 4538:     int stop;
        -: 4539:{
        -: 4540:  int val;
    #####: 4541:  register char *fastmap = bufp->fastmap;
    #####: 4542:  register char *translate = bufp->translate;
    #####: 4543:  int total_size = size1 + size2;
    #####: 4544:  int endpos = startpos + range;
        -: 4545:
        -: 4546:  /* Check for out-of-range STARTPOS.  */
    #####: 4547:  if (startpos < 0 || startpos > total_size)
    #####: 4548:    return -1;
        -: 4549:    
        -: 4550:  /* Fix up RANGE if it might eventually take us outside
        -: 4551:     the virtual concatenation of STRING1 and STRING2.  */
    #####: 4552:  if (endpos < -1)
    #####: 4553:    range = -1 - startpos;
    #####: 4554:  else if (endpos > total_size)
    #####: 4555:    range = total_size - startpos;
        -: 4556:
        -: 4557:  /* If the search isn't to be a backwards one, don't waste time in a
        -: 4558:     search for a pattern that must be anchored.  */
    #####: 4559:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
        -: 4560:    {
    #####: 4561:      if (startpos > 0)
    #####: 4562:	return -1;
        -: 4563:      else
    #####: 4564:	range = 1;
        -: 4565:    }
        -: 4566:
        -: 4567:  /* Update the fastmap now if not correct already.  */
    #####: 4568:  if (fastmap && !bufp->fastmap_accurate)
    #####: 4569:    if (re_compile_fastmap (bufp) == -2)
    #####: 4570:      return -2;
        -: 4571:  
        -: 4572:  /* Loop through the string, looking for a place to start matching.  */
        -: 4573:  for (;;)
        -: 4574:    { 
        -: 4575:      /* If a fastmap is supplied, skip quickly over characters that
        -: 4576:         cannot be the start of a match.  If the pattern can match the
        -: 4577:         null string, however, we don't need to skip characters; we want
        -: 4578:         the first null string.  */
    #####: 4579:      if (fastmap && startpos < total_size && !bufp->can_be_null)
        -: 4580:	{
    #####: 4581:	  if (range > 0)	/* Searching forwards.  */
        -: 4582:	    {
        -: 4583:	      register const char *d;
    #####: 4584:	      register int lim = 0;
    #####: 4585:	      int irange = range;
        -: 4586:
    #####: 4587:              if (startpos < size1 && startpos + range >= size1)
    #####: 4588:                lim = range - (size1 - startpos);
        -: 4589:
    #####: 4590:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
        -: 4591:   
        -: 4592:              /* Written out as an if-else to avoid testing `translate'
        -: 4593:                 inside the loop.  */
    #####: 4594:	      if (translate)
    #####: 4595:                while (range > lim
    #####: 4596:                       && !fastmap[(unsigned char)
    #####: 4597:				   translate[(unsigned char) *d++]])
    #####: 4598:                  range--;
        -: 4599:	      else
    #####: 4600:                while (range > lim && !fastmap[(unsigned char) *d++])
    #####: 4601:                  range--;
        -: 4602:
    #####: 4603:	      startpos += irange - range;
        -: 4604:	    }
        -: 4605:	  else				/* Searching backwards.  */
        -: 4606:	    {
    #####: 4607:	      register char c = (size1 == 0 || startpos >= size1
    #####: 4608:                                 ? string2[startpos - size1] 
    #####: 4609:                                 : string1[startpos]);
        -: 4610:
    #####: 4611:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
    #####: 4612:		goto advance;
        -: 4613:	    }
        -: 4614:	}
        -: 4615:
        -: 4616:      /* If can't match the null string, and that's all we have left, fail.  */
    #####: 4617:      if (range >= 0 && startpos == total_size && fastmap
    #####: 4618:          && !bufp->can_be_null)
    #####: 4619:	return -1;
        -: 4620:
    #####: 4621:      val = re_match_2 (bufp, string1, size1, string2, size2,
        -: 4622:	                startpos, regs, stop);
    #####: 4623:      if (val >= 0)
    #####: 4624:	return startpos;
        -: 4625:        
    #####: 4626:      if (val == -2)
    #####: 4627:	return -2;
        -: 4628:
        -: 4629:    advance:
    #####: 4630:      if (!range) 
    #####: 4631:        break;
    #####: 4632:      else if (range > 0) 
        -: 4633:        {
    #####: 4634:          range--; 
    #####: 4635:          startpos++;
        -: 4636:        }
        -: 4637:      else
        -: 4638:        {
    #####: 4639:          range++; 
    #####: 4640:          startpos--;
        -: 4641:        }
    #####: 4642:    }
    #####: 4643:  return -1;
        -: 4644:} /* re_search_2 */
        -: 4645:
        -: 4646:/* Declarations and macros for re_match_2.  */
        -: 4647:
        -: 4648:static int bcmp_translate ();
        -: 4649:static boolean alt_match_null_string_p (),
        -: 4650:               common_op_match_null_string_p (),
        -: 4651:               group_match_null_string_p ();
        -: 4652:
        -: 4653:/* Structure for per-register (a.k.a. per-group) information.
        -: 4654:   This must not be longer than one word, because we push this value
        -: 4655:   onto the failure stack.  Other register information, such as the
        -: 4656:   starting and ending positions (which are addresses), and the list of
        -: 4657:   inner groups (which is a bits list) are maintained in separate
        -: 4658:   variables.  
        -: 4659:   
        -: 4660:   We are making a (strictly speaking) nonportable assumption here: that
        -: 4661:   the compiler will pack our bit fields into something that fits into
        -: 4662:   the type of `word', i.e., is something that fits into one item on the
        -: 4663:   failure stack.  */
        -: 4664:typedef union
        -: 4665:{
        -: 4666:  fail_stack_elt_t word;
        -: 4667:  struct
        -: 4668:  {
        -: 4669:      /* This field is one if this group can match the empty string,
        -: 4670:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
        -: 4671:#define MATCH_NULL_UNSET_VALUE 3
        -: 4672:    unsigned match_null_string_p : 2;
        -: 4673:    unsigned is_active : 1;
        -: 4674:    unsigned matched_something : 1;
        -: 4675:    unsigned ever_matched_something : 1;
        -: 4676:  } bits;
        -: 4677:} register_info_type;
        -: 4678:
        -: 4679:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
        -: 4680:#define IS_ACTIVE(R)  ((R).bits.is_active)
        -: 4681:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
        -: 4682:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
        -: 4683:
        -: 4684:
        -: 4685:/* Call this when have matched a real character; it sets `matched' flags
        -: 4686:   for the subexpressions which we are currently inside.  Also records
        -: 4687:   that those subexprs have matched.  */
        -: 4688:#define SET_REGS_MATCHED()						\
        -: 4689:  do									\
        -: 4690:    {									\
        -: 4691:      unsigned r;							\
        -: 4692:      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
        -: 4693:        {								\
        -: 4694:          MATCHED_SOMETHING (reg_info[r])				\
        -: 4695:            = EVER_MATCHED_SOMETHING (reg_info[r])			\
        -: 4696:            = 1;							\
        -: 4697:        }								\
        -: 4698:    }									\
        -: 4699:  while (0)
        -: 4700:
        -: 4701:
        -: 4702:/* This converts PTR, a pointer into one of the search strings `string1'
        -: 4703:   and `string2' into an offset from the beginning of that string.  */
        -: 4704:#define POINTER_TO_OFFSET(ptr)						\
        -: 4705:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
        -: 4706:
        -: 4707:/* Registers are set to a sentinel when they haven't yet matched.  */
        -: 4708:#define REG_UNSET_VALUE ((char *) -1)
        -: 4709:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
        -: 4710:
        -: 4711:
        -: 4712:/* Macros for dealing with the split strings in re_match_2.  */
        -: 4713:
        -: 4714:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
        -: 4715:
        -: 4716:/* Call before fetching a character with *d.  This switches over to
        -: 4717:   string2 if necessary.  */
        -: 4718:#define PREFETCH()							\
        -: 4719:  while (d == dend)						    	\
        -: 4720:    {									\
        -: 4721:      /* End of string2 => fail.  */					\
        -: 4722:      if (dend == end_match_2) 						\
        -: 4723:        goto fail;							\
        -: 4724:      /* End of string1 => advance to string2.  */ 			\
        -: 4725:      d = string2;						        \
        -: 4726:      dend = end_match_2;						\
        -: 4727:    }
        -: 4728:
        -: 4729:
        -: 4730:/* Test if at very beginning or at very end of the virtual concatenation
        -: 4731:   of `string1' and `string2'.  If only one string, it's `string2'.  */
        -: 4732:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
        -: 4733:#define AT_STRINGS_END(d) ((d) == end2)	
        -: 4734:
        -: 4735:
        -: 4736:/* Test if D points to a character which is word-constituent.  We have
        -: 4737:   two special cases to check for: if past the end of string1, look at
        -: 4738:   the first character in string2; and if before the beginning of
        -: 4739:   string2, look at the last character in string1.  */
        -: 4740:#define WORDCHAR_P(d)							\
        -: 4741:  (SYNTAX ((d) == end1 ? *string2					\
        -: 4742:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
        -: 4743:   == Sword)
        -: 4744:
        -: 4745:/* Test if the character before D and the one at D differ with respect
        -: 4746:   to being word-constituent.  */
        -: 4747:#define AT_WORD_BOUNDARY(d)						\
        -: 4748:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
        -: 4749:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
        -: 4750:
        -: 4751:
        -: 4752:/* Free everything we malloc.  */
        -: 4753:#ifdef REGEX_MALLOC
        -: 4754:#define FREE_VAR(var) if (var) free (var); var = NULL
        -: 4755:#define FREE_VARIABLES()						\
        -: 4756:  do {									\
        -: 4757:    FREE_VAR (fail_stack.stack);					\
        -: 4758:    FREE_VAR (regstart);						\
        -: 4759:    FREE_VAR (regend);							\
        -: 4760:    FREE_VAR (old_regstart);						\
        -: 4761:    FREE_VAR (old_regend);						\
        -: 4762:    FREE_VAR (best_regstart);						\
        -: 4763:    FREE_VAR (best_regend);						\
        -: 4764:    FREE_VAR (reg_info);						\
        -: 4765:    FREE_VAR (reg_dummy);						\
        -: 4766:    FREE_VAR (reg_info_dummy);						\
        -: 4767:  } while (0)
        -: 4768:#else /* not REGEX_MALLOC */
        -: 4769:/* Some MIPS systems (at least) want this to free alloca'd storage.  */
        -: 4770:#define FREE_VARIABLES() alloca (0)
        -: 4771:#endif /* not REGEX_MALLOC */
        -: 4772:
        -: 4773:
        -: 4774:/* These values must meet several constraints.  They must not be valid
        -: 4775:   register values; since we have a limit of 255 registers (because
        -: 4776:   we use only one byte in the pattern for the register number), we can
        -: 4777:   use numbers larger than 255.  They must differ by 1, because of
        -: 4778:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
        -: 4779:   be larger than the value for the highest register, so we do not try
        -: 4780:   to actually save any registers when none are active.  */
        -: 4781:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
        -: 4782:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
        -: 4783:
        -: 4784:/* Matching routines.  */
        -: 4785:
        -: 4786:#ifndef emacs   /* Emacs never uses this.  */
        -: 4787:/* re_match is like re_match_2 except it takes only a single string.  */
        -: 4788:
        -: 4789:int
    #####: 4790:re_match (bufp, string, size, pos, regs)
        -: 4791:     struct re_pattern_buffer *bufp;
        -: 4792:     const char *string;
        -: 4793:     int size, pos;
        -: 4794:     struct re_registers *regs;
        -: 4795: {
    #####: 4796:  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
        -: 4797:}
        -: 4798:#endif /* not emacs */
        -: 4799:
        -: 4800:
        -: 4801:/* re_match_2 matches the compiled pattern in BUFP against the
        -: 4802:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
        -: 4803:   and SIZE2, respectively).  We start matching at POS, and stop
        -: 4804:   matching at STOP.
        -: 4805:   
        -: 4806:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
        -: 4807:   store offsets for the substring each group matched in REGS.  See the
        -: 4808:   documentation for exactly how many groups we fill.
        -: 4809:
        -: 4810:   We return -1 if no match, -2 if an internal error (such as the
        -: 4811:   failure stack overflowing).  Otherwise, we return the length of the
        -: 4812:   matched substring.  */
        -: 4813:
        -: 4814:int
    #####: 4815:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 4816:     struct re_pattern_buffer *bufp;
        -: 4817:     const char *string1, *string2;
        -: 4818:     int size1, size2;
        -: 4819:     int pos;
        -: 4820:     struct re_registers *regs;
        -: 4821:     int stop;
        -: 4822:{
        -: 4823:  /* General temporaries.  */
        -: 4824:  int mcnt;
        -: 4825:  unsigned char *p1;
        -: 4826:
        -: 4827:  /* Just past the end of the corresponding string.  */
        -: 4828:  const char *end1, *end2;
        -: 4829:
        -: 4830:  /* Pointers into string1 and string2, just past the last characters in
        -: 4831:     each to consider matching.  */
        -: 4832:  const char *end_match_1, *end_match_2;
        -: 4833:
        -: 4834:  /* Where we are in the data, and the end of the current string.  */
        -: 4835:  const char *d, *dend;
        -: 4836:  
        -: 4837:  /* Where we are in the pattern, and the end of the pattern.  */
    #####: 4838:  unsigned char *p = bufp->buffer;
    #####: 4839:  register unsigned char *pend = p + bufp->used;
        -: 4840:
        -: 4841:  /* We use this to map every character in the string.  */
    #####: 4842:  char *translate = bufp->translate;
        -: 4843:
        -: 4844:  /* Failure point stack.  Each place that can handle a failure further
        -: 4845:     down the line pushes a failure point on this stack.  It consists of
        -: 4846:     restart, regend, and reg_info for all registers corresponding to
        -: 4847:     the subexpressions we're currently inside, plus the number of such
        -: 4848:     registers, and, finally, two char *'s.  The first char * is where
        -: 4849:     to resume scanning the pattern; the second one is where to resume
        -: 4850:     scanning the strings.  If the latter is zero, the failure point is
        -: 4851:     a ``dummy''; if a failure happens and the failure point is a dummy,
        -: 4852:     it gets discarded and the next next one is tried.  */
        -: 4853:  fail_stack_type fail_stack;
        -: 4854:#ifdef DEBUG
        -: 4855:  static unsigned failure_id = 0;
        -: 4856:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
        -: 4857:#endif
        -: 4858:
        -: 4859:  /* We fill all the registers internally, independent of what we
        -: 4860:     return, for use in backreferences.  The number here includes
        -: 4861:     an element for register zero.  */
    #####: 4862:  unsigned num_regs = bufp->re_nsub + 1;
        -: 4863:  
        -: 4864:  /* The currently active registers.  */
    #####: 4865:  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####: 4866:  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 4867:
        -: 4868:  /* Information on the contents of registers. These are pointers into
        -: 4869:     the input strings; they record just what was matched (on this
        -: 4870:     attempt) by a subexpression part of the pattern, that is, the
        -: 4871:     regnum-th regstart pointer points to where in the pattern we began
        -: 4872:     matching and the regnum-th regend points to right after where we
        -: 4873:     stopped matching the regnum-th subexpression.  (The zeroth register
        -: 4874:     keeps track of what the whole pattern matches.)  */
        -: 4875:  const char **regstart, **regend;
        -: 4876:
        -: 4877:  /* If a group that's operated upon by a repetition operator fails to
        -: 4878:     match anything, then the register for its start will need to be
        -: 4879:     restored because it will have been set to wherever in the string we
        -: 4880:     are when we last see its open-group operator.  Similarly for a
        -: 4881:     register's end.  */
        -: 4882:  const char **old_regstart, **old_regend;
        -: 4883:
        -: 4884:  /* The is_active field of reg_info helps us keep track of which (possibly
        -: 4885:     nested) subexpressions we are currently in. The matched_something
        -: 4886:     field of reg_info[reg_num] helps us tell whether or not we have
        -: 4887:     matched any of the pattern so far this time through the reg_num-th
        -: 4888:     subexpression.  These two fields get reset each time through any
        -: 4889:     loop their register is in.  */
        -: 4890:  register_info_type *reg_info; 
        -: 4891:
        -: 4892:  /* The following record the register info as found in the above
        -: 4893:     variables when we find a match better than any we've seen before. 
        -: 4894:     This happens as we backtrack through the failure points, which in
        -: 4895:     turn happens only if we have not yet matched the entire string. */
    #####: 4896:  unsigned best_regs_set = false;
        -: 4897:  const char **best_regstart, **best_regend;
        -: 4898:  
        -: 4899:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
        -: 4900:     allocate space for that if we're not allocating space for anything
        -: 4901:     else (see below).  Also, we never need info about register 0 for
        -: 4902:     any of the other register vectors, and it seems rather a kludge to
        -: 4903:     treat `best_regend' differently than the rest.  So we keep track of
        -: 4904:     the end of the best match so far in a separate variable.  We
        -: 4905:     initialize this to NULL so that when we backtrack the first time
        -: 4906:     and need to test it, it's not garbage.  */
    #####: 4907:  const char *match_end = NULL;
        -: 4908:
        -: 4909:  /* Used when we pop values we don't care about.  */
        -: 4910:  const char **reg_dummy;
        -: 4911:  register_info_type *reg_info_dummy;
        -: 4912:
        -: 4913:#ifdef DEBUG
        -: 4914:  /* Counts the total number of registers pushed.  */
        -: 4915:  unsigned num_regs_pushed = 0; 	
        -: 4916:#endif
        -: 4917:
        -: 4918:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
        -: 4919:  
    #####: 4920:  INIT_FAIL_STACK ();
        -: 4921:  
        -: 4922:  /* Do not bother to initialize all the register variables if there are
        -: 4923:     no groups in the pattern, as it takes a fair amount of time.  If
        -: 4924:     there are groups, we include space for register 0 (the whole
        -: 4925:     pattern), even though we never use it, since it simplifies the
        -: 4926:     array indexing.  We should fix this.  */
    #####: 4927:  if (bufp->re_nsub)
        -: 4928:    {
    #####: 4929:      regstart = REGEX_TALLOC (num_regs, const char *);
    #####: 4930:      regend = REGEX_TALLOC (num_regs, const char *);
    #####: 4931:      old_regstart = REGEX_TALLOC (num_regs, const char *);
    #####: 4932:      old_regend = REGEX_TALLOC (num_regs, const char *);
    #####: 4933:      best_regstart = REGEX_TALLOC (num_regs, const char *);
    #####: 4934:      best_regend = REGEX_TALLOC (num_regs, const char *);
    #####: 4935:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
    #####: 4936:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
    #####: 4937:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
        -: 4938:
    #####: 4939:      if (!(regstart && regend && old_regstart && old_regend && reg_info 
    #####: 4940:            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
        -: 4941:        {
    #####: 4942:          FREE_VARIABLES ();
    #####: 4943:          return -2;
        -: 4944:        }
        -: 4945:    }
        -: 4946:#ifdef REGEX_MALLOC
        -: 4947:  else
        -: 4948:    {
        -: 4949:      /* We must initialize all our variables to NULL, so that
        -: 4950:         `FREE_VARIABLES' doesn't try to free them.  */
        -: 4951:      regstart = regend = old_regstart = old_regend = best_regstart
        -: 4952:        = best_regend = reg_dummy = NULL;
        -: 4953:      reg_info = reg_info_dummy = (register_info_type *) NULL;
        -: 4954:    }
        -: 4955:#endif /* REGEX_MALLOC */
        -: 4956:
        -: 4957:  /* The starting position is bogus.  */
    #####: 4958:  if (pos < 0 || pos > size1 + size2)
        -: 4959:    {
    #####: 4960:      FREE_VARIABLES ();
    #####: 4961:      return -1;
        -: 4962:    }
        -: 4963:    
        -: 4964:  /* Initialize subexpression text positions to -1 to mark ones that no
        -: 4965:     start_memory/stop_memory has been seen for. Also initialize the
        -: 4966:     register information struct.  */
    #####: 4967:  for (mcnt = 1; mcnt < num_regs; mcnt++)
        -: 4968:    {
    #####: 4969:      regstart[mcnt] = regend[mcnt] 
    #####: 4970:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
        -: 4971:        
    #####: 4972:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
    #####: 4973:      IS_ACTIVE (reg_info[mcnt]) = 0;
    #####: 4974:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    #####: 4975:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
        -: 4976:    }
        -: 4977:  
        -: 4978:  /* We move `string1' into `string2' if the latter's empty -- but not if
        -: 4979:     `string1' is null.  */
    #####: 4980:  if (size2 == 0 && string1 != NULL)
        -: 4981:    {
    #####: 4982:      string2 = string1;
    #####: 4983:      size2 = size1;
    #####: 4984:      string1 = 0;
    #####: 4985:      size1 = 0;
        -: 4986:    }
    #####: 4987:  end1 = string1 + size1;
    #####: 4988:  end2 = string2 + size2;
        -: 4989:
        -: 4990:  /* Compute where to stop matching, within the two strings.  */
    #####: 4991:  if (stop <= size1)
        -: 4992:    {
    #####: 4993:      end_match_1 = string1 + stop;
    #####: 4994:      end_match_2 = string2;
        -: 4995:    }
        -: 4996:  else
        -: 4997:    {
    #####: 4998:      end_match_1 = end1;
    #####: 4999:      end_match_2 = string2 + stop - size1;
        -: 5000:    }
        -: 5001:
        -: 5002:  /* `p' scans through the pattern as `d' scans through the data. 
        -: 5003:     `dend' is the end of the input string that `d' points within.  `d'
        -: 5004:     is advanced into the following input string whenever necessary, but
        -: 5005:     this happens before fetching; therefore, at the beginning of the
        -: 5006:     loop, `d' can be pointing at the end of a string, but it cannot
        -: 5007:     equal `string2'.  */
    #####: 5008:  if (size1 > 0 && pos <= size1)
        -: 5009:    {
    #####: 5010:      d = string1 + pos;
    #####: 5011:      dend = end_match_1;
        -: 5012:    }
        -: 5013:  else
        -: 5014:    {
    #####: 5015:      d = string2 + pos - size1;
    #####: 5016:      dend = end_match_2;
        -: 5017:    }
        -: 5018:
        -: 5019:  DEBUG_PRINT1 ("The compiled pattern is: ");
        -: 5020:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
        -: 5021:  DEBUG_PRINT1 ("The string to match is: `");
        -: 5022:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
        -: 5023:  DEBUG_PRINT1 ("'\n");
        -: 5024:  
        -: 5025:  /* This loops over pattern commands.  It exits by returning from the
        -: 5026:     function if the match is complete, or it drops through if the match
        -: 5027:     fails at this starting point in the input data.  */
        -: 5028:  for (;;)
        -: 5029:    {
        -: 5030:      DEBUG_PRINT2 ("\n0x%x: ", p);
        -: 5031:
    #####: 5032:      if (p == pend)
        -: 5033:	{ /* End of pattern means we might have succeeded.  */
        -: 5034:          DEBUG_PRINT1 ("end of pattern ... ");
        -: 5035:          
        -: 5036:	  /* If we haven't matched the entire string, and we want the
        -: 5037:             longest match, try backtracking.  */
    #####: 5038:          if (d != end_match_2)
        -: 5039:	    {
        -: 5040:              DEBUG_PRINT1 ("backtracking.\n");
        -: 5041:              
    #####: 5042:              if (!FAIL_STACK_EMPTY ())
        -: 5043:                { /* More failure points to try.  */
    #####: 5044:                  boolean same_str_p = (FIRST_STRING_P (match_end) 
    #####: 5045:	        	                == MATCHING_IN_FIRST_STRING);
        -: 5046:
        -: 5047:                  /* If exceeds best match so far, save it.  */
    #####: 5048:                  if (!best_regs_set
    #####: 5049:                      || (same_str_p && d > match_end)
    #####: 5050:                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
        -: 5051:                    {
    #####: 5052:                      best_regs_set = true;
    #####: 5053:                      match_end = d;
        -: 5054:                      
        -: 5055:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
        -: 5056:                      
    #####: 5057:                      for (mcnt = 1; mcnt < num_regs; mcnt++)
        -: 5058:                        {
    #####: 5059:                          best_regstart[mcnt] = regstart[mcnt];
    #####: 5060:                          best_regend[mcnt] = regend[mcnt];
        -: 5061:                        }
        -: 5062:                    }
    #####: 5063:                  goto fail;	       
        -: 5064:                }
        -: 5065:
        -: 5066:              /* If no failure points, don't restore garbage.  */
    #####: 5067:              else if (best_regs_set)   
        -: 5068:                {
        -: 5069:  	        restore_best_regs:
        -: 5070:                  /* Restore best match.  It may happen that `dend ==
        -: 5071:                     end_match_1' while the restored d is in string2.
        -: 5072:                     For example, the pattern `x.*y.*z' against the
        -: 5073:                     strings `x-' and `y-z-', if the two strings are
        -: 5074:                     not consecutive in memory.  */
        -: 5075:                  DEBUG_PRINT1 ("Restoring best registers.\n");
        -: 5076:                  
    #####: 5077:                  d = match_end;
    #####: 5078:                  dend = ((d >= string1 && d <= end1)
    #####: 5079:		           ? end_match_1 : end_match_2);
        -: 5080:
    #####: 5081:		  for (mcnt = 1; mcnt < num_regs; mcnt++)
        -: 5082:		    {
    #####: 5083:		      regstart[mcnt] = best_regstart[mcnt];
    #####: 5084:		      regend[mcnt] = best_regend[mcnt];
        -: 5085:		    }
        -: 5086:                }
        -: 5087:            } /* d != end_match_2 */
        -: 5088:
        -: 5089:          DEBUG_PRINT1 ("Accepting match.\n");
        -: 5090:
        -: 5091:          /* If caller wants register contents data back, do it.  */
    #####: 5092:          if (regs && !bufp->no_sub)
        -: 5093:	    {
        -: 5094:              /* Have the register data arrays been allocated?  */
    #####: 5095:              if (bufp->regs_allocated == REGS_UNALLOCATED)
        -: 5096:                { /* No.  So allocate them with malloc.  We need one
        -: 5097:                     extra element beyond `num_regs' for the `-1' marker
        -: 5098:                     GNU code uses.  */
    #####: 5099:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
    #####: 5100:                  regs->start = TALLOC (regs->num_regs, regoff_t);
    #####: 5101:                  regs->end = TALLOC (regs->num_regs, regoff_t);
    #####: 5102:                  if (regs->start == NULL || regs->end == NULL)
    #####: 5103:                    return -2;
    #####: 5104:                  bufp->regs_allocated = REGS_REALLOCATE;
        -: 5105:                }
    #####: 5106:              else if (bufp->regs_allocated == REGS_REALLOCATE)
        -: 5107:                { /* Yes.  If we need more elements than were already
        -: 5108:                     allocated, reallocate them.  If we need fewer, just
        -: 5109:                     leave it alone.  */
    #####: 5110:                  if (regs->num_regs < num_regs + 1)
        -: 5111:                    {
    #####: 5112:                      regs->num_regs = num_regs + 1;
    #####: 5113:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
    #####: 5114:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
    #####: 5115:                      if (regs->start == NULL || regs->end == NULL)
    #####: 5116:                        return -2;
        -: 5117:                    }
        -: 5118:                }
        -: 5119:              else
        -: 5120:		{
        -: 5121:		  /* These braces fend off a "empty body in an else-statement"
        -: 5122:		     warning under GCC when assert expands to nothing.  */
        -: 5123:		  assert (bufp->regs_allocated == REGS_FIXED);
        -: 5124:		}
        -: 5125:
        -: 5126:              /* Convert the pointer data in `regstart' and `regend' to
        -: 5127:                 indices.  Register zero has to be set differently,
        -: 5128:                 since we haven't kept track of any info for it.  */
    #####: 5129:              if (regs->num_regs > 0)
        -: 5130:                {
    #####: 5131:                  regs->start[0] = pos;
    #####: 5132:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
    #####: 5133:			          : d - string2 + size1);
        -: 5134:                }
        -: 5135:              
        -: 5136:              /* Go through the first `min (num_regs, regs->num_regs)'
        -: 5137:                 registers, since that is all we initialized.  */
    #####: 5138:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
        -: 5139:		{
    #####: 5140:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
    #####: 5141:                    regs->start[mcnt] = regs->end[mcnt] = -1;
        -: 5142:                  else
        -: 5143:                    {
    #####: 5144:		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
    #####: 5145:                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
        -: 5146:                    }
        -: 5147:		}
        -: 5148:              
        -: 5149:              /* If the regs structure we return has more elements than
        -: 5150:                 were in the pattern, set the extra elements to -1.  If
        -: 5151:                 we (re)allocated the registers, this is the case,
        -: 5152:                 because we always allocate enough to have at least one
        -: 5153:                 -1 at the end.  */
    #####: 5154:              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
    #####: 5155:                regs->start[mcnt] = regs->end[mcnt] = -1;
        -: 5156:	    } /* regs && !bufp->no_sub */
        -: 5157:
    #####: 5158:          FREE_VARIABLES ();
        -: 5159:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
        -: 5160:                        nfailure_points_pushed, nfailure_points_popped,
        -: 5161:                        nfailure_points_pushed - nfailure_points_popped);
        -: 5162:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
        -: 5163:
    #####: 5164:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
        -: 5165:			    ? string1 
    #####: 5166:			    : string2 - size1);
        -: 5167:
        -: 5168:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
        -: 5169:
    #####: 5170:          return mcnt;
        -: 5171:        }
        -: 5172:
        -: 5173:      /* Otherwise match next pattern command.  */
        -: 5174:#ifdef SWITCH_ENUM_BUG
        -: 5175:      switch ((int) ((re_opcode_t) *p++))
        -: 5176:#else
    #####: 5177:      switch ((re_opcode_t) *p++)
        -: 5178:#endif
        -: 5179:	{
        -: 5180:        /* Ignore these.  Used to ignore the n of succeed_n's which
        -: 5181:           currently have n == 0.  */
        -: 5182:        case no_op:
        -: 5183:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
    #####: 5184:          break;
        -: 5185:
        -: 5186:
        -: 5187:        /* Match the next n pattern characters exactly.  The following
        -: 5188:           byte in the pattern defines n, and the n bytes after that
        -: 5189:           are the characters to match.  */
        -: 5190:	case exactn:
    #####: 5191:	  mcnt = *p++;
        -: 5192:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
        -: 5193:
        -: 5194:          /* This is written out as an if-else so we don't waste time
        -: 5195:             testing `translate' inside the loop.  */
    #####: 5196:          if (translate)
        -: 5197:	    {
        -: 5198:	      do
        -: 5199:		{
    #####: 5200:		  PREFETCH ();
    #####: 5201:		  if (translate[(unsigned char) *d++] != (char) *p++)
    #####: 5202:                    goto fail;
        -: 5203:		}
    #####: 5204:	      while (--mcnt);
        -: 5205:	    }
        -: 5206:	  else
        -: 5207:	    {
        -: 5208:	      do
        -: 5209:		{
    #####: 5210:		  PREFETCH ();
    #####: 5211:		  if (*d++ != (char) *p++) goto fail;
        -: 5212:		}
    #####: 5213:	      while (--mcnt);
        -: 5214:	    }
    #####: 5215:	  SET_REGS_MATCHED ();
    #####: 5216:          break;
        -: 5217:
        -: 5218:
        -: 5219:        /* Match any character except possibly a newline or a null.  */
        -: 5220:	case anychar:
        -: 5221:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
        -: 5222:
    #####: 5223:          PREFETCH ();
        -: 5224:
    #####: 5225:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
    #####: 5226:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
        -: 5227:	    goto fail;
        -: 5228:
    #####: 5229:          SET_REGS_MATCHED ();
        -: 5230:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
    #####: 5231:          d++;
    #####: 5232:	  break;
        -: 5233:
        -: 5234:
        -: 5235:	case charset:
        -: 5236:	case charset_not:
        -: 5237:	  {
        -: 5238:	    register unsigned char c;
    #####: 5239:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
        -: 5240:
        -: 5241:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
        -: 5242:
    #####: 5243:	    PREFETCH ();
    #####: 5244:	    c = TRANSLATE (*d); /* The character to match.  */
        -: 5245:
        -: 5246:            /* Cast to `unsigned' instead of `unsigned char' in case the
        -: 5247:               bit list is a full 32 bytes long.  */
    #####: 5248:	    if (c < (unsigned) (*p * BYTEWIDTH)
    #####: 5249:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
    #####: 5250:	      not = !not;
        -: 5251:
    #####: 5252:	    p += 1 + *p;
        -: 5253:
    #####: 5254:	    if (!not) goto fail;
        -: 5255:            
    #####: 5256:	    SET_REGS_MATCHED ();
    #####: 5257:            d++;
    #####: 5258:	    break;
        -: 5259:	  }
        -: 5260:
        -: 5261:
        -: 5262:        /* The beginning of a group is represented by start_memory.
        -: 5263:           The arguments are the register number in the next byte, and the
        -: 5264:           number of groups inner to this one in the next.  The text
        -: 5265:           matched within the group is recorded (in the internal
        -: 5266:           registers data structure) under the register number.  */
        -: 5267:        case start_memory:
        -: 5268:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
        -: 5269:
        -: 5270:          /* Find out if this group can match the empty string.  */
    #####: 5271:	  p1 = p;		/* To send to group_match_null_string_p.  */
        -: 5272:          
    #####: 5273:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
    #####: 5274:            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
    #####: 5275:              = group_match_null_string_p (&p1, pend, reg_info);
        -: 5276:
        -: 5277:          /* Save the position in the string where we were the last time
        -: 5278:             we were at this open-group operator in case the group is
        -: 5279:             operated upon by a repetition operator, e.g., with `(a*)*b'
        -: 5280:             against `ab'; then we want to ignore where we are now in
        -: 5281:             the string in case this attempt to match fails.  */
    #####: 5282:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####: 5283:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
    #####: 5284:                             : regstart[*p];
        -: 5285:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
        -: 5286:			 POINTER_TO_OFFSET (old_regstart[*p]));
        -: 5287:
    #####: 5288:          regstart[*p] = d;
        -: 5289:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
        -: 5290:
    #####: 5291:          IS_ACTIVE (reg_info[*p]) = 1;
    #####: 5292:          MATCHED_SOMETHING (reg_info[*p]) = 0;
        -: 5293:          
        -: 5294:          /* This is the new highest active register.  */
    #####: 5295:          highest_active_reg = *p;
        -: 5296:          
        -: 5297:          /* If nothing was active before, this is the new lowest active
        -: 5298:             register.  */
    #####: 5299:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
    #####: 5300:            lowest_active_reg = *p;
        -: 5301:
        -: 5302:          /* Move past the register number and inner group count.  */
    #####: 5303:          p += 2;
    #####: 5304:          break;
        -: 5305:
        -: 5306:
        -: 5307:        /* The stop_memory opcode represents the end of a group.  Its
        -: 5308:           arguments are the same as start_memory's: the register
        -: 5309:           number, and the number of inner groups.  */
        -: 5310:	case stop_memory:
        -: 5311:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
        -: 5312:             
        -: 5313:          /* We need to save the string position the last time we were at
        -: 5314:             this close-group operator in case the group is operated
        -: 5315:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
        -: 5316:             against `aba'; then we want to ignore where we are now in
        -: 5317:             the string in case this attempt to match fails.  */
    #####: 5318:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####: 5319:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
    #####: 5320:			   : regend[*p];
        -: 5321:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
        -: 5322:			 POINTER_TO_OFFSET (old_regend[*p]));
        -: 5323:
    #####: 5324:          regend[*p] = d;
        -: 5325:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
        -: 5326:
        -: 5327:          /* This register isn't active anymore.  */
    #####: 5328:          IS_ACTIVE (reg_info[*p]) = 0;
        -: 5329:          
        -: 5330:          /* If this was the only register active, nothing is active
        -: 5331:             anymore.  */
    #####: 5332:          if (lowest_active_reg == highest_active_reg)
        -: 5333:            {
    #####: 5334:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####: 5335:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 5336:            }
        -: 5337:          else
        -: 5338:            { /* We must scan for the new highest active register, since
        -: 5339:                 it isn't necessarily one less than now: consider
        -: 5340:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
        -: 5341:                 new highest active register is 1.  */
    #####: 5342:              unsigned char r = *p - 1;
    #####: 5343:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
    #####: 5344:                r--;
        -: 5345:              
        -: 5346:              /* If we end up at register zero, that means that we saved
        -: 5347:                 the registers as the result of an `on_failure_jump', not
        -: 5348:                 a `start_memory', and we jumped to past the innermost
        -: 5349:                 `stop_memory'.  For example, in ((.)*) we save
        -: 5350:                 registers 1 and 2 as a result of the *, but when we pop
        -: 5351:                 back to the second ), we are at the stop_memory 1.
        -: 5352:                 Thus, nothing is active.  */
    #####: 5353:	      if (r == 0)
        -: 5354:                {
    #####: 5355:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####: 5356:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -: 5357:                }
        -: 5358:              else
    #####: 5359:                highest_active_reg = r;
        -: 5360:            }
        -: 5361:          
        -: 5362:          /* If just failed to match something this time around with a
        -: 5363:             group that's operated on by a repetition operator, try to
        -: 5364:             force exit from the ``loop'', and restore the register
        -: 5365:             information for this group that we had before trying this
        -: 5366:             last match.  */
    #####: 5367:          if ((!MATCHED_SOMETHING (reg_info[*p])
    #####: 5368:               || (re_opcode_t) p[-3] == start_memory)
    #####: 5369:	      && (p + 2) < pend)              
        -: 5370:            {
    #####: 5371:              boolean is_a_jump_n = false;
        -: 5372:              
    #####: 5373:              p1 = p + 2;
    #####: 5374:              mcnt = 0;
    #####: 5375:              switch ((re_opcode_t) *p1++)
        -: 5376:                {
        -: 5377:                  case jump_n:
    #####: 5378:		    is_a_jump_n = true;
        -: 5379:                  case pop_failure_jump:
        -: 5380:		  case maybe_pop_jump:
        -: 5381:		  case jump:
        -: 5382:		  case dummy_failure_jump:
    #####: 5383:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 5384:		    if (is_a_jump_n)
    #####: 5385:		      p1 += 2;
    #####: 5386:                    break;
        -: 5387:                  
        -: 5388:                  default:
        -: 5389:                    /* do nothing */ ;
        -: 5390:                }
    #####: 5391:	      p1 += mcnt;
        -: 5392:        
        -: 5393:              /* If the next operation is a jump backwards in the pattern
        -: 5394:	         to an on_failure_jump right before the start_memory
        -: 5395:                 corresponding to this stop_memory, exit from the loop
        -: 5396:                 by forcing a failure after pushing on the stack the
        -: 5397:                 on_failure_jump's jump in the pattern, and d.  */
    #####: 5398:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
    #####: 5399:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
        -: 5400:		{
        -: 5401:                  /* If this group ever matched anything, then restore
        -: 5402:                     what its registers were before trying this last
        -: 5403:                     failed match, e.g., with `(a*)*b' against `ab' for
        -: 5404:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
        -: 5405:                     against `aba' for regend[3].
        -: 5406:                     
        -: 5407:                     Also restore the registers for inner groups for,
        -: 5408:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
        -: 5409:                     otherwise get trashed).  */
        -: 5410:                     
    #####: 5411:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
        -: 5412:		    {
        -: 5413:		      unsigned r; 
        -: 5414:        
    #####: 5415:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
        -: 5416:                      
        -: 5417:		      /* Restore this and inner groups' (if any) registers.  */
    #####: 5418:                      for (r = *p; r < *p + *(p + 1); r++)
        -: 5419:                        {
    #####: 5420:                          regstart[r] = old_regstart[r];
        -: 5421:
        -: 5422:                          /* xx why this test?  */
    #####: 5423:                          if ((int) old_regend[r] >= (int) regstart[r])
    #####: 5424:                            regend[r] = old_regend[r];
        -: 5425:                        }     
        -: 5426:                    }
    #####: 5427:		  p1++;
    #####: 5428:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 5429:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
        -: 5430:
    #####: 5431:                  goto fail;
        -: 5432:                }
        -: 5433:            }
        -: 5434:          
        -: 5435:          /* Move past the register number and the inner group count.  */
    #####: 5436:          p += 2;
    #####: 5437:          break;
        -: 5438:
        -: 5439:
        -: 5440:	/* \<digit> has been turned into a `duplicate' command which is
        -: 5441:           followed by the numeric value of <digit> as the register number.  */
        -: 5442:        case duplicate:
        -: 5443:	  {
        -: 5444:	    register const char *d2, *dend2;
    #####: 5445:	    int regno = *p++;   /* Get which register to match against.  */
        -: 5446:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
        -: 5447:
        -: 5448:	    /* Can't back reference a group which we've never matched.  */
    #####: 5449:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
        -: 5450:              goto fail;
        -: 5451:              
        -: 5452:            /* Where in input to try to start matching.  */
    #####: 5453:            d2 = regstart[regno];
        -: 5454:            
        -: 5455:            /* Where to stop matching; if both the place to start and
        -: 5456:               the place to stop matching are in the same string, then
        -: 5457:               set to the place to stop, otherwise, for now have to use
        -: 5458:               the end of the first string.  */
        -: 5459:
    #####: 5460:            dend2 = ((FIRST_STRING_P (regstart[regno]) 
    #####: 5461:		      == FIRST_STRING_P (regend[regno]))
    #####: 5462:		     ? regend[regno] : end_match_1);
        -: 5463:	    for (;;)
        -: 5464:	      {
        -: 5465:		/* If necessary, advance to next segment in register
        -: 5466:                   contents.  */
    #####: 5467:		while (d2 == dend2)
        -: 5468:		  {
    #####: 5469:		    if (dend2 == end_match_2) break;
    #####: 5470:		    if (dend2 == regend[regno]) break;
        -: 5471:
        -: 5472:                    /* End of string1 => advance to string2. */
    #####: 5473:                    d2 = string2;
    #####: 5474:                    dend2 = regend[regno];
        -: 5475:		  }
        -: 5476:		/* At end of register contents => success */
    #####: 5477:		if (d2 == dend2) break;
        -: 5478:
        -: 5479:		/* If necessary, advance to next segment in data.  */
    #####: 5480:		PREFETCH ();
        -: 5481:
        -: 5482:		/* How many characters left in this segment to match.  */
    #####: 5483:		mcnt = dend - d;
        -: 5484:                
        -: 5485:		/* Want how many consecutive characters we can match in
        -: 5486:                   one shot, so, if necessary, adjust the count.  */
    #####: 5487:                if (mcnt > dend2 - d2)
    #####: 5488:		  mcnt = dend2 - d2;
        -: 5489:                  
        -: 5490:		/* Compare that many; failure if mismatch, else move
        -: 5491:                   past them.  */
    #####: 5492:		if (translate 
    #####: 5493:                    ? bcmp_translate (d, d2, mcnt, translate) 
    #####: 5494:                    : bcmp (d, d2, mcnt))
    #####: 5495:		  goto fail;
    #####: 5496:		d += mcnt, d2 += mcnt;
    #####: 5497:	      }
        -: 5498:	  }
    #####: 5499:	  break;
        -: 5500:
        -: 5501:
        -: 5502:        /* begline matches the empty string at the beginning of the string
        -: 5503:           (unless `not_bol' is set in `bufp'), and, if
        -: 5504:           `newline_anchor' is set, after newlines.  */
        -: 5505:	case begline:
        -: 5506:          DEBUG_PRINT1 ("EXECUTING begline.\n");
        -: 5507:          
    #####: 5508:          if (AT_STRINGS_BEG (d))
        -: 5509:            {
    #####: 5510:              if (!bufp->not_bol) break;
        -: 5511:            }
    #####: 5512:          else if (d[-1] == '\n' && bufp->newline_anchor)
        -: 5513:            {
    #####: 5514:              break;
        -: 5515:            }
        -: 5516:          /* In all other cases, we fail.  */
    #####: 5517:          goto fail;
        -: 5518:
        -: 5519:
        -: 5520:        /* endline is the dual of begline.  */
        -: 5521:	case endline:
        -: 5522:          DEBUG_PRINT1 ("EXECUTING endline.\n");
        -: 5523:
    #####: 5524:          if (AT_STRINGS_END (d))
        -: 5525:            {
    #####: 5526:              if (!bufp->not_eol) break;
        -: 5527:            }
        -: 5528:          
        -: 5529:          /* We have to ``prefetch'' the next character.  */
    #####: 5530:          else if ((d == end1 ? *string2 : *d) == '\n'
    #####: 5531:                   && bufp->newline_anchor)
        -: 5532:            {
    #####: 5533:              break;
        -: 5534:            }
    #####: 5535:          goto fail;
        -: 5536:
        -: 5537:
        -: 5538:	/* Match at the very beginning of the data.  */
        -: 5539:        case begbuf:
        -: 5540:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
    #####: 5541:          if (AT_STRINGS_BEG (d))
        -: 5542:            break;
    #####: 5543:          goto fail;
        -: 5544:
        -: 5545:
        -: 5546:	/* Match at the very end of the data.  */
        -: 5547:        case endbuf:
        -: 5548:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
    #####: 5549:	  if (AT_STRINGS_END (d))
    #####: 5550:	    break;
    #####: 5551:          goto fail;
        -: 5552:
        -: 5553:
        -: 5554:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
        -: 5555:           pushes NULL as the value for the string on the stack.  Then
        -: 5556:           `pop_failure_point' will keep the current value for the
        -: 5557:           string, instead of restoring it.  To see why, consider
        -: 5558:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
        -: 5559:           then the . fails against the \n.  But the next thing we want
        -: 5560:           to do is match the \n against the \n; if we restored the
        -: 5561:           string value, we would be back at the foo.
        -: 5562:           
        -: 5563:           Because this is used only in specific cases, we don't need to
        -: 5564:           check all the things that `on_failure_jump' does, to make
        -: 5565:           sure the right things get saved on the stack.  Hence we don't
        -: 5566:           share its code.  The only reason to push anything on the
        -: 5567:           stack at all is that otherwise we would have to change
        -: 5568:           `anychar's code to do something besides goto fail in this
        -: 5569:           case; that seems worse than this.  */
        -: 5570:        case on_failure_keep_string_jump:
        -: 5571:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
        -: 5572:          
    #####: 5573:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 5574:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
        -: 5575:
    #####: 5576:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
    #####: 5577:          break;
        -: 5578:
        -: 5579:
        -: 5580:	/* Uses of on_failure_jump:
        -: 5581:        
        -: 5582:           Each alternative starts with an on_failure_jump that points
        -: 5583:           to the beginning of the next alternative.  Each alternative
        -: 5584:           except the last ends with a jump that in effect jumps past
        -: 5585:           the rest of the alternatives.  (They really jump to the
        -: 5586:           ending jump of the following alternative, because tensioning
        -: 5587:           these jumps is a hassle.)
        -: 5588:
        -: 5589:           Repeats start with an on_failure_jump that points past both
        -: 5590:           the repetition text and either the following jump or
        -: 5591:           pop_failure_jump back to this on_failure_jump.  */
        -: 5592:	case on_failure_jump:
        -: 5593:        on_failure:
        -: 5594:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
        -: 5595:
    #####: 5596:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 5597:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
        -: 5598:
        -: 5599:          /* If this on_failure_jump comes right before a group (i.e.,
        -: 5600:             the original * applied to a group), save the information
        -: 5601:             for that group and all inner ones, so that if we fail back
        -: 5602:             to this point, the group's information will be correct.
        -: 5603:             For example, in \(a*\)*\1, we need the preceding group,
        -: 5604:             and in \(\(a*\)b*\)\2, we need the inner group.  */
        -: 5605:
        -: 5606:          /* We can't use `p' to check ahead because we push
        -: 5607:             a failure point to `p + mcnt' after we do this.  */
    #####: 5608:          p1 = p;
        -: 5609:
        -: 5610:          /* We need to skip no_op's before we look for the
        -: 5611:             start_memory in case this on_failure_jump is happening as
        -: 5612:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
        -: 5613:             against aba.  */
    #####: 5614:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
    #####: 5615:            p1++;
        -: 5616:
    #####: 5617:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
        -: 5618:            {
        -: 5619:              /* We have a new highest active register now.  This will
        -: 5620:                 get reset at the start_memory we are about to get to,
        -: 5621:                 but we will have saved all the registers relevant to
        -: 5622:                 this repetition op, as described above.  */
    #####: 5623:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
    #####: 5624:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
    #####: 5625:                lowest_active_reg = *(p1 + 1);
        -: 5626:            }
        -: 5627:
        -: 5628:          DEBUG_PRINT1 (":\n");
    #####: 5629:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
    #####: 5630:          break;
        -: 5631:
        -: 5632:
        -: 5633:        /* A smart repeat ends with `maybe_pop_jump'.
        -: 5634:	   We change it to either `pop_failure_jump' or `jump'.  */
        -: 5635:        case maybe_pop_jump:
    #####: 5636:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 5637:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
        -: 5638:          {
    #####: 5639:	    register unsigned char *p2 = p;
        -: 5640:
        -: 5641:            /* Compare the beginning of the repeat with what in the
        -: 5642:               pattern follows its end. If we can establish that there
        -: 5643:               is nothing that they would both match, i.e., that we
        -: 5644:               would have to backtrack because of (as in, e.g., `a*a')
        -: 5645:               then we can change to pop_failure_jump, because we'll
        -: 5646:               never have to backtrack.
        -: 5647:               
        -: 5648:               This is not true in the case of alternatives: in
        -: 5649:               `(a|ab)*' we do need to backtrack to the `ab' alternative
        -: 5650:               (e.g., if the string was `ab').  But instead of trying to
        -: 5651:               detect that here, the alternative has put on a dummy
        -: 5652:               failure point which is what we will end up popping.  */
        -: 5653:
        -: 5654:	    /* Skip over open/close-group commands.  */
    #####: 5655:	    while (p2 + 2 < pend
    #####: 5656:		   && ((re_opcode_t) *p2 == stop_memory
    #####: 5657:		       || (re_opcode_t) *p2 == start_memory))
    #####: 5658:	      p2 += 3;			/* Skip over args, too.  */
        -: 5659:
        -: 5660:            /* If we're at the end of the pattern, we can change.  */
    #####: 5661:            if (p2 == pend)
        -: 5662:	      {
        -: 5663:		/* Consider what happens when matching ":\(.*\)"
        -: 5664:		   against ":/".  I don't really understand this code
        -: 5665:		   yet.  */
    #####: 5666:  	        p[-3] = (unsigned char) pop_failure_jump;
        -: 5667:                DEBUG_PRINT1
        -: 5668:                  ("  End of pattern: change to `pop_failure_jump'.\n");
        -: 5669:              }
        -: 5670:
    #####: 5671:            else if ((re_opcode_t) *p2 == exactn
    #####: 5672:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
        -: 5673:	      {
    #####: 5674:		register unsigned char c
    #####: 5675:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
    #####: 5676:		p1 = p + mcnt;
        -: 5677:
        -: 5678:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
        -: 5679:                   to the `maybe_finalize_jump' of this case.  Examine what 
        -: 5680:                   follows.  */
    #####: 5681:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
        -: 5682:                  {
    #####: 5683:  		    p[-3] = (unsigned char) pop_failure_jump;
        -: 5684:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -: 5685:                                  c, p1[5]);
        -: 5686:                  }
        -: 5687:                  
    #####: 5688:		else if ((re_opcode_t) p1[3] == charset
    #####: 5689:			 || (re_opcode_t) p1[3] == charset_not)
        -: 5690:		  {
    #####: 5691:		    int not = (re_opcode_t) p1[3] == charset_not;
        -: 5692:                    
    #####: 5693:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
    #####: 5694:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
    #####: 5695:		      not = !not;
        -: 5696:
        -: 5697:                    /* `not' is equal to 1 if c would match, which means
        -: 5698:                        that we can't change to pop_failure_jump.  */
    #####: 5699:		    if (!not)
        -: 5700:                      {
    #####: 5701:  		        p[-3] = (unsigned char) pop_failure_jump;
        -: 5702:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -: 5703:                      }
        -: 5704:		  }
        -: 5705:	      }
        -: 5706:	  }
    #####: 5707:	  p -= 2;		/* Point at relative address again.  */
    #####: 5708:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
        -: 5709:	    {
    #####: 5710:	      p[-1] = (unsigned char) jump;
        -: 5711:              DEBUG_PRINT1 ("  Match => jump.\n");
    #####: 5712:	      goto unconditional_jump;
        -: 5713:	    }
        -: 5714:        /* Note fall through.  */
        -: 5715:
        -: 5716:
        -: 5717:	/* The end of a simple repeat has a pop_failure_jump back to
        -: 5718:           its matching on_failure_jump, where the latter will push a
        -: 5719:           failure point.  The pop_failure_jump takes off failure
        -: 5720:           points put on by this pop_failure_jump's matching
        -: 5721:           on_failure_jump; we got through the pattern to here from the
        -: 5722:           matching on_failure_jump, so didn't fail.  */
        -: 5723:        case pop_failure_jump:
        -: 5724:          {
        -: 5725:            /* We need to pass separate storage for the lowest and
        -: 5726:               highest registers, even though we don't care about the
        -: 5727:               actual values.  Otherwise, we will restore only one
        -: 5728:               register from the stack, since lowest will == highest in
        -: 5729:               `pop_failure_point'.  */
        -: 5730:            unsigned dummy_low_reg, dummy_high_reg;
        -: 5731:            unsigned char *pdummy;
        -: 5732:            const char *sdummy;
        -: 5733:
        -: 5734:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
    #####: 5735:            POP_FAILURE_POINT (sdummy, pdummy,
        -: 5736:                               dummy_low_reg, dummy_high_reg,
        -: 5737:                               reg_dummy, reg_dummy, reg_info_dummy);
        -: 5738:          }
        -: 5739:          /* Note fall through.  */
        -: 5740:
        -: 5741:          
        -: 5742:        /* Unconditionally jump (without popping any failure points).  */
        -: 5743:        case jump:
        -: 5744:	unconditional_jump:
    #####: 5745:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
        -: 5746:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
    #####: 5747:	  p += mcnt;				/* Do the jump.  */
        -: 5748:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
    #####: 5749:	  break;
        -: 5750:
        -: 5751:	
        -: 5752:        /* We need this opcode so we can detect where alternatives end
        -: 5753:           in `group_match_null_string_p' et al.  */
        -: 5754:        case jump_past_alt:
        -: 5755:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
    #####: 5756:          goto unconditional_jump;
        -: 5757:
        -: 5758:
        -: 5759:        /* Normally, the on_failure_jump pushes a failure point, which
        -: 5760:           then gets popped at pop_failure_jump.  We will end up at
        -: 5761:           pop_failure_jump, also, and with a pattern of, say, `a+', we
        -: 5762:           are skipping over the on_failure_jump, so we have to push
        -: 5763:           something meaningless for pop_failure_jump to pop.  */
        -: 5764:        case dummy_failure_jump:
        -: 5765:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
        -: 5766:          /* It doesn't matter what we push for the string here.  What
        -: 5767:             the code at `fail' tests is the value for the pattern.  */
    #####: 5768:          PUSH_FAILURE_POINT (0, 0, -2);
    #####: 5769:          goto unconditional_jump;
        -: 5770:
        -: 5771:
        -: 5772:        /* At the end of an alternative, we need to push a dummy failure
        -: 5773:           point in case we are followed by a `pop_failure_jump', because
        -: 5774:           we don't want the failure point for the alternative to be
        -: 5775:           popped.  For example, matching `(a|ab)*' against `aab'
        -: 5776:           requires that we match the `ab' alternative.  */
        -: 5777:        case push_dummy_failure:
        -: 5778:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
        -: 5779:          /* See comments just above at `dummy_failure_jump' about the
        -: 5780:             two zeroes.  */
    #####: 5781:          PUSH_FAILURE_POINT (0, 0, -2);
    #####: 5782:          break;
        -: 5783:
        -: 5784:        /* Have to succeed matching what follows at least n times.
        -: 5785:           After that, handle like `on_failure_jump'.  */
        -: 5786:        case succeed_n: 
    #####: 5787:          EXTRACT_NUMBER (mcnt, p + 2);
        -: 5788:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
        -: 5789:
        -: 5790:          assert (mcnt >= 0);
        -: 5791:          /* Originally, this is how many times we HAVE to succeed.  */
    #####: 5792:          if (mcnt > 0)
        -: 5793:            {
    #####: 5794:               mcnt--;
    #####: 5795:	       p += 2;
    #####: 5796:               STORE_NUMBER_AND_INCR (p, mcnt);
        -: 5797:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
        -: 5798:            }
    #####: 5799:	  else if (mcnt == 0)
        -: 5800:            {
        -: 5801:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
    #####: 5802:	      p[2] = (unsigned char) no_op;
    #####: 5803:              p[3] = (unsigned char) no_op;
    #####: 5804:              goto on_failure;
        -: 5805:            }
    #####: 5806:          break;
        -: 5807:        
        -: 5808:        case jump_n: 
    #####: 5809:          EXTRACT_NUMBER (mcnt, p + 2);
        -: 5810:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
        -: 5811:
        -: 5812:          /* Originally, this is how many times we CAN jump.  */
    #####: 5813:          if (mcnt)
        -: 5814:            {
    #####: 5815:               mcnt--;
    #####: 5816:               STORE_NUMBER (p + 2, mcnt);
    #####: 5817:	       goto unconditional_jump;	     
        -: 5818:            }
        -: 5819:          /* If don't have to jump any more, skip over the rest of command.  */
        -: 5820:	  else      
    #####: 5821:	    p += 4;		     
    #####: 5822:          break;
        -: 5823:        
        -: 5824:	case set_number_at:
        -: 5825:	  {
        -: 5826:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
        -: 5827:
    #####: 5828:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
    #####: 5829:            p1 = p + mcnt;
    #####: 5830:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -: 5831:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
    #####: 5832:	    STORE_NUMBER (p1, mcnt);
    #####: 5833:            break;
        -: 5834:          }
        -: 5835:
        -: 5836:        case wordbound:
        -: 5837:          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
    #####: 5838:          if (AT_WORD_BOUNDARY (d))
        -: 5839:	    break;
    #####: 5840:          goto fail;
        -: 5841:
        -: 5842:	case notwordbound:
        -: 5843:          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
    #####: 5844:	  if (AT_WORD_BOUNDARY (d))
        -: 5845:	    goto fail;
    #####: 5846:          break;
        -: 5847:
        -: 5848:	case wordbeg:
        -: 5849:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
    #####: 5850:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
        -: 5851:	    break;
    #####: 5852:          goto fail;
        -: 5853:
        -: 5854:	case wordend:
        -: 5855:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
    #####: 5856:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
    #####: 5857:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
        -: 5858:	    break;
    #####: 5859:          goto fail;
        -: 5860:
        -: 5861:#ifdef emacs
        -: 5862:#ifdef emacs19
        -: 5863:  	case before_dot:
        -: 5864:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
        -: 5865: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
        -: 5866:  	    goto fail;
        -: 5867:  	  break;
        -: 5868:  
        -: 5869:  	case at_dot:
        -: 5870:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -: 5871: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
        -: 5872:  	    goto fail;
        -: 5873:  	  break;
        -: 5874:  
        -: 5875:  	case after_dot:
        -: 5876:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
        -: 5877:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
        -: 5878:  	    goto fail;
        -: 5879:  	  break;
        -: 5880:#else /* not emacs19 */
        -: 5881:	case at_dot:
        -: 5882:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -: 5883:	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
        -: 5884:	    goto fail;
        -: 5885:	  break;
        -: 5886:#endif /* not emacs19 */
        -: 5887:
        -: 5888:	case syntaxspec:
        -: 5889:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
        -: 5890:	  mcnt = *p++;
        -: 5891:	  goto matchsyntax;
        -: 5892:
        -: 5893:        case wordchar:
        -: 5894:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
        -: 5895:	  mcnt = (int) Sword;
        -: 5896:        matchsyntax:
        -: 5897:	  PREFETCH ();
        -: 5898:	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
        -: 5899:            goto fail;
        -: 5900:          SET_REGS_MATCHED ();
        -: 5901:	  break;
        -: 5902:
        -: 5903:	case notsyntaxspec:
        -: 5904:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
        -: 5905:	  mcnt = *p++;
        -: 5906:	  goto matchnotsyntax;
        -: 5907:
        -: 5908:        case notwordchar:
        -: 5909:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
        -: 5910:	  mcnt = (int) Sword;
        -: 5911:        matchnotsyntax:
        -: 5912:	  PREFETCH ();
        -: 5913:	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
        -: 5914:            goto fail;
        -: 5915:	  SET_REGS_MATCHED ();
        -: 5916:          break;
        -: 5917:
        -: 5918:#else /* not emacs */
        -: 5919:	case wordchar:
        -: 5920:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
    #####: 5921:	  PREFETCH ();
    #####: 5922:          if (!WORDCHAR_P (d))
    #####: 5923:            goto fail;
    #####: 5924:	  SET_REGS_MATCHED ();
    #####: 5925:          d++;
    #####: 5926:	  break;
        -: 5927:	  
        -: 5928:	case notwordchar:
        -: 5929:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
    #####: 5930:	  PREFETCH ();
    #####: 5931:	  if (WORDCHAR_P (d))
    #####: 5932:            goto fail;
    #####: 5933:          SET_REGS_MATCHED ();
    #####: 5934:          d++;
    #####: 5935:	  break;
        -: 5936:#endif /* not emacs */
        -: 5937:          
        -: 5938:        default:
    #####: 5939:          abort ();
        -: 5940:	}
    #####: 5941:      continue;  /* Successfully executed one pattern command; keep going.  */
        -: 5942:
        -: 5943:
        -: 5944:    /* We goto here if a matching operation fails. */
        -: 5945:    fail:
    #####: 5946:      if (!FAIL_STACK_EMPTY ())
        -: 5947:	{ /* A restart point is known.  Restore to that state.  */
        -: 5948:          DEBUG_PRINT1 ("\nFAIL:\n");
    #####: 5949:          POP_FAILURE_POINT (d, p,
        -: 5950:                             lowest_active_reg, highest_active_reg,
        -: 5951:                             regstart, regend, reg_info);
        -: 5952:
        -: 5953:          /* If this failure point is a dummy, try the next one.  */
    #####: 5954:          if (!p)
    #####: 5955:	    goto fail;
        -: 5956:
        -: 5957:          /* If we failed to the end of the pattern, don't examine *p.  */
        -: 5958:	  assert (p <= pend);
    #####: 5959:          if (p < pend)
        -: 5960:            {
    #####: 5961:              boolean is_a_jump_n = false;
        -: 5962:              
        -: 5963:              /* If failed to a backwards jump that's part of a repetition
        -: 5964:                 loop, need to pop this failure point and use the next one.  */
    #####: 5965:              switch ((re_opcode_t) *p)
        -: 5966:                {
        -: 5967:                case jump_n:
    #####: 5968:                  is_a_jump_n = true;
        -: 5969:                case maybe_pop_jump:
        -: 5970:                case pop_failure_jump:
        -: 5971:                case jump:
    #####: 5972:                  p1 = p + 1;
    #####: 5973:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 5974:                  p1 += mcnt;	
        -: 5975:
    #####: 5976:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
    #####: 5977:                      || (!is_a_jump_n
    #####: 5978:                          && (re_opcode_t) *p1 == on_failure_jump))
        -: 5979:                    goto fail;
    #####: 5980:                  break;
        -: 5981:                default:
        -: 5982:                  /* do nothing */ ;
        -: 5983:                }
        -: 5984:            }
        -: 5985:
    #####: 5986:          if (d >= string1 && d <= end1)
    #####: 5987:	    dend = end_match_1;
        -: 5988:        }
        -: 5989:      else
    #####: 5990:        break;   /* Matching at this starting point really fails.  */
    #####: 5991:    } /* for (;;) */
        -: 5992:
    #####: 5993:  if (best_regs_set)
    #####: 5994:    goto restore_best_regs;
        -: 5995:
    #####: 5996:  FREE_VARIABLES ();
        -: 5997:
    #####: 5998:  return -1;         			/* Failure to match.  */
        -: 5999:} /* re_match_2 */
        -: 6000:
        -: 6001:/* Subroutine definitions for re_match_2.  */
        -: 6002:
        -: 6003:
        -: 6004:/* We are passed P pointing to a register number after a start_memory.
        -: 6005:   
        -: 6006:   Return true if the pattern up to the corresponding stop_memory can
        -: 6007:   match the empty string, and false otherwise.
        -: 6008:   
        -: 6009:   If we find the matching stop_memory, sets P to point to one past its number.
        -: 6010:   Otherwise, sets P to an undefined byte less than or equal to END.
        -: 6011:
        -: 6012:   We don't handle duplicates properly (yet).  */
        -: 6013:
        -: 6014:static boolean
    #####: 6015:group_match_null_string_p (p, end, reg_info)
        -: 6016:    unsigned char **p, *end;
        -: 6017:    register_info_type *reg_info;
        -: 6018:{
        -: 6019:  int mcnt;
        -: 6020:  /* Point to after the args to the start_memory.  */
    #####: 6021:  unsigned char *p1 = *p + 2;
        -: 6022:  
    #####: 6023:  while (p1 < end)
        -: 6024:    {
        -: 6025:      /* Skip over opcodes that can match nothing, and return true or
        -: 6026:	 false, as appropriate, when we get to one that can't, or to the
        -: 6027:         matching stop_memory.  */
        -: 6028:      
    #####: 6029:      switch ((re_opcode_t) *p1)
        -: 6030:        {
        -: 6031:        /* Could be either a loop or a series of alternatives.  */
        -: 6032:        case on_failure_jump:
    #####: 6033:          p1++;
    #####: 6034:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -: 6035:          
        -: 6036:          /* If the next operation is not a jump backwards in the
        -: 6037:	     pattern.  */
        -: 6038:
    #####: 6039:	  if (mcnt >= 0)
        -: 6040:	    {
        -: 6041:              /* Go through the on_failure_jumps of the alternatives,
        -: 6042:                 seeing if any of the alternatives cannot match nothing.
        -: 6043:                 The last alternative starts with only a jump,
        -: 6044:                 whereas the rest start with on_failure_jump and end
        -: 6045:                 with a jump, e.g., here is the pattern for `a|b|c':
        -: 6046:
        -: 6047:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
        -: 6048:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
        -: 6049:                 /exactn/1/c						
        -: 6050:
        -: 6051:                 So, we have to first go through the first (n-1)
        -: 6052:                 alternatives and then deal with the last one separately.  */
        -: 6053:
        -: 6054:
        -: 6055:              /* Deal with the first (n-1) alternatives, which start
        -: 6056:                 with an on_failure_jump (see above) that jumps to right
        -: 6057:                 past a jump_past_alt.  */
        -: 6058:
    #####: 6059:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
        -: 6060:                {
        -: 6061:                  /* `mcnt' holds how many bytes long the alternative
        -: 6062:                     is, including the ending `jump_past_alt' and
        -: 6063:                     its number.  */
        -: 6064:
    #####: 6065:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
        -: 6066:				                      reg_info))
    #####: 6067:                    return false;
        -: 6068:
        -: 6069:                  /* Move to right after this alternative, including the
        -: 6070:		     jump_past_alt.  */
    #####: 6071:                  p1 += mcnt;	
        -: 6072:
        -: 6073:                  /* Break if it's the beginning of an n-th alternative
        -: 6074:                     that doesn't begin with an on_failure_jump.  */
    #####: 6075:                  if ((re_opcode_t) *p1 != on_failure_jump)
    #####: 6076:                    break;
        -: 6077:		
        -: 6078:		  /* Still have to check that it's not an n-th
        -: 6079:		     alternative that starts with an on_failure_jump.  */
    #####: 6080:		  p1++;
    #####: 6081:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6082:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
        -: 6083:                    {
        -: 6084:		      /* Get to the beginning of the n-th alternative.  */
    #####: 6085:                      p1 -= 3;
    #####: 6086:                      break;
        -: 6087:                    }
        -: 6088:                }
        -: 6089:
        -: 6090:              /* Deal with the last alternative: go back and get number
        -: 6091:                 of the `jump_past_alt' just before it.  `mcnt' contains
        -: 6092:                 the length of the alternative.  */
    #####: 6093:              EXTRACT_NUMBER (mcnt, p1 - 2);
        -: 6094:
    #####: 6095:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
    #####: 6096:                return false;
        -: 6097:
    #####: 6098:              p1 += mcnt;	/* Get past the n-th alternative.  */
        -: 6099:            } /* if mcnt > 0 */
    #####: 6100:          break;
        -: 6101:
        -: 6102:          
        -: 6103:        case stop_memory:
        -: 6104:	  assert (p1[1] == **p);
    #####: 6105:          *p = p1 + 2;
    #####: 6106:          return true;
        -: 6107:
        -: 6108:        
        -: 6109:        default: 
    #####: 6110:          if (!common_op_match_null_string_p (&p1, end, reg_info))
    #####: 6111:            return false;
        -: 6112:        }
        -: 6113:    } /* while p1 < end */
        -: 6114:
    #####: 6115:  return false;
        -: 6116:} /* group_match_null_string_p */
        -: 6117:
        -: 6118:
        -: 6119:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
        -: 6120:   It expects P to be the first byte of a single alternative and END one
        -: 6121:   byte past the last. The alternative can contain groups.  */
        -: 6122:   
        -: 6123:static boolean
    #####: 6124:alt_match_null_string_p (p, end, reg_info)
        -: 6125:    unsigned char *p, *end;
        -: 6126:    register_info_type *reg_info;
        -: 6127:{
        -: 6128:  int mcnt;
    #####: 6129:  unsigned char *p1 = p;
        -: 6130:  
    #####: 6131:  while (p1 < end)
        -: 6132:    {
        -: 6133:      /* Skip over opcodes that can match nothing, and break when we get 
        -: 6134:         to one that can't.  */
        -: 6135:      
    #####: 6136:      switch ((re_opcode_t) *p1)
        -: 6137:        {
        -: 6138:	/* It's a loop.  */
        -: 6139:        case on_failure_jump:
    #####: 6140:          p1++;
    #####: 6141:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6142:          p1 += mcnt;
    #####: 6143:          break;
        -: 6144:          
        -: 6145:	default: 
    #####: 6146:          if (!common_op_match_null_string_p (&p1, end, reg_info))
    #####: 6147:            return false;
        -: 6148:        }
        -: 6149:    }  /* while p1 < end */
        -: 6150:
    #####: 6151:  return true;
        -: 6152:} /* alt_match_null_string_p */
        -: 6153:
        -: 6154:
        -: 6155:/* Deals with the ops common to group_match_null_string_p and
        -: 6156:   alt_match_null_string_p.  
        -: 6157:   
        -: 6158:   Sets P to one after the op and its arguments, if any.  */
        -: 6159:
        -: 6160:static boolean
    #####: 6161:common_op_match_null_string_p (p, end, reg_info)
        -: 6162:    unsigned char **p, *end;
        -: 6163:    register_info_type *reg_info;
        -: 6164:{
        -: 6165:  int mcnt;
        -: 6166:  boolean ret;
        -: 6167:  int reg_no;
    #####: 6168:  unsigned char *p1 = *p;
        -: 6169:
    #####: 6170:  switch ((re_opcode_t) *p1++)
        -: 6171:    {
        -: 6172:    case no_op:
        -: 6173:    case begline:
        -: 6174:    case endline:
        -: 6175:    case begbuf:
        -: 6176:    case endbuf:
        -: 6177:    case wordbeg:
        -: 6178:    case wordend:
        -: 6179:    case wordbound:
        -: 6180:    case notwordbound:
        -: 6181:#ifdef emacs
        -: 6182:    case before_dot:
        -: 6183:    case at_dot:
        -: 6184:    case after_dot:
        -: 6185:#endif
    #####: 6186:      break;
        -: 6187:
        -: 6188:    case start_memory:
    #####: 6189:      reg_no = *p1;
        -: 6190:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
    #####: 6191:      ret = group_match_null_string_p (&p1, end, reg_info);
        -: 6192:      
        -: 6193:      /* Have to set this here in case we're checking a group which
        -: 6194:         contains a group and a back reference to it.  */
        -: 6195:
    #####: 6196:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
    #####: 6197:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
        -: 6198:
    #####: 6199:      if (!ret)
    #####: 6200:        return false;
    #####: 6201:      break;
        -: 6202:          
        -: 6203:    /* If this is an optimized succeed_n for zero times, make the jump.  */
        -: 6204:    case jump:
    #####: 6205:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6206:      if (mcnt >= 0)
    #####: 6207:        p1 += mcnt;
        -: 6208:      else
    #####: 6209:        return false;
    #####: 6210:      break;
        -: 6211:
        -: 6212:    case succeed_n:
        -: 6213:      /* Get to the number of times to succeed.  */
    #####: 6214:      p1 += 2;		
    #####: 6215:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -: 6216:
    #####: 6217:      if (mcnt == 0)
        -: 6218:        {
    #####: 6219:          p1 -= 4;
    #####: 6220:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####: 6221:          p1 += mcnt;
        -: 6222:        }
        -: 6223:      else
    #####: 6224:        return false;
    #####: 6225:      break;
        -: 6226:
        -: 6227:    case duplicate: 
    #####: 6228:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
    #####: 6229:        return false;
    #####: 6230:      break;
        -: 6231:
        -: 6232:    case set_number_at:
    #####: 6233:      p1 += 4;
        -: 6234:
        -: 6235:    default:
        -: 6236:      /* All other opcodes mean we cannot match the empty string.  */
    #####: 6237:      return false;
        -: 6238:  }
        -: 6239:
    #####: 6240:  *p = p1;
    #####: 6241:  return true;
        -: 6242:} /* common_op_match_null_string_p */
        -: 6243:
        -: 6244:
        -: 6245:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
        -: 6246:   bytes; nonzero otherwise.  */
        -: 6247:   
        -: 6248:static int
    #####: 6249:bcmp_translate (s1, s2, len, translate)
        -: 6250:     unsigned char *s1, *s2;
        -: 6251:     register int len;
        -: 6252:     char *translate;
        -: 6253:{
    #####: 6254:  register unsigned char *p1 = s1, *p2 = s2;
    #####: 6255:  while (len)
        -: 6256:    {
    #####: 6257:      if (translate[*p1++] != translate[*p2++]) return 1;
    #####: 6258:      len--;
        -: 6259:    }
    #####: 6260:  return 0;
        -: 6261:}
        -: 6262:
        -: 6263:/* Entry points for GNU code.  */
        -: 6264:
        -: 6265:/* re_compile_pattern is the GNU regular expression compiler: it
        -: 6266:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
        -: 6267:   Returns 0 if the pattern was valid, otherwise an error string.
        -: 6268:   
        -: 6269:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
        -: 6270:   are set in BUFP on entry.
        -: 6271:   
        -: 6272:   We call regex_compile to do the actual compilation.  */
        -: 6273:
        -: 6274:const char *
    #####: 6275:re_compile_pattern (pattern, length, bufp)
        -: 6276:     const char *pattern;
        -: 6277:     int length;
        -: 6278:     struct re_pattern_buffer *bufp;
        -: 6279:{
        -: 6280:  reg_errcode_t ret;
        -: 6281:  
        -: 6282:  /* GNU code is written to assume at least RE_NREGS registers will be set
        -: 6283:     (and at least one extra will be -1).  */
    #####: 6284:  bufp->regs_allocated = REGS_UNALLOCATED;
        -: 6285:  
        -: 6286:  /* And GNU code determines whether or not to get register information
        -: 6287:     by passing null for the REGS argument to re_match, etc., not by
        -: 6288:     setting no_sub.  */
    #####: 6289:  bufp->no_sub = 0;
        -: 6290:  
        -: 6291:  /* Match anchors at newline.  */
    #####: 6292:  bufp->newline_anchor = 1;
        -: 6293:  
    #####: 6294:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
        -: 6295:
    #####: 6296:  return re_error_msg[(int) ret];
        -: 6297:}     
        -: 6298:
        -: 6299:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -: 6300:   them if this is an Emacs or POSIX compilation.  */
        -: 6301:
        -: 6302:#if !defined (emacs) && !defined (_POSIX_SOURCE)
        -: 6303:
        -: 6304:/* BSD has one and only one pattern buffer.  */
        -: 6305:static struct re_pattern_buffer re_comp_buf;
        -: 6306:
        -: 6307:char *
        -: 6308:re_comp (s)
        -: 6309:    const char *s;
        -: 6310:{
        -: 6311:  reg_errcode_t ret;
        -: 6312:  
        -: 6313:  if (!s)
        -: 6314:    {
        -: 6315:      if (!re_comp_buf.buffer)
        -: 6316:	return "No previous regular expression";
        -: 6317:      return 0;
        -: 6318:    }
        -: 6319:
        -: 6320:  if (!re_comp_buf.buffer)
        -: 6321:    {
        -: 6322:      re_comp_buf.buffer = (unsigned char *) malloc (200);
        -: 6323:      if (re_comp_buf.buffer == NULL)
        -: 6324:        return "Memory exhausted";
        -: 6325:      re_comp_buf.allocated = 200;
        -: 6326:
        -: 6327:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
        -: 6328:      if (re_comp_buf.fastmap == NULL)
        -: 6329:	return "Memory exhausted";
        -: 6330:    }
        -: 6331:
        -: 6332:  /* Since `re_exec' always passes NULL for the `regs' argument, we
        -: 6333:     don't need to initialize the pattern buffer fields which affect it.  */
        -: 6334:
        -: 6335:  /* Match anchors at newlines.  */
        -: 6336:  re_comp_buf.newline_anchor = 1;
        -: 6337:
        -: 6338:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
        -: 6339:  
        -: 6340:  /* Yes, we're discarding `const' here.  */
        -: 6341:  return (char *) re_error_msg[(int) ret];
        -: 6342:}
        -: 6343:
        -: 6344:
        -: 6345:int
        -: 6346:re_exec (s)
        -: 6347:    const char *s;
        -: 6348:{
        -: 6349:  const int len = strlen (s);
        -: 6350:  return
        -: 6351:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
        -: 6352:}
        -: 6353:#endif /* not emacs and not _POSIX_SOURCE */
        -: 6354:
        -: 6355:/* POSIX.2 functions.  Don't define these for Emacs.  */
        -: 6356:
        -: 6357:#ifndef emacs
        -: 6358:
        -: 6359:/* regcomp takes a regular expression as a string and compiles it.
        -: 6360:
        -: 6361:   PREG is a regex_t *.  We do not expect any fields to be initialized,
        -: 6362:   since POSIX says we shouldn't.  Thus, we set
        -: 6363:
        -: 6364:     `buffer' to the compiled pattern;
        -: 6365:     `used' to the length of the compiled pattern;
        -: 6366:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
        -: 6367:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
        -: 6368:       RE_SYNTAX_POSIX_BASIC;
        -: 6369:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
        -: 6370:     `fastmap' and `fastmap_accurate' to zero;
        -: 6371:     `re_nsub' to the number of subexpressions in PATTERN.
        -: 6372:
        -: 6373:   PATTERN is the address of the pattern string.
        -: 6374:
        -: 6375:   CFLAGS is a series of bits which affect compilation.
        -: 6376:
        -: 6377:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
        -: 6378:     use POSIX basic syntax.
        -: 6379:
        -: 6380:     If REG_NEWLINE is set, then . and [^...] don't match newline.
        -: 6381:     Also, regexec will try a match beginning after every newline.
        -: 6382:
        -: 6383:     If REG_ICASE is set, then we considers upper- and lowercase
        -: 6384:     versions of letters to be equivalent when matching.
        -: 6385:
        -: 6386:     If REG_NOSUB is set, then when PREG is passed to regexec, that
        -: 6387:     routine will report only success or failure, and nothing about the
        -: 6388:     registers.
        -: 6389:
        -: 6390:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
        -: 6391:   the return codes and their meanings.)  */
        -: 6392:
        -: 6393:int
    #####: 6394:regcomp (preg, pattern, cflags)
        -: 6395:    regex_t *preg;
        -: 6396:    const char *pattern; 
        -: 6397:    int cflags;
        -: 6398:{
        -: 6399:  reg_errcode_t ret;
    #####: 6400:  unsigned syntax
    #####: 6401:    = (cflags & REG_EXTENDED) ?
        -: 6402:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
        -: 6403:
        -: 6404:  /* regex_compile will allocate the space for the compiled pattern.  */
    #####: 6405:  preg->buffer = 0;
    #####: 6406:  preg->allocated = 0;
    #####: 6407:  preg->used = 0;
        -: 6408:  
        -: 6409:  /* Don't bother to use a fastmap when searching.  This simplifies the
        -: 6410:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
        -: 6411:     characters after newlines into the fastmap.  This way, we just try
        -: 6412:     every character.  */
    #####: 6413:  preg->fastmap = 0;
        -: 6414:  
    #####: 6415:  if (cflags & REG_ICASE)
        -: 6416:    {
        -: 6417:      unsigned i;
        -: 6418:      
    #####: 6419:      preg->translate = (char *) malloc (CHAR_SET_SIZE);
    #####: 6420:      if (preg->translate == NULL)
    #####: 6421:        return (int) REG_ESPACE;
        -: 6422:
        -: 6423:      /* Map uppercase characters to corresponding lowercase ones.  */
    #####: 6424:      for (i = 0; i < CHAR_SET_SIZE; i++)
    #####: 6425:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
        -: 6426:    }
        -: 6427:  else
    #####: 6428:    preg->translate = NULL;
        -: 6429:
        -: 6430:  /* If REG_NEWLINE is set, newlines are treated differently.  */
    #####: 6431:  if (cflags & REG_NEWLINE)
        -: 6432:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####: 6433:      syntax &= ~RE_DOT_NEWLINE;
    #####: 6434:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -: 6435:      /* It also changes the matching behavior.  */
    #####: 6436:      preg->newline_anchor = 1;
        -: 6437:    }
        -: 6438:  else
    #####: 6439:    preg->newline_anchor = 0;
        -: 6440:
    #####: 6441:  preg->no_sub = !!(cflags & REG_NOSUB);
        -: 6442:
        -: 6443:  /* POSIX says a null character in the pattern terminates it, so we 
        -: 6444:     can use strlen here in compiling the pattern.  */
    #####: 6445:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
        -: 6446:  
        -: 6447:  /* POSIX doesn't distinguish between an unmatched open-group and an
        -: 6448:     unmatched close-group: both are REG_EPAREN.  */
    #####: 6449:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
        -: 6450:  
    #####: 6451:  return (int) ret;
        -: 6452:}
        -: 6453:
        -: 6454:
        -: 6455:/* regexec searches for a given pattern, specified by PREG, in the
        -: 6456:   string STRING.
        -: 6457:   
        -: 6458:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -: 6459:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -: 6460:   least NMATCH elements, and we set them to the offsets of the
        -: 6461:   corresponding matched substrings.
        -: 6462:   
        -: 6463:   EFLAGS specifies `execution flags' which affect matching: if
        -: 6464:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -: 6465:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -: 6466:   
        -: 6467:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -: 6468:
        -: 6469:int
    #####: 6470:regexec (preg, string, nmatch, pmatch, eflags)
        -: 6471:    const regex_t *preg;
        -: 6472:    const char *string; 
        -: 6473:    size_t nmatch; 
        -: 6474:    regmatch_t pmatch[]; 
        -: 6475:    int eflags;
        -: 6476:{
        -: 6477:  int ret;
        -: 6478:  struct re_registers regs;
        -: 6479:  regex_t private_preg;
    #####: 6480:  int len = strlen (string);
    #####: 6481:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
        -: 6482:
    #####: 6483:  private_preg = *preg;
        -: 6484:  
    #####: 6485:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
    #####: 6486:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
        -: 6487:  
        -: 6488:  /* The user has told us exactly how many registers to return
        -: 6489:     information about, via `nmatch'.  We have to pass that on to the
        -: 6490:     matching routines.  */
    #####: 6491:  private_preg.regs_allocated = REGS_FIXED;
        -: 6492:  
    #####: 6493:  if (want_reg_info)
        -: 6494:    {
    #####: 6495:      regs.num_regs = nmatch;
    #####: 6496:      regs.start = TALLOC (nmatch, regoff_t);
    #####: 6497:      regs.end = TALLOC (nmatch, regoff_t);
    #####: 6498:      if (regs.start == NULL || regs.end == NULL)
    #####: 6499:        return (int) REG_NOMATCH;
        -: 6500:    }
        -: 6501:
        -: 6502:  /* Perform the searching operation.  */
    #####: 6503:  ret = re_search (&private_preg, string, len,
        -: 6504:                   /* start: */ 0, /* range: */ len,
        -: 6505:                   want_reg_info ? &regs : (struct re_registers *) 0);
        -: 6506:  
        -: 6507:  /* Copy the register information to the POSIX structure.  */
    #####: 6508:  if (want_reg_info)
        -: 6509:    {
    #####: 6510:      if (ret >= 0)
        -: 6511:        {
        -: 6512:          unsigned r;
        -: 6513:
    #####: 6514:          for (r = 0; r < nmatch; r++)
        -: 6515:            {
    #####: 6516:              pmatch[r].rm_so = regs.start[r];
    #####: 6517:              pmatch[r].rm_eo = regs.end[r];
        -: 6518:            }
        -: 6519:        }
        -: 6520:
        -: 6521:      /* If we needed the temporary register info, free the space now.  */
    #####: 6522:      free (regs.start);
    #####: 6523:      free (regs.end);
        -: 6524:    }
        -: 6525:
        -: 6526:  /* We want zero return to mean success, unlike `re_search'.  */
    #####: 6527:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
        -: 6528:}
        -: 6529:
        -: 6530:
        -: 6531:/* Returns a message corresponding to an error code, ERRCODE, returned
        -: 6532:   from either regcomp or regexec.   We don't use PREG here.  */
        -: 6533:
        -: 6534:size_t
    #####: 6535:regerror (errcode, preg, errbuf, errbuf_size)
        -: 6536:    int errcode;
        -: 6537:    const regex_t *preg;
        -: 6538:    char *errbuf;
        -: 6539:    size_t errbuf_size;
        -: 6540:{
        -: 6541:  const char *msg;
        -: 6542:  size_t msg_size;
        -: 6543:
    #####: 6544:  if (errcode < 0
    #####: 6545:      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
        -: 6546:    /* Only error codes returned by the rest of the code should be passed 
        -: 6547:       to this routine.  If we are given anything else, or if other regex
        -: 6548:       code generates an invalid error code, then the program has a bug.
        -: 6549:       Dump core so we can fix it.  */
    #####: 6550:    abort ();
        -: 6551:
    #####: 6552:  msg = re_error_msg[errcode];
        -: 6553:
        -: 6554:  /* POSIX doesn't require that we do anything in this case, but why
        -: 6555:     not be nice.  */
    #####: 6556:  if (! msg)
    #####: 6557:    msg = "Success";
        -: 6558:
    #####: 6559:  msg_size = strlen (msg) + 1; /* Includes the null.  */
        -: 6560:  
    #####: 6561:  if (errbuf_size != 0)
        -: 6562:    {
    #####: 6563:      if (msg_size > errbuf_size)
        -: 6564:        {
    #####: 6565:          strncpy (errbuf, msg, errbuf_size - 1);
    #####: 6566:          errbuf[errbuf_size - 1] = 0;
        -: 6567:        }
        -: 6568:      else
    #####: 6569:        strcpy (errbuf, msg);
        -: 6570:    }
        -: 6571:
    #####: 6572:  return msg_size;
        -: 6573:}
        -: 6574:
        -: 6575:
        -: 6576:/* Free dynamically allocated space used by PREG.  */
        -: 6577:
        -: 6578:void
    #####: 6579:regfree (preg)
        -: 6580:    regex_t *preg;
        -: 6581:{
    #####: 6582:  if (preg->buffer != NULL)
    #####: 6583:    free (preg->buffer);
    #####: 6584:  preg->buffer = NULL;
        -: 6585:  
    #####: 6586:  preg->allocated = 0;
    #####: 6587:  preg->used = 0;
        -: 6588:
    #####: 6589:  if (preg->fastmap != NULL)
    #####: 6590:    free (preg->fastmap);
    #####: 6591:  preg->fastmap = NULL;
    #####: 6592:  preg->fastmap_accurate = 0;
        -: 6593:
    #####: 6594:  if (preg->translate != NULL)
    #####: 6595:    free (preg->translate);
    #####: 6596:  preg->translate = NULL;
    #####: 6597:}
        -: 6598:
        -: 6599:#endif /* not emacs  */
        -: 6600:
        -: 6601:/*
        -: 6602:Local variables:
        -: 6603:make-backup-files: t
        -: 6604:version-control: t
        -: 6605:trim-versions-without-asking: nil
        -: 6606:End:
        -: 6607:*/
        -: 6608:/* dfa.c - deterministic extended regexp routines for GNU
        -: 6609:   Copyright (C) 1988 Free Software Foundation, Inc.
        -: 6610:
        -: 6611:   This program is free software; you can redistribute it and/or modify
        -: 6612:   it under the terms of the GNU General Public License as published by
        -: 6613:   the Free Software Foundation; either version 2, or (at your option)
        -: 6614:   any later version.
        -: 6615:
        -: 6616:   This program is distributed in the hope that it will be useful,
        -: 6617:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6618:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6619:   GNU General Public License for more details.
        -: 6620:
        -: 6621:   You should have received a copy of the GNU General Public License
        -: 6622:   along with this program; if not, write to the Free Software
        -: 6623:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 6624:
        -: 6625:/* Written June, 1988 by Mike Haertel
        -: 6626:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
        -: 6627:
        -: 6628:/*#include <assert.h> */
        -: 6629:/*#include <ctype.h> */
        -: 6630:/*#include <stdio.h> */
        -: 6631:
        -: 6632:#ifdef STDC_HEADERS
        -: 6633:#if flag_stdlib==0
        -: 6634:#include <stdlib.h>
        -: 6635:#define flag_stdlib 1
        -: 6636:#endif
        -: 6637:#else
        -: 6638:#if flag_systypes==0 
        -: 6639:#include <sys/types.h>
        -: 6640:#define flag_systypes 1
        -: 6641:#endif
        -: 6642:extern char *calloc(), *malloc(), *realloc();
        -: 6643:extern void free();
        -: 6644:#endif
        -: 6645:
        -: 6646:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
        -: 6647:#if flag_string==0
        -: 6648:#include <string.h>
        -: 6649:#define flag_string 1
        -: 6650:#endif
        -: 6651:#undef index
        -: 6652:#define index strchr
        -: 6653:#else
        -: 6654:#if flag_strings==0
        -: 6655:#include <strings.h>
        -: 6656:#define flag_strings 1
        -: 6657:#endif
        -: 6658:#endif
        -: 6659:
        -: 6660:#ifndef isgraph
        -: 6661:#define isgraph(C) (isprint(C) && !isspace(C))
        -: 6662:#endif
        -: 6663:
        -: 6664:#undef ISALPHA
        -: 6665:#undef ISUPPER
        -: 6666:#undef ISLOWER
        -: 6667:#undef ISDIGIT
        -: 6668:#undef ISXDIGIT
        -: 6669:#undef ISSPACE
        -: 6670:#undef ISPUNCT
        -: 6671:#undef ISALNUM
        -: 6672:#undef ISPRINT
        -: 6673:#undef ISGRAPH
        -: 6674:#undef ISCNTRL
        -: 6675:
        -: 6676:
        -: 6677:#ifdef isascii
        -: 6678:#define ISALPHA(C) (isascii(C) && isalpha(C))
        -: 6679:#define ISUPPER(C) (isascii(C) && isupper(C))
        -: 6680:#define ISLOWER(C) (isascii(C) && islower(C))
        -: 6681:#define ISDIGIT(C) (isascii(C) && isdigit(C))
        -: 6682:#define ISXDIGIT(C) (isascii(C) && isxdigit(C))
        -: 6683:#define ISSPACE(C) (isascii(C) && isspace(C))
        -: 6684:#define ISPUNCT(C) (isascii(C) && ispunct(C))
        -: 6685:#define ISALNUM(C) (isascii(C) && isalnum(C))
        -: 6686:#define ISPRINT(C) (isascii(C) && isprint(C))
        -: 6687:#define ISGRAPH(C) (isascii(C) && isgraph(C))
        -: 6688:#define ISCNTRL(C) (isascii(C) && iscntrl(C))
        -: 6689:#else
        -: 6690:#define ISALPHA(C) isalpha(C)
        -: 6691:#define ISUPPER(C) isupper(C)
        -: 6692:#define ISLOWER(C) islower(C)
        -: 6693:#define ISDIGIT(C) isdigit(C)
        -: 6694:#define ISXDIGIT(C) isxdigit(C)
        -: 6695:#define ISSPACE(C) isspace(C)
        -: 6696:#define ISPUNCT(C) ispunct(C)
        -: 6697:#define ISALNUM(C) isalnum(C)
        -: 6698:#define ISPRINT(C) isprint(C)
        -: 6699:#define ISGRAPH(C) isgraph(C)
        -: 6700:#define ISCNTRL(C) iscntrl(C)
        -: 6701:#endif
        -: 6702:
        -: 6703:#include "dfa.h"
        -: 6704:/*#include "regex.h"*/
        -: 6705:
        -: 6706:#if __STDC__
        -: 6707:typedef void *ptr_t;
        -: 6708:#else
        -: 6709:typedef char *ptr_t;
        -: 6710:#endif
        -: 6711:
        -: 6712:static void	dfamust();
        -: 6713:
        -: 6714:static ptr_t
    #####: 6715:xcalloc(n, s)
        -: 6716:     int n;
        -: 6717:     size_t s;
        -: 6718:{
    #####: 6719:  ptr_t r = calloc(n, s);
        -: 6720:
    #####: 6721:  if (!r)
    #####: 6722:    dfaerror("Memory exhausted");
    #####: 6723:  return r;
        -: 6724:}
        -: 6725:
        -: 6726:static ptr_t
    #####: 6727:xmalloc_1(n)
        -: 6728:     size_t n;
        -: 6729:{
    #####: 6730:  ptr_t r = malloc(n);
        -: 6731:
        -: 6732:  assert(n != 0);
    #####: 6733:  if (!r)
    #####: 6734:    dfaerror("Memory exhausted");
    #####: 6735:  return r;
        -: 6736:}
        -: 6737:
        -: 6738:static ptr_t
    #####: 6739:xrealloc_1(p, n)
        -: 6740:     ptr_t p;
        -: 6741:     size_t n;
        -: 6742:{
    #####: 6743:  ptr_t r = realloc(p, n);
        -: 6744:
        -: 6745:  assert(n != 0);
    #####: 6746:  if (!r)
    #####: 6747:    dfaerror("Memory exhausted");
    #####: 6748:  return r;
        -: 6749:}
        -: 6750:
        -: 6751:#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
        -: 6752:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
        -: 6753:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
        -: 6754:
        -: 6755:/* Reallocate an array of type t if nalloc is too small for index. */
        -: 6756:#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
        -: 6757:  if ((index) >= (nalloc))			  \
        -: 6758:    {						  \
        -: 6759:      while ((index) >= (nalloc))		  \
        -: 6760:	(nalloc) *= 2;				  \
        -: 6761:      REALLOC(p, t, nalloc);			  \
        -: 6762:    }
        -: 6763:
        -: 6764:#ifdef DEBUG
        -: 6765:
        -: 6766:static void
        -: 6767:prtok(t)
        -: 6768:     token t;
        -: 6769:{
        -: 6770:  char *s;
        -: 6771:
        -: 6772:  if (t < 0)
        -: 6773:    fprintf(stderr, "END");
        -: 6774:  else if (t < NOTCHAR)
        -: 6775:    fprintf(stderr, "%c", t);
        -: 6776:  else
        -: 6777:    {
        -: 6778:      switch (t)
        -: 6779:	{
        -: 6780:	case EMPTY: s = "EMPTY"; break;
        -: 6781:	case BACKREF: s = "BACKREF"; break;
        -: 6782:	case BEGLINE: s = "BEGLINE"; break;
        -: 6783:	case ENDLINE: s = "ENDLINE"; break;
        -: 6784:	case BEGWORD: s = "BEGWORD"; break;
        -: 6785:	case ENDWORD: s = "ENDWORD"; break;
        -: 6786:	case LIMWORD: s = "LIMWORD"; break;
        -: 6787:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
        -: 6788:	case QMARK: s = "QMARK"; break;
        -: 6789:	case STAR: s = "STAR"; break;
        -: 6790:	case PLUS: s = "PLUS"; break;
        -: 6791:	case CAT: s = "CAT"; break;
        -: 6792:	case OR: s = "OR"; break;
        -: 6793:	case ORTOP: s = "ORTOP"; break;
        -: 6794:	case LPAREN: s = "LPAREN"; break;
        -: 6795:	case RPAREN: s = "RPAREN"; break;
        -: 6796:	default: s = "CSET"; break;
        -: 6797:	}
        -: 6798:      fprintf(stderr, "%s", s);
        -: 6799:    }
        -: 6800:}
        -: 6801:#endif /* DEBUG */
        -: 6802:
        -: 6803:/* Stuff pertaining to charclasses. */
        -: 6804:
        -: 6805:static int
    #####: 6806:tstbit(b, c)
        -: 6807:     int b;
        -: 6808:     charclass c;
        -: 6809:{
    #####: 6810:  return c[b / INTBITS] & 1 << b % INTBITS;
        -: 6811:}
        -: 6812:
        -: 6813:static void
    #####: 6814:setbit(b, c)
        -: 6815:     int b;
        -: 6816:     charclass c;
        -: 6817:{
    #####: 6818:  c[b / INTBITS] |= 1 << b % INTBITS;
    #####: 6819:}
        -: 6820:
        -: 6821:static void
    #####: 6822:clrbit(b, c)
        -: 6823:     int b;
        -: 6824:     charclass c;
        -: 6825:{
    #####: 6826:  c[b / INTBITS] &= ~(1 << b % INTBITS);
    #####: 6827:}
        -: 6828:
        -: 6829:static void
    #####: 6830:copyset(src, dst)
        -: 6831:     charclass src;
        -: 6832:     charclass dst;
        -: 6833:{
        -: 6834:  int i;
        -: 6835:
    #####: 6836:  for (i = 0; i < CHARCLASS_INTS; ++i)
    #####: 6837:    dst[i] = src[i];
    #####: 6838:}
        -: 6839:
        -: 6840:static void
    #####: 6841:zeroset(s)
        -: 6842:     charclass s;
        -: 6843:{
        -: 6844:  int i;
        -: 6845:
    #####: 6846:  for (i = 0; i < CHARCLASS_INTS; ++i)
    #####: 6847:    s[i] = 0;
    #####: 6848:}
        -: 6849:
        -: 6850:static void
    #####: 6851:notset(s)
        -: 6852:     charclass s;
        -: 6853:{
        -: 6854:  int i;
        -: 6855:
    #####: 6856:  for (i = 0; i < CHARCLASS_INTS; ++i)
    #####: 6857:    s[i] = ~s[i];
    #####: 6858:}
        -: 6859:
        -: 6860:static int
    #####: 6861:equal(s1, s2)
        -: 6862:     charclass s1;
        -: 6863:     charclass s2;
        -: 6864:{
        -: 6865:  int i;
        -: 6866:
    #####: 6867:  for (i = 0; i < CHARCLASS_INTS; ++i)
    #####: 6868:    if (s1[i] != s2[i])
    #####: 6869:      return 0;
    #####: 6870:  return 1;
        -: 6871:}
        -: 6872:
        -: 6873:/* A pointer to the current dfa is kept here during parsing. */
        -: 6874:static struct dfa *dfa;
        -: 6875:
        -: 6876:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
        -: 6877:static int
    #####: 6878:charclass_index(s)
        -: 6879:     charclass s;
        -: 6880:{
        -: 6881:  int i;
        -: 6882:
    #####: 6883:  for (i = 0; i < dfa->cindex; ++i)
    #####: 6884:    if (equal(s, dfa->charclasses[i]))
    #####: 6885:      return i;
    #####: 6886:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
    #####: 6887:  ++dfa->cindex;
    #####: 6888:  copyset(s, dfa->charclasses[i]);
    #####: 6889:  return i;
        -: 6890:}
        -: 6891:
        -: 6892:/* Syntax bits controlling the behavior of the lexical analyzer. */
        -: 6893:static int syntax_bits, syntax_bits_set;
        -: 6894:
        -: 6895:/* Flag for case-folding letters into sets. */
        -: 6896:static int case_fold;
        -: 6897:
        -: 6898:/* Entry point to set syntax options. */
        -: 6899:void
    #####: 6900:dfasyntax(bits, fold)
        -: 6901:     int bits;
        -: 6902:     int fold;
        -: 6903:{
    #####: 6904:  syntax_bits_set = 1;
    #####: 6905:  syntax_bits = bits;
    #####: 6906:  case_fold = fold;
    #####: 6907:}
        -: 6908:
        -: 6909:/* Lexical analyzer.  All the dross that deals with the obnoxious
        -: 6910:   GNU Regex syntax bits is located here.  The poor, suffering
        -: 6911:   reader is referred to the GNU Regex documentation for the
        -: 6912:   meaning of the @#%!@#%^!@ syntax bits. */
        -: 6913:
        -: 6914:static char *lexstart;		/* Pointer to beginning of input string. */
        -: 6915:static char *lexptr;		/* Pointer to next input character. */
        -: 6916:static lexleft;			/* Number of characters remaining. */
        -: 6917:static token lasttok;		/* Previous token returned; initially END. */
        -: 6918:static int laststart;		/* True if we're separated from beginning or (, |
        -: 6919:				   only by zero-width characters. */
        -: 6920:static int parens;		/* Count of outstanding left parens. */
        -: 6921:static int minrep, maxrep;	/* Repeat counts for {m,n}. */
        -: 6922:
        -: 6923:/* Note that characters become unsigned here. */
        -: 6924:#define FETCH(c, eoferr)   	      \
        -: 6925:  {			   	      \
        -: 6926:    if (! lexleft)	   	      \
        -: 6927:      if (eoferr != 0)	   	      \
        -: 6928:	dfaerror(eoferr);  	      \
        -: 6929:      else		   	      \
        -: 6930:	return END;	   	      \
        -: 6931:    (c) = (unsigned char) *lexptr++;  \
        -: 6932:    --lexleft;		   	      \
        -: 6933:  }
        -: 6934:
        -: 6935:#define FUNC(F, P) static int F(c) int c; { return P(c); }
        -: 6936:
    #####: 6937:FUNC(is_alpha, ISALPHA)
    #####: 6938:FUNC(is_upper, ISUPPER)
    #####: 6939:FUNC(is_lower, ISLOWER)
    #####: 6940:FUNC(is_digit, ISDIGIT)
    #####: 6941:FUNC(is_xdigit, ISXDIGIT)
    #####: 6942:FUNC(is_space, ISSPACE)
    #####: 6943:FUNC(is_punct, ISPUNCT)
    #####: 6944:FUNC(is_alnum, ISALNUM)
    #####: 6945:FUNC(is_print, ISPRINT)
    #####: 6946:FUNC(is_graph, ISGRAPH)
    #####: 6947:FUNC(is_cntrl, ISCNTRL)
        -: 6948:
        -: 6949:/* The following list maps the names of the Posix named character classes
        -: 6950:   to predicate functions that determine whether a given character is in
        -: 6951:   the class.  The leading [ has already been eaten by the lexical analyzer. */
        -: 6952:static struct {
        -: 6953:  char *name;
        -: 6954:  int (*pred)();
        -: 6955:} prednames[] = {
        -: 6956:  ":alpha:]", is_alpha,
        -: 6957:  ":upper:]", is_upper,
        -: 6958:  ":lower:]", is_lower,
        -: 6959:  ":digit:]", is_digit,
        -: 6960:  ":xdigit:]", is_xdigit,
        -: 6961:  ":space:]", is_space,
        -: 6962:  ":punct:]", is_punct,
        -: 6963:  ":alnum:]", is_alnum,
        -: 6964:  ":print:]", is_print,
        -: 6965:  ":graph:]", is_graph,
        -: 6966:  ":cntrl:]", is_cntrl,
        -: 6967:  0
        -: 6968:};
        -: 6969:
        -: 6970:static int
    #####: 6971:looking_at(s)
        -: 6972:     char *s;
        -: 6973:{
        -: 6974:  int len;
        -: 6975:
    #####: 6976:  len = strlen(s);
    #####: 6977:  if (lexleft < len)
    #####: 6978:    return 0;
    #####: 6979:  return strncmp(s, lexptr, len) == 0;
        -: 6980:}
        -: 6981:
        -: 6982:static token
    #####: 6983:lex()
        -: 6984:{
        -: 6985:  token c, c1, c2;
    #####: 6986:  int backslash = 0, invert;
        -: 6987:  charclass ccl;
        -: 6988:  int i;
        -: 6989:
        -: 6990:  /* Basic plan: We fetch a character.  If it's a backslash,
        -: 6991:     we set the backslash flag and go through the loop again.
        -: 6992:     On the plus side, this avoids having a duplicate of the
        -: 6993:     main switch inside the backslash case.  On the minus side,
        -: 6994:     it means that just about every case begins with
        -: 6995:     "if (backslash) ...".  */
    #####: 6996:  for (i = 0; i < 2; ++i)
        -: 6997:    {
    #####: 6998:      FETCH(c, 0);
    #####: 6999:      switch (c)
        -: 7000:	{
        -: 7001:	case '\\':
    #####: 7002:	  if (backslash)
    #####: 7003:	    goto normal_char;
    #####: 7004:	  if (lexleft == 0)
    #####: 7005:	    dfaerror("Unfinished \\ escape");
    #####: 7006:	  backslash = 1;
    #####: 7007:	  break;
        -: 7008:
        -: 7009:	case '^':
    #####: 7010:	  if (backslash)
    #####: 7011:	    goto normal_char;
    #####: 7012:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
    #####: 7013:	      || lasttok == END
    #####: 7014:	      || lasttok == LPAREN
    #####: 7015:	      || lasttok == OR)
    #####: 7016:	    return lasttok = BEGLINE;
    #####: 7017:	  goto normal_char;
        -: 7018:
        -: 7019:	case '$':
    #####: 7020:	  if (backslash)
    #####: 7021:	    goto normal_char;
    #####: 7022:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
    #####: 7023:	      || lexleft == 0
    #####: 7024:	      || (syntax_bits & RE_NO_BK_PARENS
    #####: 7025:		  ? lexleft > 0 && *lexptr == ')'
    #####: 7026:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
    #####: 7027:	      || (syntax_bits & RE_NO_BK_VBAR
    #####: 7028:		  ? lexleft > 0 && *lexptr == '|'
    #####: 7029:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
    #####: 7030:	      || ((syntax_bits & RE_NEWLINE_ALT)
    #####: 7031:	          && lexleft > 0 && *lexptr == '\n'))
    #####: 7032:	    return lasttok = ENDLINE;
    #####: 7033:	  goto normal_char;
        -: 7034:
        -: 7035:	case '1':
        -: 7036:	case '2':
        -: 7037:	case '3':
        -: 7038:	case '4':
        -: 7039:	case '5':
        -: 7040:	case '6':
        -: 7041:	case '7':
        -: 7042:	case '8':
        -: 7043:	case '9':
    #####: 7044:	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
        -: 7045:	    {
    #####: 7046:	      laststart = 0;
    #####: 7047:	      return lasttok = BACKREF;
        -: 7048:	    }
    #####: 7049:	  goto normal_char;
        -: 7050:
        -: 7051:	case '<':
    #####: 7052:	  if (backslash)
    #####: 7053:	    return lasttok = BEGWORD;
    #####: 7054:	  goto normal_char;
        -: 7055:
        -: 7056:	case '>':
    #####: 7057:	  if (backslash)
    #####: 7058:	    return lasttok = ENDWORD;
    #####: 7059:	  goto normal_char;
        -: 7060:
        -: 7061:	case 'b':
    #####: 7062:	  if (backslash)
    #####: 7063:	    return lasttok = LIMWORD;
    #####: 7064:	  goto normal_char;
        -: 7065:
        -: 7066:	case 'B':
    #####: 7067:	  if (backslash)
    #####: 7068:	    return lasttok = NOTLIMWORD;
    #####: 7069:	  goto normal_char;
        -: 7070:
        -: 7071:	case '?':
    #####: 7072:	  if (syntax_bits & RE_LIMITED_OPS)
    #####: 7073:	    goto normal_char;
    #####: 7074:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
    #####: 7075:	    goto normal_char;
    #####: 7076:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
    #####: 7077:	    goto normal_char;
    #####: 7078:	  return lasttok = QMARK;
        -: 7079:
        -: 7080:	case '*':
    #####: 7081:	  if (backslash)
    #####: 7082:	    goto normal_char;
    #####: 7083:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
    #####: 7084:	    goto normal_char;
    #####: 7085:	  return lasttok = STAR;
        -: 7086:
        -: 7087:	case '+':
    #####: 7088:	  if (syntax_bits & RE_LIMITED_OPS)
    #####: 7089:	    goto normal_char;
    #####: 7090:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
    #####: 7091:	    goto normal_char;
    #####: 7092:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
    #####: 7093:	    goto normal_char;
    #####: 7094:	  return lasttok = PLUS;
        -: 7095:
        -: 7096:	case '{':
    #####: 7097:	  if (!(syntax_bits & RE_INTERVALS))
    #####: 7098:	    goto normal_char;
    #####: 7099:	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
    #####: 7100:	    goto normal_char;
    #####: 7101:	  minrep = maxrep = 0;
        -: 7102:	  /* Cases:
        -: 7103:	     {M} - exact count
        -: 7104:	     {M,} - minimum count, maximum is infinity
        -: 7105:	     {,M} - 0 through M
        -: 7106:	     {M,N} - M through N */
    #####: 7107:	  FETCH(c, "unfinished repeat count");
    #####: 7108:	  if (ISDIGIT(c))
        -: 7109:	    {
    #####: 7110:	      minrep = c - '0';
        -: 7111:	      for (;;)
        -: 7112:		{
    #####: 7113:		  FETCH(c, "unfinished repeat count");
    #####: 7114:		  if (!ISDIGIT(c))
    #####: 7115:		    break;
    #####: 7116:		  minrep = 10 * minrep + c - '0';
    #####: 7117:		}
        -: 7118:	    }
    #####: 7119:	  else if (c != ',')
    #####: 7120:	    dfaerror("malformed repeat count");
    #####: 7121:	  if (c == ',')
        -: 7122:	    for (;;)
        -: 7123:	      {
    #####: 7124:		FETCH(c, "unfinished repeat count");
    #####: 7125:		if (!ISDIGIT(c))
    #####: 7126:		  break;
    #####: 7127:		maxrep = 10 * maxrep + c - '0';
    #####: 7128:	      }
        -: 7129:	  else
    #####: 7130:	    maxrep = minrep;
    #####: 7131:	  if (!(syntax_bits & RE_NO_BK_BRACES))
        -: 7132:	    {
    #####: 7133:	      if (c != '\\')
    #####: 7134:		dfaerror("malformed repeat count");
    #####: 7135:	      FETCH(c, "unfinished repeat count");
        -: 7136:	    }
    #####: 7137:	  if (c != '}')
    #####: 7138:	    dfaerror("malformed repeat count");
    #####: 7139:	  laststart = 0;
    #####: 7140:	  return lasttok = REPMN;
        -: 7141:
        -: 7142:	case '|':
    #####: 7143:	  if (syntax_bits & RE_LIMITED_OPS)
    #####: 7144:	    goto normal_char;
    #####: 7145:	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
    #####: 7146:	    goto normal_char;
    #####: 7147:	  laststart = 1;
    #####: 7148:	  return lasttok = OR;
        -: 7149:
        -: 7150:	case '\n':
    #####: 7151:	  if (syntax_bits & RE_LIMITED_OPS
    #####: 7152:	      || backslash
    #####: 7153:	      || !(syntax_bits & RE_NEWLINE_ALT))
        -: 7154:	    goto normal_char;
    #####: 7155:	  laststart = 1;
    #####: 7156:	  return lasttok = OR;
        -: 7157:
        -: 7158:	case '(':
    #####: 7159:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
    #####: 7160:	    goto normal_char;
    #####: 7161:	  ++parens;
    #####: 7162:	  laststart = 1;
    #####: 7163:	  return lasttok = LPAREN;
        -: 7164:
        -: 7165:	case ')':
    #####: 7166:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
    #####: 7167:	    goto normal_char;
    #####: 7168:	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
    #####: 7169:	    goto normal_char;
    #####: 7170:	  --parens;
    #####: 7171:	  laststart = 0;
    #####: 7172:	  return lasttok = RPAREN;
        -: 7173:
        -: 7174:	case '.':
    #####: 7175:	  if (backslash)
    #####: 7176:	    goto normal_char;
    #####: 7177:	  zeroset(ccl);
    #####: 7178:	  notset(ccl);
    #####: 7179:	  if (!(syntax_bits & RE_DOT_NEWLINE))
    #####: 7180:	    clrbit('\n', ccl);
    #####: 7181:	  if (syntax_bits & RE_DOT_NOT_NULL)
    #####: 7182:	    clrbit('\0', ccl);
    #####: 7183:	  laststart = 0;
    #####: 7184:	  return lasttok = CSET + charclass_index(ccl);
        -: 7185:
        -: 7186:	case 'w':
        -: 7187:	case 'W':
    #####: 7188:	  if (!backslash)
    #####: 7189:	    goto normal_char;
    #####: 7190:	  zeroset(ccl);
    #####: 7191:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
    #####: 7192:	    if (ISALNUM(c2))
    #####: 7193:	      setbit(c2, ccl);
    #####: 7194:	  if (c == 'W')
    #####: 7195:	    notset(ccl);
    #####: 7196:	  laststart = 0;
    #####: 7197:	  return lasttok = CSET + charclass_index(ccl);
        -: 7198:	
        -: 7199:	case '[':
    #####: 7200:	  if (backslash)
    #####: 7201:	    goto normal_char;
    #####: 7202:	  zeroset(ccl);
    #####: 7203:	  FETCH(c, "Unbalanced [");
    #####: 7204:	  if (c == '^')
        -: 7205:	    {
    #####: 7206:	      FETCH(c, "Unbalanced [");
    #####: 7207:	      invert = 1;
        -: 7208:	    }
        -: 7209:	  else
    #####: 7210:	    invert = 0;
        -: 7211:	  do
        -: 7212:	    {
        -: 7213:	      /* Nobody ever said this had to be fast. :-)
        -: 7214:		 Note that if we're looking at some other [:...:]
        -: 7215:		 construct, we just treat it as a bunch of ordinary
        -: 7216:		 characters.  We can do this because we assume
        -: 7217:		 regex has checked for syntax errors before
        -: 7218:		 dfa is ever called. */
    #####: 7219:	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
    #####: 7220:		for (c1 = 0; prednames[c1].name; ++c1)
    #####: 7221:		  if (looking_at(prednames[c1].name))
        -: 7222:		    {
    #####: 7223:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
    #####: 7224:			if ((*prednames[c1].pred)(c2))
    #####: 7225:			  setbit(c2, ccl);
    #####: 7226:		      lexptr += strlen(prednames[c1].name);
    #####: 7227:		      lexleft -= strlen(prednames[c1].name);
    #####: 7228:		      FETCH(c1, "Unbalanced [");
    #####: 7229:		      goto skip;
        -: 7230:		    }
    #####: 7231:	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
    #####: 7232:		FETCH(c, "Unbalanced [");
    #####: 7233:	      FETCH(c1, "Unbalanced [");
    #####: 7234:	      if (c1 == '-')
        -: 7235:		{
    #####: 7236:		  FETCH(c2, "Unbalanced [");
    #####: 7237:		  if (c2 == ']')
        -: 7238:		    {
        -: 7239:		      /* In the case [x-], the - is an ordinary hyphen,
        -: 7240:			 which is left in c1, the lookahead character. */
    #####: 7241:		      --lexptr;
    #####: 7242:		      ++lexleft;
    #####: 7243:		      c2 = c;
        -: 7244:		    }
        -: 7245:		  else
        -: 7246:		    {
    #####: 7247:		      if (c2 == '\\'
    #####: 7248:			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
    #####: 7249:			FETCH(c2, "Unbalanced [");
    #####: 7250:		      FETCH(c1, "Unbalanced [");
        -: 7251:		    }
        -: 7252:		}
        -: 7253:	      else
    #####: 7254:		c2 = c;
    #####: 7255:	      while (c <= c2)
        -: 7256:		{
    #####: 7257:		  setbit(c, ccl);
    #####: 7258:		  if (case_fold)
    #####: 7259:		    if (ISUPPER(c))
    #####: 7260:		      setbit(tolower(c), ccl);
    #####: 7261:		    else if (ISLOWER(c))
    #####: 7262:		      setbit(toupper(c), ccl);
    #####: 7263:		  ++c;
        -: 7264:		}
        -: 7265:	    skip:
        -: 7266:	      ;
        -: 7267:	    }
    #####: 7268:	  while ((c = c1) != ']');
    #####: 7269:	  if (invert)
        -: 7270:	    {
    #####: 7271:	      notset(ccl);
    #####: 7272:	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
    #####: 7273:		clrbit('\n', ccl);
        -: 7274:	    }
    #####: 7275:	  laststart = 0;
    #####: 7276:	  return lasttok = CSET + charclass_index(ccl);
        -: 7277:
        -: 7278:	default:
        -: 7279:	normal_char:
    #####: 7280:	  laststart = 0;
    #####: 7281:	  if (case_fold && ISALPHA(c))
        -: 7282:	    {
    #####: 7283:	      zeroset(ccl);
    #####: 7284:	      setbit(c, ccl);
    #####: 7285:	      if (isupper(c))
    #####: 7286:		setbit(tolower(c), ccl);
        -: 7287:	      else
    #####: 7288:		setbit(toupper(c), ccl);
    #####: 7289:	      return lasttok = CSET + charclass_index(ccl);
        -: 7290:	    }
    #####: 7291:	  return c;
        -: 7292:	}
        -: 7293:    }
        -: 7294:
        -: 7295:  /* The above loop should consume at most a backslash
        -: 7296:     and some other character. */
    #####: 7297:  abort();
        -: 7298:}
        -: 7299:
        -: 7300:/* Recursive descent parser for regular expressions. */
        -: 7301:
        -: 7302:static token tok;		/* Lookahead token. */
        -: 7303:static depth;			/* Current depth of a hypothetical stack
        -: 7304:				   holding deferred productions.  This is
        -: 7305:				   used to determine the depth that will be
        -: 7306:				   required of the real stack later on in
        -: 7307:				   dfaanalyze(). */
        -: 7308:
        -: 7309:/* Add the given token to the parse tree, maintaining the depth count and
        -: 7310:   updating the maximum depth if necessary. */
        -: 7311:static void
    #####: 7312:addtok(t)
        -: 7313:     token t;
        -: 7314:{
    #####: 7315:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
    #####: 7316:  dfa->tokens[dfa->tindex++] = t;
        -: 7317:
    #####: 7318:  switch (t)
        -: 7319:    {
        -: 7320:    case QMARK:
        -: 7321:    case STAR:
        -: 7322:    case PLUS:
    #####: 7323:      break;
        -: 7324:
        -: 7325:    case CAT:
        -: 7326:    case OR:
        -: 7327:    case ORTOP:
    #####: 7328:      --depth;
    #####: 7329:      break;
        -: 7330:
        -: 7331:    default:
    #####: 7332:      ++dfa->nleaves;
        -: 7333:    case EMPTY:
    #####: 7334:      ++depth;
    #####: 7335:      break;
        -: 7336:    }
    #####: 7337:  if (depth > dfa->depth)
    #####: 7338:    dfa->depth = depth;
    #####: 7339:}
        -: 7340:
        -: 7341:/* The grammar understood by the parser is as follows.
        -: 7342:
        -: 7343:   regexp:
        -: 7344:     regexp OR branch
        -: 7345:     branch
        -: 7346:
        -: 7347:   branch:
        -: 7348:     branch closure
        -: 7349:     closure
        -: 7350:
        -: 7351:   closure:
        -: 7352:     closure QMARK
        -: 7353:     closure STAR
        -: 7354:     closure PLUS
        -: 7355:     atom
        -: 7356:
        -: 7357:   atom:
        -: 7358:     <normal character>
        -: 7359:     CSET
        -: 7360:     BACKREF
        -: 7361:     BEGLINE
        -: 7362:     ENDLINE
        -: 7363:     BEGWORD
        -: 7364:     ENDWORD
        -: 7365:     LIMWORD
        -: 7366:     NOTLIMWORD
        -: 7367:     <empty>
        -: 7368:
        -: 7369:   The parser builds a parse tree in postfix form in an array of tokens. */
        -: 7370:
        -: 7371:#if __STDC__
        -: 7372:static void regexp(int);
        -: 7373:#else
        -: 7374:static void regexp();
        -: 7375:#endif
        -: 7376:
        -: 7377:static void
    #####: 7378:atom()
        -: 7379:{
    #####: 7380:  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
    #####: 7381:      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
    #####: 7382:      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
        -: 7383:    {
    #####: 7384:      addtok(tok);
    #####: 7385:      tok = lex();
        -: 7386:    }
    #####: 7387:  else if (tok == LPAREN)
        -: 7388:    {
    #####: 7389:      tok = lex();
    #####: 7390:      regexp(0);
    #####: 7391:      if (tok != RPAREN)
    #####: 7392:	dfaerror("Unbalanced (");
    #####: 7393:      tok = lex();
        -: 7394:    }
        -: 7395:  else
    #####: 7396:    addtok(EMPTY);
    #####: 7397:}
        -: 7398:
        -: 7399:/* Return the number of tokens in the given subexpression. */
        -: 7400:static int
    #####: 7401:nsubtoks(tindex)
        -: 7402:{
        -: 7403:  int ntoks1;
        -: 7404:
    #####: 7405:  switch (dfa->tokens[tindex - 1])
        -: 7406:    {
        -: 7407:    default:
    #####: 7408:      return 1;
        -: 7409:    case QMARK:
        -: 7410:    case STAR:
        -: 7411:    case PLUS:
    #####: 7412:      return 1 + nsubtoks(tindex - 1);
        -: 7413:    case CAT:
        -: 7414:    case OR:
        -: 7415:    case ORTOP:
    #####: 7416:      ntoks1 = nsubtoks(tindex - 1);
    #####: 7417:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
        -: 7418:    }
        -: 7419:}
        -: 7420:
        -: 7421:/* Copy the given subexpression to the top of the tree. */
        -: 7422:static void
    #####: 7423:copytoks(tindex, ntokens)
        -: 7424:     int tindex, ntokens;
        -: 7425:{
        -: 7426:  int i;
        -: 7427:
    #####: 7428:  for (i = 0; i < ntokens; ++i)
    #####: 7429:    addtok(dfa->tokens[tindex + i]);
    #####: 7430:}
        -: 7431:
        -: 7432:static void
    #####: 7433:closure()
        -: 7434:{
        -: 7435:  int tindex, ntokens, i;
        -: 7436:
    #####: 7437:  atom();
    #####: 7438:  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
    #####: 7439:    if (tok == REPMN)
        -: 7440:      {
    #####: 7441:	ntokens = nsubtoks(dfa->tindex);
    #####: 7442:	tindex = dfa->tindex - ntokens;
    #####: 7443:	if (maxrep == 0)
    #####: 7444:	  addtok(PLUS);
    #####: 7445:	if (minrep == 0)
    #####: 7446:	  addtok(QMARK);
    #####: 7447:	for (i = 1; i < minrep; ++i)
        -: 7448:	  {
    #####: 7449:	    copytoks(tindex, ntokens);
    #####: 7450:	    addtok(CAT);
        -: 7451:	  }
    #####: 7452:	for (; i < maxrep; ++i)
        -: 7453:	  {
    #####: 7454:	    copytoks(tindex, ntokens);
    #####: 7455:	    addtok(QMARK);
    #####: 7456:	    addtok(CAT);
        -: 7457:	  }
    #####: 7458:	tok = lex();
        -: 7459:      }
        -: 7460:    else
        -: 7461:      {
    #####: 7462:	addtok(tok);
    #####: 7463:	tok = lex();
        -: 7464:      }
    #####: 7465:}
        -: 7466:
        -: 7467:static void
    #####: 7468:branch()
        -: 7469:{
    #####: 7470:  closure();
    #####: 7471:  while (tok != RPAREN && tok != OR && tok >= 0)
        -: 7472:    {
    #####: 7473:      closure();
    #####: 7474:      addtok(CAT);
        -: 7475:    }
    #####: 7476:}
        -: 7477:
        -: 7478:static void
    #####: 7479:regexp(toplevel)
        -: 7480:     int toplevel;
        -: 7481:{
    #####: 7482:  branch();
    #####: 7483:  while (tok == OR)
        -: 7484:    {
    #####: 7485:      tok = lex();
    #####: 7486:      branch();
    #####: 7487:      if (toplevel)
    #####: 7488:	addtok(ORTOP);
        -: 7489:      else
    #####: 7490:	addtok(OR);
        -: 7491:    }
    #####: 7492:}
        -: 7493:
        -: 7494:/* Main entry point for the parser.  S is a string to be parsed, len is the
        -: 7495:   length of the string, so s can include NUL characters.  D is a pointer to
        -: 7496:   the struct dfa to parse into. */
        -: 7497:void
    #####: 7498:dfaparse(s, len, d)
        -: 7499:     char *s;
        -: 7500:     size_t len;
        -: 7501:     struct dfa *d;
        -: 7502:
        -: 7503:{
    #####: 7504:  dfa = d;
    #####: 7505:  lexstart = lexptr = s;
    #####: 7506:  lexleft = len;
    #####: 7507:  lasttok = END;
    #####: 7508:  laststart = 1;
    #####: 7509:  parens = 0;
        -: 7510:
    #####: 7511:  if (! syntax_bits_set)
    #####: 7512:    dfaerror("No syntax specified");
        -: 7513:
    #####: 7514:  tok = lex();
    #####: 7515:  depth = d->depth;
        -: 7516:
    #####: 7517:  regexp(1);
        -: 7518:
    #####: 7519:  if (tok != END)
    #####: 7520:    dfaerror("Unbalanced )");
        -: 7521:
    #####: 7522:  addtok(END - d->nregexps);
    #####: 7523:  addtok(CAT);
        -: 7524:
    #####: 7525:  if (d->nregexps)
    #####: 7526:    addtok(ORTOP);
        -: 7527:
    #####: 7528:  ++d->nregexps;
    #####: 7529:}
        -: 7530:
        -: 7531:/* Some primitives for operating on sets of positions. */
        -: 7532:
        -: 7533:/* Copy one set to another; the destination must be large enough. */
        -: 7534:static void
    #####: 7535:copy(src, dst)
        -: 7536:     position_set *src;
        -: 7537:     position_set *dst;
        -: 7538:{
        -: 7539:  int i;
        -: 7540:
    #####: 7541:  for (i = 0; i < src->nelem; ++i)
    #####: 7542:    dst->elems[i] = src->elems[i];
    #####: 7543:  dst->nelem = src->nelem;
    #####: 7544:}
        -: 7545:
        -: 7546:/* Insert a position in a set.  Position sets are maintained in sorted
        -: 7547:   order according to index.  If position already exists in the set with
        -: 7548:   the same index then their constraints are logically or'd together.
        -: 7549:   S->elems must point to an array large enough to hold the resulting set. */
        -: 7550:static void
    #####: 7551:insert(p, s)
        -: 7552:     position p;
        -: 7553:     position_set *s;
        -: 7554:{
        -: 7555:  int i;
        -: 7556:  position t1, t2;
        -: 7557:
    #####: 7558:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
        -: 7559:    ;
    #####: 7560:  if (i < s->nelem && p.index == s->elems[i].index)
    #####: 7561:    s->elems[i].constraint |= p.constraint;
        -: 7562:  else
        -: 7563:    {
    #####: 7564:      t1 = p;
    #####: 7565:      ++s->nelem;
    #####: 7566:      while (i < s->nelem)
        -: 7567:	{
    #####: 7568:	  t2 = s->elems[i];
    #####: 7569:	  s->elems[i++] = t1;
    #####: 7570:	  t1 = t2;
        -: 7571:	}
        -: 7572:    }
    #####: 7573:}
        -: 7574:
        -: 7575:/* Merge two sets of positions into a third.  The result is exactly as if
        -: 7576:   the positions of both sets were inserted into an initially empty set. */
        -: 7577:static void
    #####: 7578:merge(s1, s2, m)
        -: 7579:     position_set *s1;
        -: 7580:     position_set *s2;
        -: 7581:     position_set *m;
        -: 7582:{
    #####: 7583:  int i = 0, j = 0;
        -: 7584:
    #####: 7585:  m->nelem = 0;
    #####: 7586:  while (i < s1->nelem && j < s2->nelem)
    #####: 7587:    if (s1->elems[i].index > s2->elems[j].index)
    #####: 7588:      m->elems[m->nelem++] = s1->elems[i++];
    #####: 7589:    else if (s1->elems[i].index < s2->elems[j].index)
    #####: 7590:      m->elems[m->nelem++] = s2->elems[j++];
        -: 7591:    else
        -: 7592:      {
    #####: 7593:	m->elems[m->nelem] = s1->elems[i++];
    #####: 7594:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
        -: 7595:      }
    #####: 7596:  while (i < s1->nelem)
    #####: 7597:    m->elems[m->nelem++] = s1->elems[i++];
    #####: 7598:  while (j < s2->nelem)
    #####: 7599:    m->elems[m->nelem++] = s2->elems[j++];
    #####: 7600:}
        -: 7601:
        -: 7602:/* Delete a position from a set. */
        -: 7603:static void
    #####: 7604:delete(p, s)
        -: 7605:     position p;
        -: 7606:     position_set *s;
        -: 7607:{
        -: 7608:  int i;
        -: 7609:
    #####: 7610:  for (i = 0; i < s->nelem; ++i)
    #####: 7611:    if (p.index == s->elems[i].index)
    #####: 7612:      break;
    #####: 7613:  if (i < s->nelem)
    #####: 7614:    for (--s->nelem; i < s->nelem; ++i)
    #####: 7615:      s->elems[i] = s->elems[i + 1];
    #####: 7616:}
        -: 7617:
        -: 7618:/* Find the index of the state corresponding to the given position set with
        -: 7619:   the given preceding context, or create a new state if there is no such
        -: 7620:   state.  Newline and letter tell whether we got here on a newline or
        -: 7621:   letter, respectively. */
        -: 7622:static int
    #####: 7623:state_index(d, s, newline, letter)
        -: 7624:     struct dfa *d;
        -: 7625:     position_set *s;
        -: 7626:     int newline;
        -: 7627:     int letter;
        -: 7628:{
    #####: 7629:  int hash = 0;
        -: 7630:  int constraint;
        -: 7631:  int i, j;
        -: 7632:
    #####: 7633:  newline = newline ? 1 : 0;
    #####: 7634:  letter = letter ? 1 : 0;
        -: 7635:
    #####: 7636:  for (i = 0; i < s->nelem; ++i)
    #####: 7637:    hash ^= s->elems[i].index + s->elems[i].constraint;
        -: 7638:
        -: 7639:  /* Try to find a state that exactly matches the proposed one. */
    #####: 7640:  for (i = 0; i < d->sindex; ++i)
        -: 7641:    {
    #####: 7642:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
    #####: 7643:	  || newline != d->states[i].newline || letter != d->states[i].letter)
    #####: 7644:	continue;
    #####: 7645:      for (j = 0; j < s->nelem; ++j)
    #####: 7646:	if (s->elems[j].constraint
    #####: 7647:	    != d->states[i].elems.elems[j].constraint
    #####: 7648:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
        -: 7649:	  break;
    #####: 7650:      if (j == s->nelem)
    #####: 7651:	return i;
        -: 7652:    }
        -: 7653:
        -: 7654:  /* We'll have to create a new state. */
    #####: 7655:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
    #####: 7656:  d->states[i].hash = hash;
    #####: 7657:  MALLOC(d->states[i].elems.elems, position, s->nelem);
    #####: 7658:  copy(s, &d->states[i].elems);
    #####: 7659:  d->states[i].newline = newline;
    #####: 7660:  d->states[i].letter = letter;
    #####: 7661:  d->states[i].backref = 0;
    #####: 7662:  d->states[i].constraint = 0;
    #####: 7663:  d->states[i].first_end = 0;
    #####: 7664:  for (j = 0; j < s->nelem; ++j)
    #####: 7665:    if (d->tokens[s->elems[j].index] < 0)
        -: 7666:      {
    #####: 7667:	constraint = s->elems[j].constraint;
    #####: 7668:	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
    #####: 7669:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
    #####: 7670:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
    #####: 7671:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
    #####: 7672:	  d->states[i].constraint |= constraint;
    #####: 7673:	if (! d->states[i].first_end)
    #####: 7674:	  d->states[i].first_end = d->tokens[s->elems[j].index];
        -: 7675:      }
    #####: 7676:    else if (d->tokens[s->elems[j].index] == BACKREF)
        -: 7677:      {
    #####: 7678:	d->states[i].constraint = NO_CONSTRAINT;
    #####: 7679:	d->states[i].backref = 1;
        -: 7680:      }
        -: 7681:
    #####: 7682:  ++d->sindex;
        -: 7683:
    #####: 7684:  return i;
        -: 7685:}
        -: 7686:
        -: 7687:/* Find the epsilon closure of a set of positions.  If any position of the set
        -: 7688:   contains a symbol that matches the empty string in some context, replace
        -: 7689:   that position with the elements of its follow labeled with an appropriate
        -: 7690:   constraint.  Repeat exhaustively until no funny positions are left.
        -: 7691:   S->elems must be large enough to hold the result. */
        -: 7692:void
    #####: 7693:epsclosure(s, d)
        -: 7694:     position_set *s;
        -: 7695:     struct dfa *d;
        -: 7696:{
        -: 7697:  int i, j;
        -: 7698:  int *visited;
        -: 7699:  position p, old;
        -: 7700:
    #####: 7701:  MALLOC(visited, int, d->tindex);
    #####: 7702:  for (i = 0; i < d->tindex; ++i)
    #####: 7703:    visited[i] = 0;
        -: 7704:
    #####: 7705:  for (i = 0; i < s->nelem; ++i)
    #####: 7706:    if (d->tokens[s->elems[i].index] >= NOTCHAR
    #####: 7707:	&& d->tokens[s->elems[i].index] != BACKREF
    #####: 7708:	&& d->tokens[s->elems[i].index] < CSET)
        -: 7709:      {
    #####: 7710:	old = s->elems[i];
    #####: 7711:	p.constraint = old.constraint;
    #####: 7712:	delete(s->elems[i], s);
    #####: 7713:	if (visited[old.index])
        -: 7714:	  {
    #####: 7715:	    --i;
    #####: 7716:	    continue;
        -: 7717:	  }
    #####: 7718:	visited[old.index] = 1;
    #####: 7719:	switch (d->tokens[old.index])
        -: 7720:	  {
        -: 7721:	  case BEGLINE:
    #####: 7722:	    p.constraint &= BEGLINE_CONSTRAINT;
    #####: 7723:	    break;
        -: 7724:	  case ENDLINE:
    #####: 7725:	    p.constraint &= ENDLINE_CONSTRAINT;
    #####: 7726:	    break;
        -: 7727:	  case BEGWORD:
    #####: 7728:	    p.constraint &= BEGWORD_CONSTRAINT;
    #####: 7729:	    break;
        -: 7730:	  case ENDWORD:
    #####: 7731:	    p.constraint &= ENDWORD_CONSTRAINT;
    #####: 7732:	    break;
        -: 7733:	  case LIMWORD:
    #####: 7734:	    p.constraint &= LIMWORD_CONSTRAINT;
    #####: 7735:	    break;
        -: 7736:	  case NOTLIMWORD:
    #####: 7737:	    p.constraint &= NOTLIMWORD_CONSTRAINT;
    #####: 7738:	    break;
        -: 7739:	  default:
    #####: 7740:	    break;
        -: 7741:	  }
    #####: 7742:	for (j = 0; j < d->follows[old.index].nelem; ++j)
        -: 7743:	  {
    #####: 7744:	    p.index = d->follows[old.index].elems[j].index;
    #####: 7745:	    insert(p, s);
        -: 7746:	  }
        -: 7747:	/* Force rescan to start at the beginning. */
    #####: 7748:	i = -1;
        -: 7749:      }
        -: 7750:
    #####: 7751:  free(visited);
    #####: 7752:}
        -: 7753:
        -: 7754:/* Perform bottom-up analysis on the parse tree, computing various functions.
        -: 7755:   Note that at this point, we're pretending constructs like \< are real
        -: 7756:   characters rather than constraints on what can follow them.
        -: 7757:
        -: 7758:   Nullable:  A node is nullable if it is at the root of a regexp that can
        -: 7759:   match the empty string.
        -: 7760:   *  EMPTY leaves are nullable.
        -: 7761:   * No other leaf is nullable.
        -: 7762:   * A QMARK or STAR node is nullable.
        -: 7763:   * A PLUS node is nullable if its argument is nullable.
        -: 7764:   * A CAT node is nullable if both its arguments are nullable.
        -: 7765:   * An OR node is nullable if either argument is nullable.
        -: 7766:
        -: 7767:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
        -: 7768:   that could correspond to the first character of a string matching the
        -: 7769:   regexp rooted at the given node.
        -: 7770:   * EMPTY leaves have empty firstpos.
        -: 7771:   * The firstpos of a nonempty leaf is that leaf itself.
        -: 7772:   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
        -: 7773:     argument.
        -: 7774:   * The firstpos of a CAT node is the firstpos of the left argument, union
        -: 7775:     the firstpos of the right if the left argument is nullable.
        -: 7776:   * The firstpos of an OR node is the union of firstpos of each argument.
        -: 7777:
        -: 7778:   Lastpos:  The lastpos of a node is the set of positions that could
        -: 7779:   correspond to the last character of a string matching the regexp at
        -: 7780:   the given node.
        -: 7781:   * EMPTY leaves have empty lastpos.
        -: 7782:   * The lastpos of a nonempty leaf is that leaf itself.
        -: 7783:   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
        -: 7784:     argument.
        -: 7785:   * The lastpos of a CAT node is the lastpos of its right argument, union
        -: 7786:     the lastpos of the left if the right argument is nullable.
        -: 7787:   * The lastpos of an OR node is the union of the lastpos of each argument.
        -: 7788:
        -: 7789:   Follow:  The follow of a position is the set of positions that could
        -: 7790:   correspond to the character following a character matching the node in
        -: 7791:   a string matching the regexp.  At this point we consider special symbols
        -: 7792:   that match the empty string in some context to be just normal characters.
        -: 7793:   Later, if we find that a special symbol is in a follow set, we will
        -: 7794:   replace it with the elements of its follow, labeled with an appropriate
        -: 7795:   constraint.
        -: 7796:   * Every node in the firstpos of the argument of a STAR or PLUS node is in
        -: 7797:     the follow of every node in the lastpos.
        -: 7798:   * Every node in the firstpos of the second argument of a CAT node is in
        -: 7799:     the follow of every node in the lastpos of the first argument.
        -: 7800:
        -: 7801:   Because of the postfix representation of the parse tree, the depth-first
        -: 7802:   analysis is conveniently done by a linear scan with the aid of a stack.
        -: 7803:   Sets are stored as arrays of the elements, obeying a stack-like allocation
        -: 7804:   scheme; the number of elements in each set deeper in the stack can be
        -: 7805:   used to determine the address of a particular set's array. */
        -: 7806:void
    #####: 7807:dfaanalyze(d, searchflag)
        -: 7808:     struct dfa *d;
        -: 7809:     int searchflag;
        -: 7810:{
        -: 7811:  int *nullable;		/* Nullable stack. */
        -: 7812:  int *nfirstpos;		/* Element count stack for firstpos sets. */
        -: 7813:  position *firstpos;		/* Array where firstpos elements are stored. */
        -: 7814:  int *nlastpos;		/* Element count stack for lastpos sets. */
        -: 7815:  position *lastpos;		/* Array where lastpos elements are stored. */
        -: 7816:  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
        -: 7817:  position_set tmp;		/* Temporary set for merging sets. */
        -: 7818:  position_set merged;		/* Result of merging sets. */
        -: 7819:  int wants_newline;		/* True if some position wants newline info. */
        -: 7820:  int *o_nullable;
        -: 7821:  int *o_nfirst, *o_nlast;
        -: 7822:  position *o_firstpos, *o_lastpos;
        -: 7823:  int i, j;
        -: 7824:  position *pos;
        -: 7825:
        -: 7826:#ifdef DEBUG
        -: 7827:  fprintf(stderr, "dfaanalyze:\n");
        -: 7828:  for (i = 0; i < d->tindex; ++i)
        -: 7829:    {
        -: 7830:      fprintf(stderr, " %d:", i);
        -: 7831:      prtok(d->tokens[i]);
        -: 7832:    }
        -: 7833:  putc('\n', stderr);
        -: 7834:#endif
        -: 7835:
    #####: 7836:  d->searchflag = searchflag;
        -: 7837:
    #####: 7838:  MALLOC(nullable, int, d->depth);
    #####: 7839:  o_nullable = nullable;
    #####: 7840:  MALLOC(nfirstpos, int, d->depth);
    #####: 7841:  o_nfirst = nfirstpos;
    #####: 7842:  MALLOC(firstpos, position, d->nleaves);
    #####: 7843:  o_firstpos = firstpos, firstpos += d->nleaves;
    #####: 7844:  MALLOC(nlastpos, int, d->depth);
    #####: 7845:  o_nlast = nlastpos;
    #####: 7846:  MALLOC(lastpos, position, d->nleaves);
    #####: 7847:  o_lastpos = lastpos, lastpos += d->nleaves;
    #####: 7848:  MALLOC(nalloc, int, d->tindex);
    #####: 7849:  for (i = 0; i < d->tindex; ++i)
    #####: 7850:    nalloc[i] = 0;
    #####: 7851:  MALLOC(merged.elems, position, d->nleaves);
        -: 7852:
    #####: 7853:  CALLOC(d->follows, position_set, d->tindex);
        -: 7854:
    #####: 7855:  for (i = 0; i < d->tindex; ++i)
        -: 7856:#ifdef DEBUG
        -: 7857:    {				/* Nonsyntactic #ifdef goo... */
        -: 7858:#endif
    #####: 7859:    switch (d->tokens[i])
        -: 7860:      {
        -: 7861:      case EMPTY:
        -: 7862:	/* The empty set is nullable. */
    #####: 7863:	*nullable++ = 1;
        -: 7864:
        -: 7865:	/* The firstpos and lastpos of the empty leaf are both empty. */
    #####: 7866:	*nfirstpos++ = *nlastpos++ = 0;
    #####: 7867:	break;
        -: 7868:
        -: 7869:      case STAR:
        -: 7870:      case PLUS:
        -: 7871:	/* Every element in the firstpos of the argument is in the follow
        -: 7872:	   of every element in the lastpos. */
    #####: 7873:	tmp.nelem = nfirstpos[-1];
    #####: 7874:	tmp.elems = firstpos;
    #####: 7875:	pos = lastpos;
    #####: 7876:	for (j = 0; j < nlastpos[-1]; ++j)
        -: 7877:	  {
    #####: 7878:	    merge(&tmp, &d->follows[pos[j].index], &merged);
    #####: 7879:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
        -: 7880:				 nalloc[pos[j].index], merged.nelem - 1);
    #####: 7881:	    copy(&merged, &d->follows[pos[j].index]);
        -: 7882:	  }
        -: 7883:
        -: 7884:      case QMARK:
        -: 7885:	/* A QMARK or STAR node is automatically nullable. */
    #####: 7886:	if (d->tokens[i] != PLUS)
    #####: 7887:	  nullable[-1] = 1;
    #####: 7888:	break;
        -: 7889:
        -: 7890:      case CAT:
        -: 7891:	/* Every element in the firstpos of the second argument is in the
        -: 7892:	   follow of every element in the lastpos of the first argument. */
    #####: 7893:	tmp.nelem = nfirstpos[-1];
    #####: 7894:	tmp.elems = firstpos;
    #####: 7895:	pos = lastpos + nlastpos[-1];
    #####: 7896:	for (j = 0; j < nlastpos[-2]; ++j)
        -: 7897:	  {
    #####: 7898:	    merge(&tmp, &d->follows[pos[j].index], &merged);
    #####: 7899:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
        -: 7900:				 nalloc[pos[j].index], merged.nelem - 1);
    #####: 7901:	    copy(&merged, &d->follows[pos[j].index]);
        -: 7902:	  }
        -: 7903:
        -: 7904:	/* The firstpos of a CAT node is the firstpos of the first argument,
        -: 7905:	   union that of the second argument if the first is nullable. */
    #####: 7906:	if (nullable[-2])
    #####: 7907:	  nfirstpos[-2] += nfirstpos[-1];
        -: 7908:	else
    #####: 7909:	  firstpos += nfirstpos[-1];
    #####: 7910:	--nfirstpos;
        -: 7911:
        -: 7912:	/* The lastpos of a CAT node is the lastpos of the second argument,
        -: 7913:	   union that of the first argument if the second is nullable. */
    #####: 7914:	if (nullable[-1])
    #####: 7915:	  nlastpos[-2] += nlastpos[-1];
        -: 7916:	else
        -: 7917:	  {
    #####: 7918:	    pos = lastpos + nlastpos[-2];
    #####: 7919:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
    #####: 7920:	      pos[j] = lastpos[j];
    #####: 7921:	    lastpos += nlastpos[-2];
    #####: 7922:	    nlastpos[-2] = nlastpos[-1];
        -: 7923:	  }
    #####: 7924:	--nlastpos;
        -: 7925:
        -: 7926:	/* A CAT node is nullable if both arguments are nullable. */
    #####: 7927:	nullable[-2] = nullable[-1] && nullable[-2];
    #####: 7928:	--nullable;
    #####: 7929:	break;
        -: 7930:
        -: 7931:      case OR:
        -: 7932:      case ORTOP:
        -: 7933:	/* The firstpos is the union of the firstpos of each argument. */
    #####: 7934:	nfirstpos[-2] += nfirstpos[-1];
    #####: 7935:	--nfirstpos;
        -: 7936:
        -: 7937:	/* The lastpos is the union of the lastpos of each argument. */
    #####: 7938:	nlastpos[-2] += nlastpos[-1];
    #####: 7939:	--nlastpos;
        -: 7940:
        -: 7941:	/* An OR node is nullable if either argument is nullable. */
    #####: 7942:	nullable[-2] = nullable[-1] || nullable[-2];
    #####: 7943:	--nullable;
    #####: 7944:	break;
        -: 7945:
        -: 7946:      default:
        -: 7947:	/* Anything else is a nonempty position.  (Note that special
        -: 7948:	   constructs like \< are treated as nonempty strings here;
        -: 7949:	   an "epsilon closure" effectively makes them nullable later.
        -: 7950:	   Backreferences have to get a real position so we can detect
        -: 7951:	   transitions on them later.  But they are nullable. */
    #####: 7952:	*nullable++ = d->tokens[i] == BACKREF;
        -: 7953:
        -: 7954:	/* This position is in its own firstpos and lastpos. */
    #####: 7955:	*nfirstpos++ = *nlastpos++ = 1;
    #####: 7956:	--firstpos, --lastpos;
    #####: 7957:	firstpos->index = lastpos->index = i;
    #####: 7958:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
        -: 7959:
        -: 7960:	/* Allocate the follow set for this position. */
    #####: 7961:	nalloc[i] = 1;
    #####: 7962:	MALLOC(d->follows[i].elems, position, nalloc[i]);
    #####: 7963:	break;
        -: 7964:      }
        -: 7965:#ifdef DEBUG
        -: 7966:    /* ... balance the above nonsyntactic #ifdef goo... */
        -: 7967:      fprintf(stderr, "node %d:", i);
        -: 7968:      prtok(d->tokens[i]);
        -: 7969:      putc('\n', stderr);
        -: 7970:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
        -: 7971:      fprintf(stderr, " firstpos:");
        -: 7972:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
        -: 7973:	{
        -: 7974:	  fprintf(stderr, " %d:", firstpos[j].index);
        -: 7975:	  prtok(d->tokens[firstpos[j].index]);
        -: 7976:	}
        -: 7977:      fprintf(stderr, "\n lastpos:");
        -: 7978:      for (j = nlastpos[-1] - 1; j >= 0; --j)
        -: 7979:	{
        -: 7980:	  fprintf(stderr, " %d:", lastpos[j].index);
        -: 7981:	  prtok(d->tokens[lastpos[j].index]);
        -: 7982:	}
        -: 7983:      putc('\n', stderr);
        -: 7984:    }
        -: 7985:#endif
        -: 7986:
        -: 7987:  /* For each follow set that is the follow set of a real position, replace
        -: 7988:     it with its epsilon closure. */
    #####: 7989:  for (i = 0; i < d->tindex; ++i)
    #####: 7990:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
    #####: 7991:	|| d->tokens[i] >= CSET)
        -: 7992:      {
        -: 7993:#ifdef DEBUG
        -: 7994:	fprintf(stderr, "follows(%d:", i);
        -: 7995:	prtok(d->tokens[i]);
        -: 7996:	fprintf(stderr, "):");
        -: 7997:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
        -: 7998:	  {
        -: 7999:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
        -: 8000:	    prtok(d->tokens[d->follows[i].elems[j].index]);
        -: 8001:	  }
        -: 8002:	putc('\n', stderr);
        -: 8003:#endif
    #####: 8004:	copy(&d->follows[i], &merged);
    #####: 8005:	epsclosure(&merged, d);
    #####: 8006:	if (d->follows[i].nelem < merged.nelem)
    #####: 8007:	  REALLOC(d->follows[i].elems, position, merged.nelem);
    #####: 8008:	copy(&merged, &d->follows[i]);
        -: 8009:      }
        -: 8010:
        -: 8011:  /* Get the epsilon closure of the firstpos of the regexp.  The result will
        -: 8012:     be the set of positions of state 0. */
    #####: 8013:  merged.nelem = 0;
    #####: 8014:  for (i = 0; i < nfirstpos[-1]; ++i)
    #####: 8015:    insert(firstpos[i], &merged);
    #####: 8016:  epsclosure(&merged, d);
        -: 8017:
        -: 8018:  /* Check if any of the positions of state 0 will want newline context. */
    #####: 8019:  wants_newline = 0;
    #####: 8020:  for (i = 0; i < merged.nelem; ++i)
    #####: 8021:    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))
    #####: 8022:      wants_newline = 1;
        -: 8023:
        -: 8024:  /* Build the initial state. */
    #####: 8025:  d->salloc = 1;
    #####: 8026:  d->sindex = 0;
    #####: 8027:  MALLOC(d->states, dfa_state, d->salloc);
    #####: 8028:  state_index(d, &merged, wants_newline, 0);
        -: 8029:
    #####: 8030:  free(o_nullable);
    #####: 8031:  free(o_nfirst);
    #####: 8032:  free(o_firstpos);
    #####: 8033:  free(o_nlast);
    #####: 8034:  free(o_lastpos);
    #####: 8035:  free(nalloc);
    #####: 8036:  free(merged.elems);
    #####: 8037:}
        -: 8038:
        -: 8039:/* Find, for each character, the transition out of state s of d, and store
        -: 8040:   it in the appropriate slot of trans.
        -: 8041:
        -: 8042:   We divide the positions of s into groups (positions can appear in more
        -: 8043:   than one group).  Each group is labeled with a set of characters that
        -: 8044:   every position in the group matches (taking into account, if necessary,
        -: 8045:   preceding context information of s).  For each group, find the union
        -: 8046:   of the its elements' follows.  This set is the set of positions of the
        -: 8047:   new state.  For each character in the group's label, set the transition
        -: 8048:   on this character to be to a state corresponding to the set's positions,
        -: 8049:   and its associated backward context information, if necessary.
        -: 8050:
        -: 8051:   If we are building a searching matcher, we include the positions of state
        -: 8052:   0 in every state.
        -: 8053:
        -: 8054:   The collection of groups is constructed by building an equivalence-class
        -: 8055:   partition of the positions of s.
        -: 8056:
        -: 8057:   For each position, find the set of characters C that it matches.  Eliminate
        -: 8058:   any characters from C that fail on grounds of backward context.
        -: 8059:
        -: 8060:   Search through the groups, looking for a group whose label L has nonempty
        -: 8061:   intersection with C.  If L - C is nonempty, create a new group labeled
        -: 8062:   L - C and having the same positions as the current group, and set L to
        -: 8063:   the intersection of L and C.  Insert the position in this group, set
        -: 8064:   C = C - L, and resume scanning.
        -: 8065:
        -: 8066:   If after comparing with every group there are characters remaining in C,
        -: 8067:   create a new group labeled with the characters of C and insert this
        -: 8068:   position in that group. */
        -: 8069:void
    #####: 8070:dfastate(s, d, trans)
        -: 8071:     int s;
        -: 8072:     struct dfa *d;
        -: 8073:     int trans[];
        -: 8074:{
        -: 8075:  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
        -: 8076:  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
    #####: 8077:  int ngrps = 0;		/* Number of groups actually used. */
        -: 8078:  position pos;			/* Current position being considered. */
        -: 8079:  charclass matches;		/* Set of matching characters. */
        -: 8080:  int matchesf;			/* True if matches is nonempty. */
        -: 8081:  charclass intersect;		/* Intersection with some label set. */
        -: 8082:  int intersectf;		/* True if intersect is nonempty. */
        -: 8083:  charclass leftovers;		/* Stuff in the label that didn't match. */
        -: 8084:  int leftoversf;		/* True if leftovers is nonempty. */
        -: 8085:  static charclass letters;	/* Set of characters considered letters. */
        -: 8086:  static charclass newline;	/* Set of characters that aren't newline. */
        -: 8087:  position_set follows;		/* Union of the follows of some group. */
        -: 8088:  position_set tmp;		/* Temporary space for merging sets. */
        -: 8089:  int state;			/* New state. */
        -: 8090:  int wants_newline;		/* New state wants to know newline context. */
        -: 8091:  int state_newline;		/* New state on a newline transition. */
        -: 8092:  int wants_letter;		/* New state wants to know letter context. */
        -: 8093:  int state_letter;		/* New state on a letter transition. */
        -: 8094:  static initialized;		/* Flag for static initialization. */
        -: 8095:  int i, j, k;
        -: 8096:
        -: 8097:  /* Initialize the set of letters, if necessary. */
    #####: 8098:  if (! initialized)
        -: 8099:    {
    #####: 8100:      initialized = 1;
    #####: 8101:      for (i = 0; i < NOTCHAR; ++i)
    #####: 8102:	if (ISALNUM(i))
    #####: 8103:	  setbit(i, letters);
    #####: 8104:      setbit('\n', newline);
        -: 8105:    }
        -: 8106:
    #####: 8107:  zeroset(matches);
        -: 8108:
    #####: 8109:  for (i = 0; i < d->states[s].elems.nelem; ++i)
        -: 8110:    {
    #####: 8111:      pos = d->states[s].elems.elems[i];
    #####: 8112:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
    #####: 8113:	setbit(d->tokens[pos.index], matches);
    #####: 8114:      else if (d->tokens[pos.index] >= CSET)
    #####: 8115:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
        -: 8116:      else
    #####: 8117:	continue;
        -: 8118:
        -: 8119:      /* Some characters may need to be eliminated from matches because
        -: 8120:	 they fail in the current context. */
    #####: 8121:      if (pos.constraint != 0xFF)
        -: 8122:	{
    #####: 8123:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
        -: 8124:					 d->states[s].newline, 1))
    #####: 8125:	    clrbit('\n', matches);
    #####: 8126:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
        -: 8127:					 d->states[s].newline, 0))
    #####: 8128:	    for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 8129:	      matches[j] &= newline[j];
    #####: 8130:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
        -: 8131:					d->states[s].letter, 1))
    #####: 8132:	    for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 8133:	      matches[j] &= ~letters[j];
    #####: 8134:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
        -: 8135:					d->states[s].letter, 0))
    #####: 8136:	    for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 8137:	      matches[j] &= letters[j];
        -: 8138:
        -: 8139:	  /* If there are no characters left, there's no point in going on. */
    #####: 8140:	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
        -: 8141:	    ;
    #####: 8142:	  if (j == CHARCLASS_INTS)
    #####: 8143:	    continue;
        -: 8144:	}
        -: 8145:
    #####: 8146:      for (j = 0; j < ngrps; ++j)
        -: 8147:	{
        -: 8148:	  /* If matches contains a single character only, and the current
        -: 8149:	     group's label doesn't contain that character, go on to the
        -: 8150:	     next group. */
    #####: 8151:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
    #####: 8152:	      && !tstbit(d->tokens[pos.index], labels[j]))
    #####: 8153:	    continue;
        -: 8154:
        -: 8155:	  /* Check if this group's label has a nonempty intersection with
        -: 8156:	     matches. */
    #####: 8157:	  intersectf = 0;
    #####: 8158:	  for (k = 0; k < CHARCLASS_INTS; ++k)
    #####: 8159:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
    #####: 8160:	  if (! intersectf)
    #####: 8161:	    continue;
        -: 8162:
        -: 8163:	  /* It does; now find the set differences both ways. */
    #####: 8164:	  leftoversf = matchesf = 0;
    #####: 8165:	  for (k = 0; k < CHARCLASS_INTS; ++k)
        -: 8166:	    {
        -: 8167:	      /* Even an optimizing compiler can't know this for sure. */
    #####: 8168:	      int match = matches[k], label = labels[j][k];
        -: 8169:
    #####: 8170:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
    #####: 8171:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
        -: 8172:	    }
        -: 8173:
        -: 8174:	  /* If there were leftovers, create a new group labeled with them. */
    #####: 8175:	  if (leftoversf)
        -: 8176:	    {
    #####: 8177:	      copyset(leftovers, labels[ngrps]);
    #####: 8178:	      copyset(intersect, labels[j]);
    #####: 8179:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
    #####: 8180:	      copy(&grps[j], &grps[ngrps]);
    #####: 8181:	      ++ngrps;
        -: 8182:	    }
        -: 8183:
        -: 8184:	  /* Put the position in the current group.  Note that there is no
        -: 8185:	     reason to call insert() here. */
    #####: 8186:	  grps[j].elems[grps[j].nelem++] = pos;
        -: 8187:
        -: 8188:	  /* If every character matching the current position has been
        -: 8189:	     accounted for, we're done. */
    #####: 8190:	  if (! matchesf)
    #####: 8191:	    break;
        -: 8192:	}
        -: 8193:
        -: 8194:      /* If we've passed the last group, and there are still characters
        -: 8195:	 unaccounted for, then we'll have to create a new group. */
    #####: 8196:      if (j == ngrps)
        -: 8197:	{
    #####: 8198:	  copyset(matches, labels[ngrps]);
    #####: 8199:	  zeroset(matches);
    #####: 8200:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
    #####: 8201:	  grps[ngrps].nelem = 1;
    #####: 8202:	  grps[ngrps].elems[0] = pos;
    #####: 8203:	  ++ngrps;
        -: 8204:	}
        -: 8205:    }
        -: 8206:
    #####: 8207:  MALLOC(follows.elems, position, d->nleaves);
    #####: 8208:  MALLOC(tmp.elems, position, d->nleaves);
        -: 8209:
        -: 8210:  /* If we are a searching matcher, the default transition is to a state
        -: 8211:     containing the positions of state 0, otherwise the default transition
        -: 8212:     is to fail miserably. */
    #####: 8213:  if (d->searchflag)
        -: 8214:    {
    #####: 8215:      wants_newline = 0;
    #####: 8216:      wants_letter = 0;
    #####: 8217:      for (i = 0; i < d->states[0].elems.nelem; ++i)
        -: 8218:	{
    #####: 8219:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
    #####: 8220:	    wants_newline = 1;
    #####: 8221:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
    #####: 8222:	    wants_letter = 1;
        -: 8223:	}
    #####: 8224:      copy(&d->states[0].elems, &follows);
    #####: 8225:      state = state_index(d, &follows, 0, 0);
    #####: 8226:      if (wants_newline)
    #####: 8227:	state_newline = state_index(d, &follows, 1, 0);
        -: 8228:      else
    #####: 8229:	state_newline = state;
    #####: 8230:      if (wants_letter)
    #####: 8231:	state_letter = state_index(d, &follows, 0, 1);
        -: 8232:      else
    #####: 8233:	state_letter = state;
    #####: 8234:      for (i = 0; i < NOTCHAR; ++i)
    #####: 8235:	if (i == '\n')
    #####: 8236:	  trans[i] = state_newline;
    #####: 8237:	else if (ISALNUM(i))
    #####: 8238:	  trans[i] = state_letter;
        -: 8239:	else
    #####: 8240:	  trans[i] = state;
        -: 8241:    }
        -: 8242:  else
    #####: 8243:    for (i = 0; i < NOTCHAR; ++i)
    #####: 8244:      trans[i] = -1;
        -: 8245:
    #####: 8246:  for (i = 0; i < ngrps; ++i)
        -: 8247:    {
    #####: 8248:      follows.nelem = 0;
        -: 8249:
        -: 8250:      /* Find the union of the follows of the positions of the group.
        -: 8251:	 This is a hideously inefficient loop.  Fix it someday. */
    #####: 8252:      for (j = 0; j < grps[i].nelem; ++j)
    #####: 8253:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
    #####: 8254:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
        -: 8255:
        -: 8256:      /* If we are building a searching matcher, throw in the positions
        -: 8257:	 of state 0 as well. */
    #####: 8258:      if (d->searchflag)
    #####: 8259:	for (j = 0; j < d->states[0].elems.nelem; ++j)
    #####: 8260:	  insert(d->states[0].elems.elems[j], &follows);
        -: 8261:
        -: 8262:      /* Find out if the new state will want any context information. */
    #####: 8263:      wants_newline = 0;
    #####: 8264:      if (tstbit('\n', labels[i]))
    #####: 8265:	for (j = 0; j < follows.nelem; ++j)
    #####: 8266:	  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))
    #####: 8267:	    wants_newline = 1;
        -: 8268:
    #####: 8269:      wants_letter = 0;
    #####: 8270:      for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 8271:	if (labels[i][j] & letters[j])
    #####: 8272:	  break;
    #####: 8273:      if (j < CHARCLASS_INTS)
    #####: 8274:	for (j = 0; j < follows.nelem; ++j)
    #####: 8275:	  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))
    #####: 8276:	    wants_letter = 1;
        -: 8277:
        -: 8278:      /* Find the state(s) corresponding to the union of the follows. */
    #####: 8279:      state = state_index(d, &follows, 0, 0);
    #####: 8280:      if (wants_newline)
    #####: 8281:	state_newline = state_index(d, &follows, 1, 0);
        -: 8282:      else
    #####: 8283:	state_newline = state;
    #####: 8284:      if (wants_letter)
    #####: 8285:	state_letter = state_index(d, &follows, 0, 1);
        -: 8286:      else
    #####: 8287:	state_letter = state;
        -: 8288:
        -: 8289:      /* Set the transitions for each character in the current label. */
    #####: 8290:      for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 8291:	for (k = 0; k < INTBITS; ++k)
    #####: 8292:	  if (labels[i][j] & 1 << k)
        -: 8293:	    {
    #####: 8294:	      int c = j * INTBITS + k;
        -: 8295:
    #####: 8296:	      if (c == '\n')
    #####: 8297:		trans[c] = state_newline;
    #####: 8298:	      else if (ISALNUM(c))
    #####: 8299:		trans[c] = state_letter;
    #####: 8300:	      else if (c < NOTCHAR)
    #####: 8301:		trans[c] = state;
        -: 8302:	    }
        -: 8303:    }
        -: 8304:
    #####: 8305:  for (i = 0; i < ngrps; ++i)
    #####: 8306:    free(grps[i].elems);
    #####: 8307:  free(follows.elems);
    #####: 8308:  free(tmp.elems);
    #####: 8309:}
        -: 8310:
        -: 8311:/* Some routines for manipulating a compiled dfa's transition tables.
        -: 8312:   Each state may or may not have a transition table; if it does, and it
        -: 8313:   is a non-accepting state, then d->trans[state] points to its table.
        -: 8314:   If it is an accepting state then d->fails[state] points to its table.
        -: 8315:   If it has no table at all, then d->trans[state] is NULL.
        -: 8316:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
        -: 8317:
        -: 8318:static void
    #####: 8319:build_state(s, d)
        -: 8320:     int s;
        -: 8321:     struct dfa *d;
        -: 8322:{
        -: 8323:  int *trans;			/* The new transition table. */
        -: 8324:  int i;
        -: 8325:
        -: 8326:  /* Set an upper limit on the number of transition tables that will ever
        -: 8327:     exist at once.  1024 is arbitrary.  The idea is that the frequently
        -: 8328:     used transition tables will be quickly rebuilt, whereas the ones that
        -: 8329:     were only needed once or twice will be cleared away. */
    #####: 8330:  if (d->trcount >= 1024)
        -: 8331:    {
    #####: 8332:      for (i = 0; i < d->tralloc; ++i)
    #####: 8333:	if (d->trans[i])
        -: 8334:	  {
    #####: 8335:	    free((ptr_t) d->trans[i]);
    #####: 8336:	    d->trans[i] = NULL;
        -: 8337:	  }
    #####: 8338:	else if (d->fails[i])
        -: 8339:	  {
    #####: 8340:	    free((ptr_t) d->fails[i]);
    #####: 8341:	    d->fails[i] = NULL;
        -: 8342:	  }
    #####: 8343:      d->trcount = 0;
        -: 8344:    }
        -: 8345:
    #####: 8346:  ++d->trcount;
        -: 8347:
        -: 8348:  /* Set up the success bits for this state. */
    #####: 8349:  d->success[s] = 0;
    #####: 8350:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
        -: 8351:      s, *d))
    #####: 8352:    d->success[s] |= 4;
    #####: 8353:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
        -: 8354:      s, *d))
    #####: 8355:    d->success[s] |= 2;
    #####: 8356:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
        -: 8357:      s, *d))
    #####: 8358:    d->success[s] |= 1;
        -: 8359:
    #####: 8360:  MALLOC(trans, int, NOTCHAR);
    #####: 8361:  dfastate(s, d, trans);
        -: 8362:
        -: 8363:  /* Now go through the new transition table, and make sure that the trans
        -: 8364:     and fail arrays are allocated large enough to hold a pointer for the
        -: 8365:     largest state mentioned in the table. */
    #####: 8366:  for (i = 0; i < NOTCHAR; ++i)
    #####: 8367:    if (trans[i] >= d->tralloc)
        -: 8368:      {
    #####: 8369:	int oldalloc = d->tralloc;
        -: 8370:
    #####: 8371:	while (trans[i] >= d->tralloc)
    #####: 8372:	  d->tralloc *= 2;
    #####: 8373:	REALLOC(d->realtrans, int *, d->tralloc + 1);
    #####: 8374:	d->trans = d->realtrans + 1;
    #####: 8375:	REALLOC(d->fails, int *, d->tralloc);
    #####: 8376:	REALLOC(d->success, int, d->tralloc);
    #####: 8377:	REALLOC(d->newlines, int, d->tralloc);
    #####: 8378:	while (oldalloc < d->tralloc)
        -: 8379:	  {
    #####: 8380:	    d->trans[oldalloc] = NULL;
    #####: 8381:	    d->fails[oldalloc++] = NULL;
        -: 8382:	  }
        -: 8383:      }
        -: 8384:
        -: 8385:  /* Keep the newline transition in a special place so we can use it as
        -: 8386:     a sentinel. */
    #####: 8387:  d->newlines[s] = trans['\n'];
    #####: 8388:  trans['\n'] = -1;
        -: 8389:
    #####: 8390:  if (ACCEPTING(s, *d))
    #####: 8391:    d->fails[s] = trans;
        -: 8392:  else
    #####: 8393:    d->trans[s] = trans;
    #####: 8394:}
        -: 8395:
        -: 8396:static void
    #####: 8397:build_state_zero(d)
        -: 8398:     struct dfa *d;
        -: 8399:{
    #####: 8400:  d->tralloc = 1;
    #####: 8401:  d->trcount = 0;
    #####: 8402:  CALLOC(d->realtrans, int *, d->tralloc + 1);
    #####: 8403:  d->trans = d->realtrans + 1;
    #####: 8404:  CALLOC(d->fails, int *, d->tralloc);
    #####: 8405:  MALLOC(d->success, int, d->tralloc);
    #####: 8406:  MALLOC(d->newlines, int, d->tralloc);
    #####: 8407:  build_state(0, d);
    #####: 8408:}
        -: 8409:
        -: 8410:/* Search through a buffer looking for a match to the given struct dfa.
        -: 8411:   Find the first occurrence of a string matching the regexp in the buffer,
        -: 8412:   and the shortest possible version thereof.  Return a pointer to the first
        -: 8413:   character after the match, or NULL if none is found.  Begin points to
        -: 8414:   the beginning of the buffer, and end points to the first character after
        -: 8415:   its end.  We store a newline in *end to act as a sentinel, so end had
        -: 8416:   better point somewhere valid.  Newline is a flag indicating whether to
        -: 8417:   allow newlines to be in the matching string.  If count is non-
        -: 8418:   NULL it points to a place we're supposed to increment every time we
        -: 8419:   see a newline.  Finally, if backref is non-NULL it points to a place
        -: 8420:   where we're supposed to store a 1 if backreferencing happened and the
        -: 8421:   match needs to be verified by a backtracking matcher.  Otherwise
        -: 8422:   we store a 0 in *backref. */
        -: 8423:char *
    #####: 8424:dfaexec(d, begin, end, newline, count, backref)
        -: 8425:     struct dfa *d;
        -: 8426:     char *begin;
        -: 8427:     char *end;
        -: 8428:     int newline;
        -: 8429:     int *count;
        -: 8430:     int *backref;
        -: 8431:{
        -: 8432:  register s, s1, tmp;		/* Current state. */
        -: 8433:  register unsigned char *p;	/* Current input character. */
        -: 8434:  register **trans, *t;		/* Copy of d->trans so it can be optimized
        -: 8435:				   into a register. */
        -: 8436:  static sbit[NOTCHAR];	/* Table for anding with d->success. */
        -: 8437:  static sbit_init;
        -: 8438:
    #####: 8439:  if (! sbit_init)
        -: 8440:    {
        -: 8441:      int i;
        -: 8442:
    #####: 8443:      sbit_init = 1;
    #####: 8444:      for (i = 0; i < NOTCHAR; ++i)
    #####: 8445:	if (i == '\n')
    #####: 8446:	  sbit[i] = 4;
    #####: 8447:	else if (ISALNUM(i))
    #####: 8448:	  sbit[i] = 2;
        -: 8449:	else
    #####: 8450:	  sbit[i] = 1;
        -: 8451:    }
        -: 8452:
    #####: 8453:  if (! d->tralloc)
    #####: 8454:    build_state_zero(d);
        -: 8455:
    #####: 8456:  s = s1 = 0;
    #####: 8457:  p = (unsigned char *) begin;
    #####: 8458:  trans = d->trans;
    #####: 8459:  *end = '\n';
        -: 8460:
        -: 8461:  for (;;)
        -: 8462:    {
        -: 8463:      /* The dreaded inner loop. */
    #####: 8464:      if ((t = trans[s]) != 0)
        -: 8465:	do
        -: 8466:	  {
    #####: 8467:	    s1 = t[*p++];
    #####: 8468:	    if (! (t = trans[s1]))
    #####: 8469:	      goto last_was_s;
    #####: 8470:	    s = t[*p++];
        -: 8471:	  }
    #####: 8472:        while ((t = trans[s]) != 0);
    #####: 8473:      goto last_was_s1;
        -: 8474:    last_was_s:
    #####: 8475:      tmp = s, s = s1, s1 = tmp;
        -: 8476:    last_was_s1:
        -: 8477:
    #####: 8478:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
        -: 8479:	{
    #####: 8480:	  if (d->success[s] & sbit[*p])
        -: 8481:	    {
    #####: 8482:	      if (backref)
    #####: 8483:		if (d->states[s].backref)
    #####: 8484:		  *backref = 1;
        -: 8485:		else
    #####: 8486:		  *backref = 0;
    #####: 8487:	      return (char *) p;
        -: 8488:	    }
        -: 8489:
    #####: 8490:	  s1 = s;
    #####: 8491:	  s = d->fails[s][*p++];
    #####: 8492:	  continue;
        -: 8493:	}
        -: 8494:
        -: 8495:      /* If the previous character was a newline, count it. */
    #####: 8496:      if (count && (char *) p <= end && p[-1] == '\n')
    #####: 8497:	++*count;
        -: 8498:
        -: 8499:      /* Check if we've run off the end of the buffer. */
    #####: 8500:      if ((char *) p > end)
    #####: 8501:	return NULL;
        -: 8502:
    #####: 8503:      if (s >= 0)
        -: 8504:	{
    #####: 8505:	  build_state(s, d);
    #####: 8506:	  trans = d->trans;
    #####: 8507:	  continue;
        -: 8508:	}
        -: 8509:
    #####: 8510:      if (p[-1] == '\n' && newline)
        -: 8511:	{
    #####: 8512:	  s = d->newlines[s1];
    #####: 8513:	  continue;
        -: 8514:	}
        -: 8515:
    #####: 8516:      s = 0;
    #####: 8517:    }
        -: 8518:}
        -: 8519:
        -: 8520:/* Initialize the components of a dfa that the other routines don't
        -: 8521:   initialize for themselves. */
        -: 8522:void
    #####: 8523:dfainit(d)
        -: 8524:     struct dfa *d;
        -: 8525:{
    #####: 8526:  d->calloc = 1;
    #####: 8527:  MALLOC(d->charclasses, charclass, d->calloc);
    #####: 8528:  d->cindex = 0;
        -: 8529:
    #####: 8530:  d->talloc = 1;
    #####: 8531:  MALLOC(d->tokens, token, d->talloc);
    #####: 8532:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
        -: 8533:
    #####: 8534:  d->searchflag = 0;
    #####: 8535:  d->tralloc = 0;
        -: 8536:
    #####: 8537:  d->musts = 0;
    #####: 8538:}
        -: 8539:
        -: 8540:/* Parse and analyze a single string of the given length. */
        -: 8541:void
    #####: 8542:dfacomp(s, len, d, searchflag)
        -: 8543:     char *s;
        -: 8544:     size_t len;
        -: 8545:     struct dfa *d;
        -: 8546:     int searchflag;
        -: 8547:{
    #####: 8548:  if (case_fold)	/* dummy folding in service of dfamust() */
        -: 8549:    {
        -: 8550:      char *copy;
        -: 8551:      int i;
        -: 8552:
    #####: 8553:      copy = malloc(len);
    #####: 8554:      if (!copy)
    #####: 8555:	dfaerror("out of memory");
        -: 8556:      
        -: 8557:      /* This is a kludge. */
    #####: 8558:      case_fold = 0;
    #####: 8559:      for (i = 0; i < len; ++i)
    #####: 8560:	if (ISUPPER(s[i]))
    #####: 8561:	  copy[i] = tolower(s[i]);
        -: 8562:	else
    #####: 8563:	  copy[i] = s[i];
        -: 8564:
    #####: 8565:      dfainit(d);
    #####: 8566:      dfaparse(copy, len, d);
    #####: 8567:      free(copy);
    #####: 8568:      dfamust(d);
    #####: 8569:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
    #####: 8570:      case_fold = 1;
    #####: 8571:      dfaparse(s, len, d);
    #####: 8572:      dfaanalyze(d, searchflag);
        -: 8573:    }
        -: 8574:  else
        -: 8575:    {
    #####: 8576:        dfainit(d);
    #####: 8577:        dfaparse(s, len, d);
    #####: 8578:	dfamust(d);
    #####: 8579:        dfaanalyze(d, searchflag);
        -: 8580:    }
    #####: 8581:}
        -: 8582:
        -: 8583:/* Free the storage held by the components of a dfa. */
        -: 8584:void
    #####: 8585:dfafree(d)
        -: 8586:     struct dfa *d;
        -: 8587:{
        -: 8588:  int i;
        -: 8589:  struct dfamust *dm, *ndm;
        -: 8590:
    #####: 8591:  free((ptr_t) d->charclasses);
    #####: 8592:  free((ptr_t) d->tokens);
    #####: 8593:  for (i = 0; i < d->sindex; ++i)
    #####: 8594:    free((ptr_t) d->states[i].elems.elems);
    #####: 8595:  free((ptr_t) d->states);
    #####: 8596:  for (i = 0; i < d->tindex; ++i)
    #####: 8597:    if (d->follows[i].elems)
    #####: 8598:      free((ptr_t) d->follows[i].elems);
    #####: 8599:  free((ptr_t) d->follows);
    #####: 8600:  for (i = 0; i < d->tralloc; ++i)
    #####: 8601:    if (d->trans[i])
    #####: 8602:      free((ptr_t) d->trans[i]);
    #####: 8603:    else if (d->fails[i])
    #####: 8604:      free((ptr_t) d->fails[i]);
    #####: 8605:  free((ptr_t) d->realtrans);
    #####: 8606:  free((ptr_t) d->fails);
    #####: 8607:  free((ptr_t) d->newlines);
    #####: 8608:  for (dm = d->musts; dm; dm = ndm)
        -: 8609:    {
    #####: 8610:      ndm = dm->next;
    #####: 8611:      free(dm->must);
    #####: 8612:      free((ptr_t) dm);
        -: 8613:    }
    #####: 8614:}
        -: 8615:
        -: 8616:/* Having found the postfix representation of the regular expression,
        -: 8617:   try to find a long sequence of characters that must appear in any line
        -: 8618:   containing the r.e.
        -: 8619:   Finding a "longest" sequence is beyond the scope here;
        -: 8620:   we take an easy way out and hope for the best.
        -: 8621:   (Take "(ab|a)b"--please.)
        -: 8622:
        -: 8623:   We do a bottom-up calculation of sequences of characters that must appear
        -: 8624:   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
        -: 8625:   representation:
        -: 8626:	sequences that must appear at the left of the match ("left")
        -: 8627:	sequences that must appear at the right of the match ("right")
        -: 8628:	lists of sequences that must appear somewhere in the match ("in")
        -: 8629:	sequences that must constitute the match ("is")
        -: 8630:
        -: 8631:   When we get to the root of the tree, we use one of the longest of its
        -: 8632:   calculated "in" sequences as our answer.  The sequence we find is returned in
        -: 8633:   d->must (where "d" is the single argument passed to "dfamust");
        -: 8634:   the length of the sequence is returned in d->mustn.
        -: 8635:
        -: 8636:   The sequences calculated for the various types of node (in pseudo ANSI c)
        -: 8637:   are shown below.  "p" is the operand of unary operators (and the left-hand
        -: 8638:   operand of binary operators); "q" is the right-hand operand of binary
        -: 8639:   operators.
        -: 8640:
        -: 8641:   "ZERO" means "a zero-length sequence" below.
        -: 8642:
        -: 8643:	Type	left		right		is		in
        -: 8644:	----	----		-----		--		--
        -: 8645:	char c	# c		# c		# c		# c
        -: 8646:	
        -: 8647:	CSET	ZERO		ZERO		ZERO		ZERO
        -: 8648:	
        -: 8649:	STAR	ZERO		ZERO		ZERO		ZERO
        -: 8650:
        -: 8651:	QMARK	ZERO		ZERO		ZERO		ZERO
        -: 8652:
        -: 8653:	PLUS	p->left		p->right	ZERO		p->in
        -: 8654:
        -: 8655:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
        -: 8656:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
        -: 8657:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
        -: 8658:						ZERO
        -: 8659:					
        -: 8660:	OR	longest common	longest common	(do p->is and	substrings common to
        -: 8661:		leading		trailing	q->is have same	p->in and q->in
        -: 8662:		(sub)sequence	(sub)sequence	length and	
        -: 8663:		of p->left	of p->right	content) ?	
        -: 8664:		and q->left	and q->right	p->is : NULL	
        -: 8665:
        -: 8666:   If there's anything else we recognize in the tree, all four sequences get set
        -: 8667:   to zero-length sequences.  If there's something we don't recognize in the tree,
        -: 8668:   we just return a zero-length sequence.
        -: 8669:
        -: 8670:   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
        -: 8671:   'aaa')?
        -: 8672:
        -: 8673:   And. . .is it here or someplace that we might ponder "optimizations" such as
        -: 8674:	egrep 'psi|epsilon'	->	egrep 'psi'
        -: 8675:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
        -: 8676:					(Yes, we now find "epsi" as a "string
        -: 8677:					that must occur", but we might also
        -: 8678:					simplify the *entire* r.e. being sought)
        -: 8679:	grep '[c]'		->	grep 'c'
        -: 8680:	grep '(ab|a)b'		->	grep 'ab'
        -: 8681:	grep 'ab*'		->	grep 'a'
        -: 8682:	grep 'a*b'		->	grep 'b'
        -: 8683:
        -: 8684:   There are several issues:
        -: 8685:
        -: 8686:   Is optimization easy (enough)?
        -: 8687:
        -: 8688:   Does optimization actually accomplish anything,
        -: 8689:   or is the automaton you get from "psi|epsilon" (for example)
        -: 8690:   the same as the one you get from "psi" (for example)?
        -: 8691:  
        -: 8692:   Are optimizable r.e.'s likely to be used in real-life situations
        -: 8693:   (something like 'ab*' is probably unlikely; something like is
        -: 8694:   'psi|epsilon' is likelier)? */
        -: 8695:
        -: 8696:static char *
    #####: 8697:icatalloc(old, new)
        -: 8698:     char *old;
        -: 8699:     char *new;
        -: 8700:{
        -: 8701:  char *result;
        -: 8702:  int oldsize, newsize;
        -: 8703:
    #####: 8704:  newsize = (new == NULL) ? 0 : strlen(new);
    #####: 8705:  if (old == NULL)
    #####: 8706:    oldsize = 0;
    #####: 8707:  else if (newsize == 0)
    #####: 8708:    return old;
    #####: 8709:  else	oldsize = strlen(old);
    #####: 8710:  if (old == NULL)
    #####: 8711:    result = (char *) malloc(newsize + 1);
        -: 8712:  else
    #####: 8713:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
    #####: 8714:  if (result != NULL && new != NULL)
    #####: 8715:    (void) strcpy(result + oldsize, new);
    #####: 8716:  return result;
        -: 8717:}
        -: 8718:
        -: 8719:static char *
    #####: 8720:icpyalloc(string)
        -: 8721:     char *string;
        -: 8722:{
    #####: 8723:  return icatalloc((char *) NULL, string);
        -: 8724:}
        -: 8725:
        -: 8726:static char *
    #####: 8727:istrstr(lookin, lookfor)
        -: 8728:     char *lookin;
        -: 8729:     char *lookfor;
        -: 8730:{
        -: 8731:  char *cp;
        -: 8732:  int len;
        -: 8733:
    #####: 8734:  len = strlen(lookfor);
    #####: 8735:  for (cp = lookin; *cp != '\0'; ++cp)
    #####: 8736:    if (strncmp(cp, lookfor, len) == 0)
    #####: 8737:      return cp;
    #####: 8738:  return NULL;
        -: 8739:}
        -: 8740:
        -: 8741:static void
    #####: 8742:ifree(cp)
        -: 8743:     char *cp;
        -: 8744:{
    #####: 8745:  if (cp != NULL)
    #####: 8746:    free(cp);
    #####: 8747:}
        -: 8748:
        -: 8749:static void
    #####: 8750:freelist(cpp)
        -: 8751:     char **cpp;
        -: 8752:{
        -: 8753:  int i;
        -: 8754:
    #####: 8755:  if (cpp == NULL)
    #####: 8756:    return;
    #####: 8757:  for (i = 0; cpp[i] != NULL; ++i)
        -: 8758:    {
    #####: 8759:      free(cpp[i]);
    #####: 8760:      cpp[i] = NULL;
        -: 8761:    }
        -: 8762:}
        -: 8763:
        -: 8764:static char **
    #####: 8765:enlist(cpp, new, len)
        -: 8766:     char **cpp;
        -: 8767:     char *new;
        -: 8768:     int len;
        -: 8769:{
        -: 8770:  int i, j;
        -: 8771:
    #####: 8772:  if (cpp == NULL)
    #####: 8773:    return NULL;
    #####: 8774:  if ((new = icpyalloc(new)) == NULL)
        -: 8775:    {
    #####: 8776:      freelist(cpp);
    #####: 8777:      return NULL;
        -: 8778:    }
    #####: 8779:  new[len] = '\0';
        -: 8780:  /* Is there already something in the list that's new (or longer)? */
    #####: 8781:  for (i = 0; cpp[i] != NULL; ++i)
    #####: 8782:    if (istrstr(cpp[i], new) != NULL)
        -: 8783:      {
    #####: 8784:	free(new);
    #####: 8785:	return cpp;
        -: 8786:      }
        -: 8787:  /* Eliminate any obsoleted strings. */
    #####: 8788:  j = 0;
    #####: 8789:  while (cpp[j] != NULL)
    #####: 8790:    if (istrstr(new, cpp[j]) == NULL)
    #####: 8791:      ++j;
        -: 8792:    else
        -: 8793:      {
    #####: 8794:	free(cpp[j]);
    #####: 8795:	if (--i == j)
    #####: 8796:	  break;
    #####: 8797:	cpp[j] = cpp[i];
    #####: 8798:	cpp[i] = NULL;
        -: 8799:      }
        -: 8800:  /* Add the new string. */
    #####: 8801:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
    #####: 8802:  if (cpp == NULL)
    #####: 8803:    return NULL;
    #####: 8804:  cpp[i] = new;
    #####: 8805:  cpp[i + 1] = NULL;
    #####: 8806:  return cpp;
        -: 8807:}
        -: 8808:
        -: 8809:/* Given pointers to two strings, return a pointer to an allocated
        -: 8810:   list of their distinct common substrings. Return NULL if something
        -: 8811:   seems wild. */
        -: 8812:static char **
    #####: 8813:comsubs(left, right)
        -: 8814:     char *left;
        -: 8815:     char *right;
        -: 8816:{
        -: 8817:  char **cpp;
        -: 8818:  char *lcp;
        -: 8819:  char *rcp;
        -: 8820:  int i, len;
        -: 8821:
    #####: 8822:  if (left == NULL || right == NULL)
    #####: 8823:    return NULL;
    #####: 8824:  cpp = (char **) malloc(sizeof *cpp);
    #####: 8825:  if (cpp == NULL)
    #####: 8826:    return NULL;
    #####: 8827:  cpp[0] = NULL;
    #####: 8828:  for (lcp = left; *lcp != '\0'; ++lcp)
        -: 8829:    {
    #####: 8830:      len = 0;
    #####: 8831:      rcp = index(right, *lcp);
    #####: 8832:      while (rcp != NULL)
        -: 8833:	{
    #####: 8834:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
        -: 8835:	    ;
    #####: 8836:	  if (i > len)
    #####: 8837:	    len = i;
    #####: 8838:	  rcp = index(rcp + 1, *lcp);
        -: 8839:	}
    #####: 8840:      if (len == 0)
    #####: 8841:	continue;
    #####: 8842:      if ((cpp = enlist(cpp, lcp, len)) == NULL)
    #####: 8843:	break;
        -: 8844:    }
    #####: 8845:  return cpp;
        -: 8846:}
        -: 8847:
        -: 8848:static char **
    #####: 8849:addlists(old, new)
        -: 8850:char **old;
        -: 8851:char **new;
        -: 8852:{
        -: 8853:  int i;
        -: 8854:
    #####: 8855:  if (old == NULL || new == NULL)
    #####: 8856:    return NULL;
    #####: 8857:  for (i = 0; new[i] != NULL; ++i)
        -: 8858:    {
    #####: 8859:      old = enlist(old, new[i], strlen(new[i]));
    #####: 8860:      if (old == NULL)
    #####: 8861:	break;
        -: 8862:    }
    #####: 8863:  return old;
        -: 8864:}
        -: 8865:
        -: 8866:/* Given two lists of substrings, return a new list giving substrings
        -: 8867:   common to both. */
        -: 8868:static char **
    #####: 8869:inboth(left, right)
        -: 8870:     char **left;
        -: 8871:     char **right;
        -: 8872:{
        -: 8873:  char **both;
        -: 8874:  char **temp;
        -: 8875:  int lnum, rnum;
        -: 8876:
    #####: 8877:  if (left == NULL || right == NULL)
    #####: 8878:    return NULL;
    #####: 8879:  both = (char **) malloc(sizeof *both);
    #####: 8880:  if (both == NULL)
    #####: 8881:    return NULL;
    #####: 8882:  both[0] = NULL;
    #####: 8883:  for (lnum = 0; left[lnum] != NULL; ++lnum)
        -: 8884:    {
    #####: 8885:      for (rnum = 0; right[rnum] != NULL; ++rnum)
        -: 8886:	{
    #####: 8887:	  temp = comsubs(left[lnum], right[rnum]);
    #####: 8888:	  if (temp == NULL)
        -: 8889:	    {
    #####: 8890:	      freelist(both);
    #####: 8891:	      return NULL;
        -: 8892:	    }
    #####: 8893:	  both = addlists(both, temp);
    #####: 8894:	  freelist(temp);
    #####: 8895:	  if (both == NULL)
    #####: 8896:	    return NULL;
        -: 8897:	}
        -: 8898:    }
    #####: 8899:  return both;
        -: 8900:}
        -: 8901:
        -: 8902:typedef struct
        -: 8903:{
        -: 8904:  char **in;
        -: 8905:  char *left;
        -: 8906:  char *right;
        -: 8907:  char *is;
        -: 8908:} must;
        -: 8909:
        -: 8910:static void
    #####: 8911:resetmust(mp)
        -: 8912:must *mp;
        -: 8913:{
    #####: 8914:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
    #####: 8915:  freelist(mp->in);
    #####: 8916:}
        -: 8917:
        -: 8918:static void
    #####: 8919:dfamust(dfa)
        -: 8920:struct dfa *dfa;
        -: 8921:{
        -: 8922:  must *musts;
        -: 8923:  must *mp;
        -: 8924:  char *result;
        -: 8925:  int ri;
        -: 8926:  int i;
        -: 8927:  int exact;
        -: 8928:  token t;
        -: 8929:  static must must0;
        -: 8930:  struct dfamust *dm;
        -: 8931:
    #####: 8932:  result = "";
    #####: 8933:  exact = 0;
    #####: 8934:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
    #####: 8935:  if (musts == NULL)
    #####: 8936:    return;
    #####: 8937:  mp = musts;
    #####: 8938:  for (i = 0; i <= dfa->tindex; ++i)
    #####: 8939:    mp[i] = must0;
    #####: 8940:  for (i = 0; i <= dfa->tindex; ++i)
        -: 8941:    {
    #####: 8942:      mp[i].in = (char **) malloc(sizeof *mp[i].in);
    #####: 8943:      mp[i].left = malloc(2);
    #####: 8944:      mp[i].right = malloc(2);
    #####: 8945:      mp[i].is = malloc(2);
    #####: 8946:      if (mp[i].in == NULL || mp[i].left == NULL ||
    #####: 8947:	  mp[i].right == NULL || mp[i].is == NULL)
        -: 8948:	goto done;
    #####: 8949:      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
    #####: 8950:      mp[i].in[0] = NULL;
        -: 8951:    }
        -: 8952:#ifdef DEBUG
        -: 8953:  fprintf(stderr, "dfamust:\n");
        -: 8954:  for (i = 0; i < dfa->tindex; ++i)
        -: 8955:    {
        -: 8956:      fprintf(stderr, " %d:", i);
        -: 8957:      prtok(dfa->tokens[i]);
        -: 8958:    }
        -: 8959:  putc('\n', stderr);
        -: 8960:#endif
    #####: 8961:  for (ri = 0; ri < dfa->tindex; ++ri)
        -: 8962:    {
    #####: 8963:      switch (t = dfa->tokens[ri])
        -: 8964:	{
        -: 8965:	case LPAREN:
        -: 8966:	case RPAREN:
    #####: 8967:	  goto done;		/* "cannot happen" */
        -: 8968:	case EMPTY:
        -: 8969:	case BEGLINE:
        -: 8970:	case ENDLINE:
        -: 8971:	case BEGWORD:
        -: 8972:	case ENDWORD:
        -: 8973:	case LIMWORD:
        -: 8974:	case NOTLIMWORD:
        -: 8975:	case BACKREF:
    #####: 8976:	  resetmust(mp);
    #####: 8977:	  break;
        -: 8978:	case STAR:
        -: 8979:	case QMARK:
    #####: 8980:	  if (mp <= musts)
    #####: 8981:	    goto done;		/* "cannot happen" */
    #####: 8982:	  --mp;
    #####: 8983:	  resetmust(mp);
    #####: 8984:	  break;
        -: 8985:	case OR:
        -: 8986:	case ORTOP:
    #####: 8987:	  if (mp < &musts[2])
    #####: 8988:	    goto done;		/* "cannot happen" */
        -: 8989:	  {
        -: 8990:	    char **new;
        -: 8991:	    must *lmp;
        -: 8992:	    must *rmp;
        -: 8993:	    int j, ln, rn, n;
        -: 8994:
    #####: 8995:	    rmp = --mp;
    #####: 8996:	    lmp = --mp;
        -: 8997:	    /* Guaranteed to be.  Unlikely, but. . . */
    #####: 8998:	    if (strcmp(lmp->is, rmp->is) != 0)
    #####: 8999:	      lmp->is[0] = '\0';
        -: 9000:	    /* Left side--easy */
    #####: 9001:	    i = 0;
    #####: 9002:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
    #####: 9003:	      ++i;
    #####: 9004:	    lmp->left[i] = '\0';
        -: 9005:	    /* Right side */
    #####: 9006:	    ln = strlen(lmp->right);
    #####: 9007:	    rn = strlen(rmp->right);
    #####: 9008:	    n = ln;
    #####: 9009:	    if (n > rn)
    #####: 9010:	      n = rn;
    #####: 9011:	    for (i = 0; i < n; ++i)
    #####: 9012:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
    #####: 9013:		break;
    #####: 9014:	    for (j = 0; j < i; ++j)
    #####: 9015:	      lmp->right[j] = lmp->right[(ln - i) + j];
    #####: 9016:	    lmp->right[j] = '\0';
    #####: 9017:	    new = inboth(lmp->in, rmp->in);
    #####: 9018:	    if (new == NULL)
    #####: 9019:	      goto done;
    #####: 9020:	    freelist(lmp->in);
    #####: 9021:	    free((char *) lmp->in);
    #####: 9022:	    lmp->in = new;
        -: 9023:	  }
    #####: 9024:	  break;
        -: 9025:	case PLUS:
    #####: 9026:	  if (mp <= musts)
    #####: 9027:	    goto done;		/* "cannot happen" */
    #####: 9028:	  --mp;
    #####: 9029:	  mp->is[0] = '\0';
    #####: 9030:	  break;
        -: 9031:	case END:
    #####: 9032:	  if (mp != &musts[1])
    #####: 9033:	    goto done;		/* "cannot happen" */
    #####: 9034:	  for (i = 0; musts[0].in[i] != NULL; ++i)
    #####: 9035:	    if (strlen(musts[0].in[i]) > strlen(result))
    #####: 9036:	      result = musts[0].in[i];
    #####: 9037:	  if (strcmp(result, musts[0].is) == 0)
    #####: 9038:	    exact = 1;
    #####: 9039:	  goto done;
        -: 9040:	case CAT:
    #####: 9041:	  if (mp < &musts[2])
    #####: 9042:	    goto done;		/* "cannot happen" */
        -: 9043:	  {
        -: 9044:	    must *lmp;
        -: 9045:	    must *rmp;
        -: 9046:
    #####: 9047:	    rmp = --mp;
    #####: 9048:	    lmp = --mp;
        -: 9049:	    /* In.  Everything in left, plus everything in
        -: 9050:	       right, plus catenation of
        -: 9051:	       left's right and right's left. */
    #####: 9052:	    lmp->in = addlists(lmp->in, rmp->in);
    #####: 9053:	    if (lmp->in == NULL)
    #####: 9054:	      goto done;
    #####: 9055:	    if (lmp->right[0] != '\0' &&
    #####: 9056:		rmp->left[0] != '\0')
        -: 9057:	      {
        -: 9058:		char *tp;
        -: 9059:
    #####: 9060:		tp = icpyalloc(lmp->right);
    #####: 9061:		if (tp == NULL)
    #####: 9062:		  goto done;
    #####: 9063:		tp = icatalloc(tp, rmp->left);
    #####: 9064:		if (tp == NULL)
    #####: 9065:		  goto done;
    #####: 9066:		lmp->in = enlist(lmp->in, tp,
        -: 9067:				 strlen(tp));
    #####: 9068:		free(tp);
    #####: 9069:		if (lmp->in == NULL)
    #####: 9070:		  goto done;
        -: 9071:	      }
        -: 9072:	    /* Left-hand */
    #####: 9073:	    if (lmp->is[0] != '\0')
        -: 9074:	      {
    #####: 9075:		lmp->left = icatalloc(lmp->left,
        -: 9076:				      rmp->left);
    #####: 9077:		if (lmp->left == NULL)
    #####: 9078:		  goto done;
        -: 9079:	      }
        -: 9080:	    /* Right-hand */
    #####: 9081:	    if (rmp->is[0] == '\0')
    #####: 9082:	      lmp->right[0] = '\0';
    #####: 9083:	    lmp->right = icatalloc(lmp->right, rmp->right);
    #####: 9084:	    if (lmp->right == NULL)
    #####: 9085:	      goto done;
        -: 9086:	    /* Guaranteed to be */
    #####: 9087:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
        -: 9088:	      {
    #####: 9089:		lmp->is = icatalloc(lmp->is, rmp->is);
    #####: 9090:		if (lmp->is == NULL)
    #####: 9091:		  goto done;
        -: 9092:	      }
        -: 9093:	    else
    #####: 9094:	      lmp->is[0] = '\0';
        -: 9095:	  }
    #####: 9096:	  break;
        -: 9097:	default:
    #####: 9098:	  if (t < END)
        -: 9099:	    {
        -: 9100:	      /* "cannot happen" */
    #####: 9101:	      goto done;
        -: 9102:	    }
    #####: 9103:	  else if (t == '\0')
        -: 9104:	    {
        -: 9105:	      /* not on *my* shift */
    #####: 9106:	      goto done;
        -: 9107:	    }
    #####: 9108:	  else if (t >= CSET)
        -: 9109:	    {
        -: 9110:	      /* easy enough */
    #####: 9111:	      resetmust(mp);
        -: 9112:	    }
        -: 9113:	  else
        -: 9114:	    {
        -: 9115:	      /* plain character */
    #####: 9116:	      resetmust(mp);
    #####: 9117:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
    #####: 9118:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
    #####: 9119:	      mp->in = enlist(mp->in, mp->is, 1);
    #####: 9120:	      if (mp->in == NULL)
    #####: 9121:		goto done;
        -: 9122:	    }
    #####: 9123:	  break;
        -: 9124:	}
        -: 9125:#ifdef DEBUG
        -: 9126:      fprintf(stderr, " node: %d:", ri);
        -: 9127:      prtok(dfa->tokens[ri]);
        -: 9128:      fprintf(stderr, "\n  in:");
        -: 9129:      for (i = 0; mp->in[i]; ++i)
        -: 9130:	fprintf(stderr, " \"%s\"", mp->in[i]);
        -: 9131:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
        -: 9132:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
        -: 9133:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
        -: 9134:#endif
    #####: 9135:      ++mp;
        -: 9136:    }
        -: 9137: done:
    #####: 9138:  if (strlen(result))
        -: 9139:    {
    #####: 9140:      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
    #####: 9141:      dm->exact = exact;
    #####: 9142:      dm->must = malloc(strlen(result) + 1);
    #####: 9143:      strcpy(dm->must, result);
    #####: 9144:      dm->next = dfa->musts;
    #####: 9145:      dfa->musts = dm;
        -: 9146:    }
    #####: 9147:  mp = musts;
    #####: 9148:  for (i = 0; i <= dfa->tindex; ++i)
        -: 9149:    {
    #####: 9150:      freelist(mp[i].in);
    #####: 9151:      ifree((char *) mp[i].in);
    #####: 9152:      ifree(mp[i].left);
    #####: 9153:      ifree(mp[i].right);
    #####: 9154:      ifree(mp[i].is);
        -: 9155:    }
    #####: 9156:  free((char *) mp);
        -: 9157:}
        -: 9158:/* kwset.c - search for any of a set of keywords.
        -: 9159:   Copyright 1989 Free Software Foundation
        -: 9160:		  Written August 1989 by Mike Haertel.
        -: 9161:
        -: 9162:   This program is free software; you can redistribute it and/or modify
        -: 9163:   it under the terms of the GNU General Public License as published by
        -: 9164:   the Free Software Foundation; either version 1, or (at your option)
        -: 9165:   any later version.
        -: 9166:
        -: 9167:   This program is distributed in the hope that it will be useful,
        -: 9168:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 9169:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 9170:   GNU General Public License for more details.
        -: 9171:
        -: 9172:   You should have received a copy of the GNU General Public License
        -: 9173:   along with this program; if not, write to the Free Software
        -: 9174:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
        -: 9175:
        -: 9176:   The author may be reached (Email) at the address mike@ai.mit.edu,
        -: 9177:   or (US mail) as Mike Haertel c/o Free Software Foundation. */
        -: 9178:
        -: 9179:/* The algorithm implemented by these routines bears a startling resemblence
        -: 9180:   to one discovered by Beate Commentz-Walter, although it is not identical.
        -: 9181:   See "A String Matching Algorithm Fast on the Average," Technical Report,
        -: 9182:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
        -: 9183:   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
        -: 9184:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
        -: 9185:   Vol. 18, No. 6, which describes the failure function used below. */
        -: 9186:
        -: 9187:
        -: 9188:#ifdef STDC_HEADERS
        -: 9189:#undef RE_DUP_MAX
        -: 9190:#include <limits.h>
        -: 9191:#define flag_limits 1
        -: 9192:#if flag_stdlib==0 
        -: 9193:#include <stdlib.h>
        -: 9194:#define flag_stdlib 1
        -: 9195:#endif
        -: 9196:#else
        -: 9197:#define INT_MAX 2147483647
        -: 9198:#define UCHAR_MAX 255
        -: 9199:#ifdef __STDC__
        -: 9200:#include <stddef.h>
        -: 9201:#else
        -: 9202:#if flag_systypes==0
        -: 9203:#include <sys/types.h>
        -: 9204:#define flag_systypes 1
        -: 9205:#endif
        -: 9206:#endif
        -: 9207:extern char *malloc();
        -: 9208:extern void free();
        -: 9209:#endif
        -: 9210:
        -: 9211:#ifdef HAVE_MEMCHR
        -: 9212:#if flag_string==0
        -: 9213:#include <string.h>
        -: 9214:#define flag_string 1
        -: 9215:#endif
        -: 9216:#ifdef NEED_MEMORY_H
        -: 9217:#if flag_memory==0
        -: 9218:#include <memory.h>
        -: 9219:#define flag_memory 1
        -: 9220:#endif
        -: 9221:#endif
        -: 9222:#else
        -: 9223:#ifdef __STDC__
        -: 9224:extern void *memchr();
        -: 9225:#else
        -: 9226:extern char *memchr();
        -: 9227:#endif
        -: 9228:#endif
        -: 9229:
        -: 9230:#ifdef GREP
        -: 9231:extern char *xmalloc();
        -: 9232:#define malloc xmalloc
        -: 9233:#endif
        -: 9234:
        -: 9235:#include "kwset.h"
        -: 9236:#include "obstack.h"
        -: 9237:
        -: 9238:#define NCHAR (UCHAR_MAX + 1)
        -: 9239:#define obstack_chunk_alloc malloc
        -: 9240:#define obstack_chunk_free free
        -: 9241:
        -: 9242:/* Balanced tree of edges and labels leaving a given trie node. */
        -: 9243:struct tree
        -: 9244:{
        -: 9245:  struct tree *llink;		/* Left link; MUST be first field. */
        -: 9246:  struct tree *rlink;		/* Right link (to larger labels). */
        -: 9247:  struct trie *trie;		/* Trie node pointed to by this edge. */
        -: 9248:  unsigned char label;		/* Label on this edge. */
        -: 9249:  char balance;			/* Difference in depths of subtrees. */
        -: 9250:};
        -: 9251:
        -: 9252:/* Node of a trie representing a set of reversed keywords. */
        -: 9253:struct trie
        -: 9254:{
        -: 9255:  unsigned int accepting;	/* Word index of accepted word, or zero. */
        -: 9256:  struct tree *links;		/* Tree of edges leaving this node. */
        -: 9257:  struct trie *parent;		/* Parent of this node. */
        -: 9258:  struct trie *next;		/* List of all trie nodes in level order. */
        -: 9259:  struct trie *fail;		/* Aho-Corasick failure function. */
        -: 9260:  int depth;			/* Depth of this node from the root. */
        -: 9261:  int shift;			/* Shift function for search failures. */
        -: 9262:  int maxshift;			/* Max shift of self and descendents. */
        -: 9263:};
        -: 9264:
        -: 9265:/* Structure returned opaquely to the caller, containing everything. */
        -: 9266:struct kwset
        -: 9267:{
        -: 9268:  struct obstack obstack;	/* Obstack for node allocation. */
        -: 9269:  int words;			/* Number of words in the trie. */
        -: 9270:  struct trie *trie;		/* The trie itself. */
        -: 9271:  int mind;			/* Minimum depth of an accepting node. */
        -: 9272:  int maxd;			/* Maximum depth of any node. */
        -: 9273:  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
        -: 9274:  struct trie *next[NCHAR];	/* Table of children of the root. */
        -: 9275:  char *target;			/* Target string if there's only one. */
        -: 9276:  int mind2;			/* Used in Boyer-Moore search for one string. */
        -: 9277:  char *trans;			/* Character translation table. */
        -: 9278:};
        -: 9279:
        -: 9280:/* Allocate and initialize a keyword set object, returning an opaque
        -: 9281:   pointer to it.  Return NULL if memory is not available. */
        -: 9282:kwset_t
    #####: 9283:kwsalloc(trans)
        -: 9284:     char *trans;
        -: 9285:{
        -: 9286:  struct kwset *kwset;
        -: 9287:
    #####: 9288:  kwset = (struct kwset *) malloc(sizeof (struct kwset));
    #####: 9289:  if (!kwset)
    #####: 9290:    return 0;
        -: 9291:
    #####: 9292:  obstack_init(&kwset->obstack);
    #####: 9293:  kwset->words = 0;
        -: 9294:  kwset->trie
    #####: 9295:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
    #####: 9296:  if (!kwset->trie)
        -: 9297:    {
    #####: 9298:      kwsfree((kwset_t) kwset);
    #####: 9299:      return 0;
        -: 9300:    }
    #####: 9301:  kwset->trie->accepting = 0;
    #####: 9302:  kwset->trie->links = 0;
    #####: 9303:  kwset->trie->parent = 0;
    #####: 9304:  kwset->trie->next = 0;
    #####: 9305:  kwset->trie->fail = 0;
    #####: 9306:  kwset->trie->depth = 0;
    #####: 9307:  kwset->trie->shift = 0;
    #####: 9308:  kwset->mind = INT_MAX;
    #####: 9309:  kwset->maxd = -1;
    #####: 9310:  kwset->target = 0;
    #####: 9311:  kwset->trans = trans;
        -: 9312:
    #####: 9313:  return (kwset_t) kwset;
        -: 9314:}
        -: 9315:
        -: 9316:/* Add the given string to the contents of the keyword set.  Return NULL
        -: 9317:   for success, an error message otherwise. */
        -: 9318:char *
    #####: 9319:kwsincr(kws, text, len)
        -: 9320:     kwset_t kws;
        -: 9321:     char *text;
        -: 9322:     size_t len;
        -: 9323:{
        -: 9324:  struct kwset *kwset;
        -: 9325:  register struct trie *trie;
        -: 9326:  register unsigned char label;
        -: 9327:  register struct tree *link;
        -: 9328:  register int depth;
        -: 9329:  struct tree *links[12];
        -: 9330:  enum { L, R } dirs[12];
        -: 9331:  struct tree *t, *r, *l, *rl, *lr;
        -: 9332:
    #####: 9333:  kwset = (struct kwset *) kws;
    #####: 9334:  trie = kwset->trie;
    #####: 9335:  text += len;
        -: 9336:
        -: 9337:  /* Descend the trie (built of reversed keywords) character-by-character,
        -: 9338:     installing new nodes when necessary. */
    #####: 9339:  while (len--)
        -: 9340:    {
    #####: 9341:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
        -: 9342:
        -: 9343:      /* Descend the tree of outgoing links for this trie node,
        -: 9344:	 looking for the current character and keeping track
        -: 9345:	 of the path followed. */
    #####: 9346:      link = trie->links;
    #####: 9347:      links[0] = (struct tree *) &trie->links;
    #####: 9348:      dirs[0] = L;
    #####: 9349:      depth = 1;
        -: 9350:
    #####: 9351:      while (link && label != link->label)
        -: 9352:	{
    #####: 9353:	  links[depth] = link;
    #####: 9354:	  if (label < link->label)
    #####: 9355:	    dirs[depth++] = L, link = link->llink;
        -: 9356:	  else
    #####: 9357:	    dirs[depth++] = R, link = link->rlink;
        -: 9358:	}
        -: 9359:
        -: 9360:      /* The current character doesn't have an outgoing link at
        -: 9361:	 this trie node, so build a new trie node and install
        -: 9362:	 a link in the current trie node's tree. */
    #####: 9363:      if (!link)
        -: 9364:	{
    #####: 9365:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
        -: 9366:					       sizeof (struct tree));
    #####: 9367:	  if (!link)
    #####: 9368:	    return "memory exhausted";
    #####: 9369:	  link->llink = 0;
    #####: 9370:	  link->rlink = 0;
    #####: 9371:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
        -: 9372:						     sizeof (struct trie));
    #####: 9373:	  if (!link->trie)
    #####: 9374:	    return "memory exhausted";
    #####: 9375:	  link->trie->accepting = 0;
    #####: 9376:	  link->trie->links = 0;
    #####: 9377:	  link->trie->parent = trie;
    #####: 9378:	  link->trie->next = 0;
    #####: 9379:	  link->trie->fail = 0;
    #####: 9380:	  link->trie->depth = trie->depth + 1;
    #####: 9381:	  link->trie->shift = 0;
    #####: 9382:	  link->label = label;
    #####: 9383:	  link->balance = 0;
        -: 9384:
        -: 9385:	  /* Install the new tree node in its parent. */
    #####: 9386:	  if (dirs[--depth] == L)
    #####: 9387:	    links[depth]->llink = link;
        -: 9388:	  else
    #####: 9389:	    links[depth]->rlink = link;
        -: 9390:
        -: 9391:	  /* Back up the tree fixing the balance flags. */
    #####: 9392:	  while (depth && !links[depth]->balance)
        -: 9393:	    {
    #####: 9394:	      if (dirs[depth] == L)
    #####: 9395:		--links[depth]->balance;
        -: 9396:	      else
    #####: 9397:		++links[depth]->balance;
    #####: 9398:	      --depth;
        -: 9399:	    }
        -: 9400:
        -: 9401:	  /* Rebalance the tree by pointer rotations if necessary. */
    #####: 9402:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
    #####: 9403:			|| (dirs[depth] == R && ++links[depth]->balance)))
        -: 9404:	    {
    #####: 9405:	      switch (links[depth]->balance)
        -: 9406:		{
        -: 9407:		case (char) -2:
    #####: 9408:		  switch (dirs[depth + 1])
        -: 9409:		    {
        -: 9410:		    case L:
    #####: 9411:		      r = links[depth], t = r->llink, rl = t->rlink;
    #####: 9412:		      t->rlink = r, r->llink = rl;
    #####: 9413:		      t->balance = r->balance = 0;
    #####: 9414:		      break;
        -: 9415:		    case R:
    #####: 9416:		      r = links[depth], l = r->llink, t = l->rlink;
    #####: 9417:		      rl = t->rlink, lr = t->llink;
    #####: 9418:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
    #####: 9419:		      l->balance = t->balance != 1 ? 0 : -1;
    #####: 9420:		      r->balance = t->balance != (char) -1 ? 0 : 1;
    #####: 9421:		      t->balance = 0;
    #####: 9422:		      break;
        -: 9423:		    }
    #####: 9424:		  break;
        -: 9425:		case 2:
    #####: 9426:		  switch (dirs[depth + 1])
        -: 9427:		    {
        -: 9428:		    case R:
    #####: 9429:		      l = links[depth], t = l->rlink, lr = t->llink;
    #####: 9430:		      t->llink = l, l->rlink = lr;
    #####: 9431:		      t->balance = l->balance = 0;
    #####: 9432:		      break;
        -: 9433:		    case L:
    #####: 9434:		      l = links[depth], r = l->rlink, t = r->llink;
    #####: 9435:		      lr = t->llink, rl = t->rlink;
    #####: 9436:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
    #####: 9437:		      l->balance = t->balance != 1 ? 0 : -1;
    #####: 9438:		      r->balance = t->balance != (char) -1 ? 0 : 1;
    #####: 9439:		      t->balance = 0;
    #####: 9440:		      break;
        -: 9441:		    }
    #####: 9442:		  break;
        -: 9443:		}
        -: 9444:
    #####: 9445:	      if (dirs[depth - 1] == L)
    #####: 9446:		links[depth - 1]->llink = t;
        -: 9447:	      else
    #####: 9448:		links[depth - 1]->rlink = t;
        -: 9449:	    }
        -: 9450:	}
        -: 9451:
    #####: 9452:      trie = link->trie;
        -: 9453:    }
        -: 9454:
        -: 9455:  /* Mark the node we finally reached as accepting, encoding the
        -: 9456:     index number of this word in the keyword set so far. */
    #####: 9457:  if (!trie->accepting)
    #####: 9458:    trie->accepting = 1 + 2 * kwset->words;
    #####: 9459:  ++kwset->words;
        -: 9460:
        -: 9461:  /* Keep track of the longest and shortest string of the keyword set. */
    #####: 9462:  if (trie->depth < kwset->mind)
    #####: 9463:    kwset->mind = trie->depth;
    #####: 9464:  if (trie->depth > kwset->maxd)
    #####: 9465:    kwset->maxd = trie->depth;
        -: 9466:
    #####: 9467:  return 0;
        -: 9468:}
        -: 9469:
        -: 9470:/* Enqueue the trie nodes referenced from the given tree in the
        -: 9471:   given queue. */
        -: 9472:static void
    #####: 9473:enqueue(tree, last)
        -: 9474:     struct tree *tree;
        -: 9475:     struct trie **last;
        -: 9476:{
    #####: 9477:  if (!tree)
    #####: 9478:    return;
    #####: 9479:  enqueue(tree->llink, last);
    #####: 9480:  enqueue(tree->rlink, last);
    #####: 9481:  (*last) = (*last)->next = tree->trie;
        -: 9482:}
        -: 9483:
        -: 9484:/* Compute the Aho-Corasick failure function for the trie nodes referenced
        -: 9485:   from the given tree, given the failure function for their parent as
        -: 9486:   well as a last resort failure node. */
        -: 9487:static void
    #####: 9488:treefails(tree, fail, recourse)
        -: 9489:     register struct tree *tree;
        -: 9490:     struct trie *fail;
        -: 9491:     struct trie *recourse;
        -: 9492:{
        -: 9493:  register struct tree *link;
        -: 9494:
    #####: 9495:  if (!tree)
    #####: 9496:    return;
        -: 9497:
    #####: 9498:  treefails(tree->llink, fail, recourse);
    #####: 9499:  treefails(tree->rlink, fail, recourse);
        -: 9500:
        -: 9501:  /* Find, in the chain of fails going back to the root, the first
        -: 9502:     node that has a descendent on the current label. */
    #####: 9503:  while (fail)
        -: 9504:    {
    #####: 9505:      link = fail->links;
    #####: 9506:      while (link && tree->label != link->label)
    #####: 9507:	if (tree->label < link->label)
    #####: 9508:	  link = link->llink;
        -: 9509:	else
    #####: 9510:	  link = link->rlink;
    #####: 9511:      if (link)
        -: 9512:	{
    #####: 9513:	  tree->trie->fail = link->trie;
    #####: 9514:	  return;
        -: 9515:	}
    #####: 9516:      fail = fail->fail;
        -: 9517:    }
        -: 9518:
    #####: 9519:  tree->trie->fail = recourse;
        -: 9520:}
        -: 9521:
        -: 9522:/* Set delta entries for the links of the given tree such that
        -: 9523:   the preexisting delta value is larger than the current depth. */
        -: 9524:static void
    #####: 9525:treedelta(tree, depth, delta)
        -: 9526:     register struct tree *tree;
        -: 9527:     register unsigned int depth;
        -: 9528:     unsigned char delta[];
        -: 9529:{
    #####: 9530:  if (!tree)
    #####: 9531:    return;
    #####: 9532:  treedelta(tree->llink, depth, delta);
    #####: 9533:  treedelta(tree->rlink, depth, delta);
    #####: 9534:  if (depth < delta[tree->label])
    #####: 9535:    delta[tree->label] = depth;
        -: 9536:}
        -: 9537:
        -: 9538:/* Return true if A has every label in B. */
        -: 9539:static int
    #####: 9540:hasevery(a, b)
        -: 9541:     register struct tree *a;
        -: 9542:     register struct tree *b;
        -: 9543:{
    #####: 9544:  if (!b)
    #####: 9545:    return 1;
    #####: 9546:  if (!hasevery(a, b->llink))
    #####: 9547:    return 0;
    #####: 9548:  if (!hasevery(a, b->rlink))
    #####: 9549:    return 0;
    #####: 9550:  while (a && b->label != a->label)
    #####: 9551:    if (b->label < a->label)
    #####: 9552:      a = a->llink;
        -: 9553:    else
    #####: 9554:      a = a->rlink;
    #####: 9555:  return !!a;
        -: 9556:}
        -: 9557:
        -: 9558:/* Compute a vector, indexed by character code, of the trie nodes
        -: 9559:   referenced from the given tree. */
        -: 9560:static void
    #####: 9561:treenext(tree, next)
        -: 9562:     struct tree *tree;
        -: 9563:     struct trie *next[];
        -: 9564:{
    #####: 9565:  if (!tree)
    #####: 9566:    return;
    #####: 9567:  treenext(tree->llink, next);
    #####: 9568:  treenext(tree->rlink, next);
    #####: 9569:  next[tree->label] = tree->trie;
        -: 9570:}
        -: 9571:
        -: 9572:/* Compute the shift for each trie node, as well as the delta
        -: 9573:   table and next cache for the given keyword set. */
        -: 9574:char *
    #####: 9575:kwsprep(kws)
        -: 9576:     kwset_t kws;
        -: 9577:{
        -: 9578:  register struct kwset *kwset;
        -: 9579:  register int i;
        -: 9580:  register struct trie *curr, *fail;
        -: 9581:  register char *trans;
        -: 9582:  unsigned char delta[NCHAR];
        -: 9583:  struct trie *last, *next[NCHAR];
        -: 9584:
    #####: 9585:  kwset = (struct kwset *) kws;
        -: 9586:
        -: 9587:  /* Initial values for the delta table; will be changed later.  The
        -: 9588:     delta entry for a given character is the smallest depth of any
        -: 9589:     node at which an outgoing edge is labeled by that character. */
    #####: 9590:  if (kwset->mind < 256)
    #####: 9591:    for (i = 0; i < NCHAR; ++i)
    #####: 9592:      delta[i] = kwset->mind;
        -: 9593:  else
    #####: 9594:    for (i = 0; i < NCHAR; ++i)
    #####: 9595:      delta[i] = 255;
        -: 9596:
        -: 9597:  /* Check if we can use the simple boyer-moore algorithm, instead
        -: 9598:     of the hairy commentz-walter algorithm. */
    #####: 9599:  if (kwset->words == 1 && kwset->trans == 0)
        -: 9600:    {
        -: 9601:      /* Looking for just one string.  Extract it from the trie. */
    #####: 9602:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
    #####: 9603:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
        -: 9604:	{
    #####: 9605:	  kwset->target[i] = curr->links->label;
    #####: 9606:	  curr = curr->links->trie;
        -: 9607:	}
        -: 9608:      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
    #####: 9609:      for (i = 0; i < kwset->mind; ++i)
    #####: 9610:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
    #####: 9611:      kwset->mind2 = kwset->mind;
        -: 9612:      /* Find the minimal delta2 shift that we might make after
        -: 9613:	 a backwards match has failed. */
    #####: 9614:      for (i = 0; i < kwset->mind - 1; ++i)
    #####: 9615:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
    #####: 9616:	  kwset->mind2 = kwset->mind - (i + 1);
        -: 9617:    }
        -: 9618:  else
        -: 9619:    {
        -: 9620:      /* Traverse the nodes of the trie in level order, simultaneously
        -: 9621:	 computing the delta table, failure function, and shift function. */
    #####: 9622:      for (curr = last = kwset->trie; curr; curr = curr->next)
        -: 9623:	{
        -: 9624:	  /* Enqueue the immediate descendents in the level order queue. */
    #####: 9625:	  enqueue(curr->links, &last);
        -: 9626:
    #####: 9627:	  curr->shift = kwset->mind;
    #####: 9628:	  curr->maxshift = kwset->mind;
        -: 9629:
        -: 9630:	  /* Update the delta table for the descendents of this node. */
    #####: 9631:	  treedelta(curr->links, curr->depth, delta);
        -: 9632:
        -: 9633:	  /* Compute the failure function for the decendents of this node. */
    #####: 9634:	  treefails(curr->links, curr->fail, kwset->trie);
        -: 9635:
        -: 9636:	  /* Update the shifts at each node in the current node's chain
        -: 9637:	     of fails back to the root. */
    #####: 9638:	  for (fail = curr->fail; fail; fail = fail->fail)
        -: 9639:	    {
        -: 9640:	      /* If the current node has some outgoing edge that the fail
        -: 9641:		 doesn't, then the shift at the fail should be no larger
        -: 9642:		 than the difference of their depths. */
    #####: 9643:	      if (!hasevery(fail->links, curr->links))
    #####: 9644:		if (curr->depth - fail->depth < fail->shift)
    #####: 9645:		  fail->shift = curr->depth - fail->depth;
        -: 9646:
        -: 9647:	      /* If the current node is accepting then the shift at the
        -: 9648:		 fail and its descendents should be no larger than the
        -: 9649:		 difference of their depths. */
    #####: 9650:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
    #####: 9651:		fail->maxshift = curr->depth - fail->depth;
        -: 9652:	    }
        -: 9653:	}
        -: 9654:
        -: 9655:      /* Traverse the trie in level order again, fixing up all nodes whose
        -: 9656:	 shift exceeds their inherited maxshift. */
    #####: 9657:      for (curr = kwset->trie->next; curr; curr = curr->next)
        -: 9658:	{
    #####: 9659:	  if (curr->maxshift > curr->parent->maxshift)
    #####: 9660:	    curr->maxshift = curr->parent->maxshift;
    #####: 9661:	  if (curr->shift > curr->maxshift)
    #####: 9662:	    curr->shift = curr->maxshift;
        -: 9663:	}
        -: 9664:
        -: 9665:      /* Create a vector, indexed by character code, of the outgoing links
        -: 9666:	 from the root node. */
    #####: 9667:      for (i = 0; i < NCHAR; ++i)
    #####: 9668:	next[i] = 0;
    #####: 9669:      treenext(kwset->trie->links, next);
        -: 9670:
    #####: 9671:      if ((trans = kwset->trans) != 0)
    #####: 9672:	for (i = 0; i < NCHAR; ++i)
    #####: 9673:	  kwset->next[i] = next[(unsigned char) trans[i]];
        -: 9674:      else
    #####: 9675:	for (i = 0; i < NCHAR; ++i)
    #####: 9676:	  kwset->next[i] = next[i];
        -: 9677:    }
        -: 9678:
        -: 9679:  /* Fix things up for any translation table. */
    #####: 9680:  if ((trans = kwset->trans) != 0)
    #####: 9681:    for (i = 0; i < NCHAR; ++i)
    #####: 9682:      kwset->delta[i] = delta[(unsigned char) trans[i]];
        -: 9683:  else
    #####: 9684:    for (i = 0; i < NCHAR; ++i)
    #####: 9685:      kwset->delta[i] = delta[i];
        -: 9686:
    #####: 9687:  return 0;
        -: 9688:}
        -: 9689:
        -: 9690:#define U(C) ((unsigned char) (C))
        -: 9691:
        -: 9692:/* Fast boyer-moore search. */
        -: 9693:static char *
    #####: 9694:bmexec(kws, text, size)
        -: 9695:     kwset_t kws;
        -: 9696:     char *text;
        -: 9697:     size_t size;
        -: 9698:{
        -: 9699:  struct kwset *kwset;
        -: 9700:  register unsigned char *d1;
        -: 9701:  register char *ep, *sp, *tp;
        -: 9702:  register int d, gc, i, len, md2;
        -: 9703:
    #####: 9704:  kwset = (struct kwset *) kws;
    #####: 9705:  len = kwset->mind;
        -: 9706:
    #####: 9707:  if (len == 0)
    #####: 9708:    return text;
    #####: 9709:  if (len > size)
    #####: 9710:    return 0;
    #####: 9711:  if (len == 1)
    #####: 9712:    return memchr(text, kwset->target[0], size);
        -: 9713:
    #####: 9714:  d1 = kwset->delta;
    #####: 9715:  sp = kwset->target + len;
    #####: 9716:  gc = U(sp[-2]);
    #####: 9717:  md2 = kwset->mind2;
    #####: 9718:  tp = text + len;
        -: 9719:
        -: 9720:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
    #####: 9721:  if (size > 12 * len)
        -: 9722:    /* 11 is not a bug, the initial offset happens only once. */
    #####: 9723:    for (ep = text + size - 11 * len;;)
        -: 9724:      {
    #####: 9725:	while (tp <= ep)
        -: 9726:	  {
    #####: 9727:	    d = d1[U(tp[-1])], tp += d;
    #####: 9728:	    d = d1[U(tp[-1])], tp += d;
    #####: 9729:	    if (d == 0)
    #####: 9730:	      goto found;
    #####: 9731:	    d = d1[U(tp[-1])], tp += d;
    #####: 9732:	    d = d1[U(tp[-1])], tp += d;
    #####: 9733:	    d = d1[U(tp[-1])], tp += d;
    #####: 9734:	    if (d == 0)
    #####: 9735:	      goto found;
    #####: 9736:	    d = d1[U(tp[-1])], tp += d;
    #####: 9737:	    d = d1[U(tp[-1])], tp += d;
    #####: 9738:	    d = d1[U(tp[-1])], tp += d;
    #####: 9739:	    if (d == 0)
    #####: 9740:	      goto found;
    #####: 9741:	    d = d1[U(tp[-1])], tp += d;
    #####: 9742:	    d = d1[U(tp[-1])], tp += d;
        -: 9743:	  }
    #####: 9744:	break;
        -: 9745:      found:
    #####: 9746:	if (U(tp[-2]) == gc)
        -: 9747:	  {
    #####: 9748:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
        -: 9749:	      ;
    #####: 9750:	    if (i > len)
    #####: 9751:	      return tp - len;
        -: 9752:	  }
    #####: 9753:	tp += md2;
    #####: 9754:      }
        -: 9755:
        -: 9756:  /* Now we have only a few characters left to search.  We
        -: 9757:     carefully avoid ever producing an out-of-bounds pointer. */
    #####: 9758:  ep = text + size;
    #####: 9759:  d = d1[U(tp[-1])];
    #####: 9760:  while (d <= ep - tp)
        -: 9761:    {
    #####: 9762:      d = d1[U((tp += d)[-1])];
    #####: 9763:      if (d != 0)
    #####: 9764:	continue;
    #####: 9765:      if (tp[-2] == gc)
        -: 9766:	{
    #####: 9767:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
        -: 9768:	    ;
    #####: 9769:	  if (i > len)
    #####: 9770:	    return tp - len;
        -: 9771:	}
    #####: 9772:      d = md2;
        -: 9773:    }
        -: 9774:
    #####: 9775:  return 0;
        -: 9776:}
        -: 9777:
        -: 9778:/* Hairy multiple string search. */
        -: 9779:static char *
    #####: 9780:cwexec(kws, text, len, kwsmatch)
        -: 9781:     kwset_t kws;
        -: 9782:     char *text;
        -: 9783:     size_t len;
        -: 9784:     struct kwsmatch *kwsmatch;
        -: 9785:{
        -: 9786:  struct kwset *kwset;
        -: 9787:  struct trie **next, *trie, *accept;
        -: 9788:  char *beg, *lim, *mch, *lmch;
        -: 9789:  register unsigned char c, *delta;
        -: 9790:  register int d;
        -: 9791:  register char *end, *qlim;
        -: 9792:  register struct tree *tree;
        -: 9793:  register char *trans;
        -: 9794:
        -: 9795:  /* Initialize register copies and look for easy ways out. */
    #####: 9796:  kwset = (struct kwset *) kws;
    #####: 9797:  if (len < kwset->mind)
    #####: 9798:    return 0;
    #####: 9799:  next = kwset->next;
    #####: 9800:  delta = kwset->delta;
    #####: 9801:  trans = kwset->trans;
    #####: 9802:  lim = text + len;
    #####: 9803:  end = text;
    #####: 9804:  if ((d = kwset->mind) != 0)
    #####: 9805:    mch = 0;
        -: 9806:  else
        -: 9807:    {
    #####: 9808:      mch = text, accept = kwset->trie;
    #####: 9809:      goto match;
        -: 9810:    }
        -: 9811:
    #####: 9812:  if (len >= 4 * kwset->mind)
    #####: 9813:    qlim = lim - 4 * kwset->mind;
        -: 9814:  else
    #####: 9815:    qlim = 0;
        -: 9816:
    #####: 9817:  while (lim - end >= d)
        -: 9818:    {
    #####: 9819:      if (qlim && end <= qlim)
        -: 9820:	{
    #####: 9821:	  end += d - 1;
    #####: 9822:	  while ((d = delta[c = *end]) && end < qlim)
        -: 9823:	    {
    #####: 9824:	      end += d;
    #####: 9825:	      end += delta[(unsigned char) *end];
    #####: 9826:	      end += delta[(unsigned char) *end];
        -: 9827:	    }
    #####: 9828:	  ++end;
        -: 9829:	}
        -: 9830:      else
    #####: 9831:	d = delta[c = (end += d)[-1]];
    #####: 9832:      if (d)
    #####: 9833:	continue;
    #####: 9834:      beg = end - 1;
    #####: 9835:      trie = next[c];
    #####: 9836:      if (trie->accepting)
        -: 9837:	{
    #####: 9838:	  mch = beg;
    #####: 9839:	  accept = trie;
        -: 9840:	}
    #####: 9841:      d = trie->shift;
    #####: 9842:      while (beg > text)
        -: 9843:	{
    #####: 9844:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
    #####: 9845:	  tree = trie->links;
    #####: 9846:	  while (tree && c != tree->label)
    #####: 9847:	    if (c < tree->label)
    #####: 9848:	      tree = tree->llink;
        -: 9849:	    else
    #####: 9850:	      tree = tree->rlink;
    #####: 9851:	  if (tree)
        -: 9852:	    {
    #####: 9853:	      trie = tree->trie;
    #####: 9854:	      if (trie->accepting)
        -: 9855:		{
    #####: 9856:		  mch = beg;
    #####: 9857:		  accept = trie;
        -: 9858:		}
        -: 9859:	    }
        -: 9860:	  else
    #####: 9861:	    break;
    #####: 9862:	  d = trie->shift;
        -: 9863:	}
    #####: 9864:      if (mch)
    #####: 9865:	goto match;
        -: 9866:    }
    #####: 9867:  return 0;
        -: 9868:
        -: 9869: match:
        -: 9870:  /* Given a known match, find the longest possible match anchored
        -: 9871:     at or before its starting point.  This is nearly a verbatim
        -: 9872:     copy of the preceding main search loops. */
    #####: 9873:  if (lim - mch > kwset->maxd)
    #####: 9874:    lim = mch + kwset->maxd;
    #####: 9875:  lmch = 0;
    #####: 9876:  d = 1;
    #####: 9877:  while (lim - end >= d)
        -: 9878:    {
    #####: 9879:      if ((d = delta[c = (end += d)[-1]]) != 0)
    #####: 9880:	continue;
    #####: 9881:      beg = end - 1;
    #####: 9882:      if (!(trie = next[c]))
        -: 9883:	{
    #####: 9884:	  d = 1;
    #####: 9885:	  continue;
        -: 9886:	}
    #####: 9887:      if (trie->accepting && beg <= mch)
        -: 9888:	{
    #####: 9889:	  lmch = beg;
    #####: 9890:	  accept = trie;
        -: 9891:	}
    #####: 9892:      d = trie->shift;
    #####: 9893:      while (beg > text)
        -: 9894:	{
    #####: 9895:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
    #####: 9896:	  tree = trie->links;
    #####: 9897:	  while (tree && c != tree->label)
    #####: 9898:	    if (c < tree->label)
    #####: 9899:	      tree = tree->llink;
        -: 9900:	    else
    #####: 9901:	      tree = tree->rlink;
    #####: 9902:	  if (tree)
        -: 9903:	    {
    #####: 9904:	      trie = tree->trie;
    #####: 9905:	      if (trie->accepting && beg <= mch)
        -: 9906:		{
    #####: 9907:		  lmch = beg;
    #####: 9908:		  accept = trie;
        -: 9909:		}
        -: 9910:	    }
        -: 9911:	  else
    #####: 9912:	    break;
    #####: 9913:	  d = trie->shift;
        -: 9914:	}
    #####: 9915:      if (lmch)
        -: 9916:	{
    #####: 9917:	  mch = lmch;
    #####: 9918:	  goto match;
        -: 9919:	}
    #####: 9920:      if (!d)
    #####: 9921:	d = 1;
        -: 9922:    }
        -: 9923:
    #####: 9924:  if (kwsmatch)
        -: 9925:    {
    #####: 9926:      kwsmatch->index = accept->accepting / 2;
    #####: 9927:      kwsmatch->beg[0] = mch;
    #####: 9928:      kwsmatch->size[0] = accept->depth;
        -: 9929:    }
    #####: 9930:  return mch;
        -: 9931:}
        -: 9932:  
        -: 9933:/* Search through the given text for a match of any member of the
        -: 9934:   given keyword set.  Return a pointer to the first character of
        -: 9935:   the matching substring, or NULL if no match is found.  If FOUNDLEN
        -: 9936:   is non-NULL store in the referenced location the length of the
        -: 9937:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
        -: 9938:   in the referenced location the index number of the particular
        -: 9939:   keyword matched. */
        -: 9940:char *
    #####: 9941:kwsexec(kws, text, size, kwsmatch)
        -: 9942:     kwset_t kws;
        -: 9943:     char *text;
        -: 9944:     size_t size;
        -: 9945:     struct kwsmatch *kwsmatch;
        -: 9946:{
        -: 9947:  struct kwset *kwset;
        -: 9948:  char *ret;
        -: 9949:
    #####: 9950:  kwset = (struct kwset *) kws;
    #####: 9951:  if (kwset->words == 1 && kwset->trans == 0)
        -: 9952:    {
    #####: 9953:      ret = bmexec(kws, text, size);
    #####: 9954:      if (kwsmatch != 0 && ret != 0)
        -: 9955:	{
    #####: 9956:	  kwsmatch->index = 0;
    #####: 9957:	  kwsmatch->beg[0] = ret;
    #####: 9958:	  kwsmatch->size[0] = kwset->mind;
        -: 9959:	}
    #####: 9960:      return ret;
        -: 9961:    }
        -: 9962:  else
    #####: 9963:    return cwexec(kws, text, size, kwsmatch);
        -: 9964:}
        -: 9965:
        -: 9966:/* Free the components of the given keyword set. */
        -: 9967:void
    #####: 9968:kwsfree(kws)
        -: 9969:     kwset_t kws;
        -: 9970:{
        -: 9971:  struct kwset *kwset;
        -: 9972:
    #####: 9973:  kwset = (struct kwset *) kws;
    #####: 9974:  obstack_free(&kwset->obstack, 0);
    #####: 9975:  free(kws);
    #####: 9976:}
        -: 9977:/* obstack.c - subroutines used implicitly by object stack macros
        -: 9978:   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
        -: 9979:
        -: 9980:This program is free software; you can redistribute it and/or modify it
        -: 9981:under the terms of the GNU General Public License as published by the
        -: 9982:Free Software Foundation; either version 2, or (at your option) any
        -: 9983:later version.
        -: 9984:
        -: 9985:This program is distributed in the hope that it will be useful,
        -: 9986:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 9987:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 9988:GNU General Public License for more details.
        -: 9989:
        -: 9990:You should have received a copy of the GNU General Public License
        -: 9991:along with this program; if not, write to the Free Software
        -: 9992:Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
        -: 9993:
        -: 9994:/*#include "obstack.h"*/
        -: 9995:
        -: 9996:/* This is just to get __GNU_LIBRARY__ defined.  */
        -: 9997:/*#include <stdio.h>*/
        -: 9998:
        -: 9999:/* Comment out all this code if we are using the GNU C Library, and are not
        -:10000:   actually compiling the library itself.  This code is part of the GNU C
        -:10001:   Library, but also included in many other GNU distributions.  Compiling
        -:10002:   and linking in this code is a waste when using the GNU C library
        -:10003:   (especially if it is a shared library).  Rather than having every GNU
        -:10004:   program understand `configure --with-gnu-libc' and omit the object files,
        -:10005:   it is simpler to just do this in the source for each such file.  */
        -:10006:
        -:10007:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
        -:10008:
        -:10009:
        -:10010:#ifdef __STDC__
        -:10011:#define POINTER void *
        -:10012:#else
        -:10013:#define POINTER char *
        -:10014:#endif
        -:10015:
        -:10016:/* Determine default alignment.  */
        -:10017:struct fooalign {char x; double d;};
        -:10018:#define DEFAULT_ALIGNMENT  \
        -:10019:  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
        -:10020:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
        -:10021:   But in fact it might be less smart and round addresses to as much as
        -:10022:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
        -:10023:union fooround {long x; double d;};
        -:10024:#define DEFAULT_ROUNDING (sizeof (union fooround))
        -:10025:
        -:10026:/* When we copy a long block of data, this is the unit to do it with.
        -:10027:   On some machines, copying successive ints does not work;
        -:10028:   in such a case, redefine COPYING_UNIT to `long' (if that works)
        -:10029:   or `char' as a last resort.  */
        -:10030:#ifndef COPYING_UNIT
        -:10031:#define COPYING_UNIT int
        -:10032:#endif
        -:10033:
        -:10034:/* The non-GNU-C macros copy the obstack into this global variable
        -:10035:   to avoid multiple evaluation.  */
        -:10036:
        -:10037:struct obstack *_obstack;
        -:10038:
        -:10039:/* Define a macro that either calls functions with the traditional malloc/free
        -:10040:   calling interface, or calls functions with the mmalloc/mfree interface
        -:10041:   (that adds an extra first argument), based on the state of use_extra_arg.
        -:10042:   For free, do not use ?:, since some compilers, like the MIPS compilers,
        -:10043:   do not allow (expr) ? void : void.  */
        -:10044:
        -:10045:#define CALL_CHUNKFUN(h, size) \
        -:10046:  (((h) -> use_extra_arg) \
        -:10047:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -:10048:   : (*(h)->chunkfun) ((size)))
        -:10049:
        -:10050:#define CALL_FREEFUN(h, old_chunk) \
        -:10051:  do { \
        -:10052:    if ((h) -> use_extra_arg) \
        -:10053:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -:10054:    else \
        -:10055:      (*(h)->freefun) ((old_chunk)); \
        -:10056:  } while (0)
        -:10057:
        -:10058:#define CALL_FREEFUN(h, old_chunk) \
        -:10059:  do { \
        -:10060:      free ((old_chunk)); \
        -:10061:  } while (0)
        -:10062:
        -:10063:
        -:10064:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
        -:10065:   Objects start on multiples of ALIGNMENT (0 means use default).
        -:10066:   CHUNKFUN is the function to use to allocate chunks,
        -:10067:   and FREEFUN the function to free them.  */
        -:10068:
        -:10069:void
        -:10070:_obstack_begin (h, size, alignment, chunkfun, freefun)
        -:10071:     struct obstack *h;
        -:10072:     int size;
        -:10073:     int alignment;
        -:10074:     POINTER (*chunkfun) ();
        -:10075:     void (*freefun) ();
        -:10076:{
        -:10077:  register struct _obstack_chunk* chunk; /* points to new chunk */
        -:10078:
        -:10079:  if (alignment == 0)
        -:10080:    alignment = DEFAULT_ALIGNMENT;
        -:10081:  if (size == 0)
        -:10082:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -:10083:    {
        -:10084:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -:10085:	 Use the values for range checking, because if range checking is off,
        -:10086:	 the extra bytes won't be missed terribly, but if range checking is on
        -:10087:	 and we used a larger request, a whole extra 4096 bytes would be
        -:10088:	 allocated.
        -:10089:
        -:10090:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -:10091:	 less sensitive to the size of the request.  */
        -:10092:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -:10093:		    + 4 + DEFAULT_ROUNDING - 1)
        -:10094:		   & ~(DEFAULT_ROUNDING - 1));
        -:10095:      size = 4096 - extra;
        -:10096:    }
        -:10097:
        -:10098:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -:10099:  h->freefun = freefun;
        -:10100:  h->chunk_size = size;
        -:10101:  h->alignment_mask = alignment - 1;
        -:10102:  h->use_extra_arg = 0;
        -:10103:
        -:10104:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -:10105:  h->next_free = h->object_base = chunk->contents;
        -:10106:  h->chunk_limit = chunk->limit
        -:10107:    = (char *) chunk + h->chunk_size;
        -:10108:  chunk->prev = 0;
        -:10109:  /* The initial chunk now contains no empty object.  */
        -:10110:  h->maybe_empty_object = 0;
        -:10111:}
        -:10112:
        -:10113:void
        -:10114:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
        -:10115:     struct obstack *h;
        -:10116:     int size;
        -:10117:     int alignment;
        -:10118:     POINTER (*chunkfun) ();
        -:10119:     void (*freefun) ();
        -:10120:     POINTER arg;
        -:10121:{
        -:10122:  register struct _obstack_chunk* chunk; /* points to new chunk */
        -:10123:
        -:10124:  if (alignment == 0)
        -:10125:    alignment = DEFAULT_ALIGNMENT;
        -:10126:  if (size == 0)
        -:10127:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -:10128:    {
        -:10129:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -:10130:	 Use the values for range checking, because if range checking is off,
        -:10131:	 the extra bytes won't be missed terribly, but if range checking is on
        -:10132:	 and we used a larger request, a whole extra 4096 bytes would be
        -:10133:	 allocated.
        -:10134:
        -:10135:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -:10136:	 less sensitive to the size of the request.  */
        -:10137:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -:10138:		    + 4 + DEFAULT_ROUNDING - 1)
        -:10139:		   & ~(DEFAULT_ROUNDING - 1));
        -:10140:      size = 4096 - extra;
        -:10141:    }
        -:10142:
        -:10143:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -:10144:  h->freefun = freefun;
        -:10145:  h->chunk_size = size;
        -:10146:  h->alignment_mask = alignment - 1;
        -:10147:  h->extra_arg = arg;
        -:10148:  h->use_extra_arg = 1;
        -:10149:
        -:10150:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -:10151:  h->next_free = h->object_base = chunk->contents;
        -:10152:  h->chunk_limit = chunk->limit
        -:10153:    = (char *) chunk + h->chunk_size;
        -:10154:  chunk->prev = 0;
        -:10155:  /* The initial chunk now contains no empty object.  */
        -:10156:  h->maybe_empty_object = 0;
        -:10157:}
        -:10158:
        -:10159:/* Allocate a new current chunk for the obstack *H
        -:10160:   on the assumption that LENGTH bytes need to be added
        -:10161:   to the current object, or a new object of length LENGTH allocated.
        -:10162:   Copies any partial object from the end of the old chunk
        -:10163:   to the beginning of the new one.  */
        -:10164:
        -:10165:void
        -:10166:_obstack_newchunk (h, length)
        -:10167:     struct obstack *h;
        -:10168:     int length;
        -:10169:{
        -:10170:  register struct _obstack_chunk*	old_chunk = h->chunk;
        -:10171:  register struct _obstack_chunk*	new_chunk;
        -:10172:  register long	new_size;
        -:10173:  register int obj_size = h->next_free - h->object_base;
        -:10174:  register int i;
        -:10175:  int already;
        -:10176:
        -:10177:  /* Compute size for new chunk.  */
        -:10178:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
        -:10179:  if (new_size < h->chunk_size)
        -:10180:    new_size = h->chunk_size;
        -:10181:
        -:10182:  /* Allocate and initialize the new chunk.  */
        -:10183:  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
        -:10184:  new_chunk->prev = old_chunk;
        -:10185:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
        -:10186:
        -:10187:  /* Move the existing object to the new chunk.
        -:10188:     Word at a time is fast and is safe if the object
        -:10189:     is sufficiently aligned.  */
        -:10190:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
        -:10191:    {
        -:10192:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
        -:10193:	   i >= 0; i--)
        -:10194:	((COPYING_UNIT *)new_chunk->contents)[i]
        -:10195:	  = ((COPYING_UNIT *)h->object_base)[i];
        -:10196:      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
        -:10197:	 but that can cross a page boundary on a machine
        -:10198:	 which does not do strict alignment for COPYING_UNITS.  */
        -:10199:      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
        -:10200:    }
        -:10201:  else
        -:10202:    already = 0;
        -:10203:  /* Copy remaining bytes one by one.  */
        -:10204:  for (i = already; i < obj_size; i++)
        -:10205:    new_chunk->contents[i] = h->object_base[i];
        -:10206:
        -:10207:  /* If the object just copied was the only data in OLD_CHUNK,
        -:10208:     free that chunk and remove it from the chain.
        -:10209:     But not if that chunk might contain an empty object.  */
        -:10210:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
        -:10211:    {
        -:10212:      new_chunk->prev = old_chunk->prev;
        -:10213:      CALL_FREEFUN (h, old_chunk);
        -:10214:    }
        -:10215:
        -:10216:  h->object_base = new_chunk->contents;
        -:10217:  h->next_free = h->object_base + obj_size;
        -:10218:  /* The new chunk certainly contains no empty object yet.  */
        -:10219:  h->maybe_empty_object = 0;
        -:10220:}
        -:10221:
        -:10222:/* Return nonzero if object OBJ has been allocated from obstack H.
        -:10223:   This is here for debugging.
        -:10224:   If you use it in a program, you are probably losing.  */
        -:10225:
        -:10226:int
        -:10227:_obstack_allocated_p (h, obj)
        -:10228:     struct obstack *h;
        -:10229:     POINTER obj;
        -:10230:{
        -:10231:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
        -:10232:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
        -:10233:
        -:10234:  lp = (h)->chunk;
        -:10235:  /* We use >= rather than > since the object cannot be exactly at
        -:10236:     the beginning of the chunk but might be an empty object exactly
        -:10237:     at the end of an adjacent chunk. */
        -:10238:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
        -:10239:    {
        -:10240:      plp = lp->prev;
        -:10241:      lp = plp;
        -:10242:    }
        -:10243:  return lp != 0;
        -:10244:}
        -:10245:
        -:10246:/* Free objects in obstack H, including OBJ and everything allocate
        -:10247:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
        -:10248:
        -:10249:#undef obstack_free
        -:10250:
        -:10251:/* This function has two names with identical definitions.
        -:10252:   This is the first one, called from non-ANSI code.  */
        -:10253:
        -:10254:void
        -:10255:_obstack_free (h, obj)
        -:10256:     struct obstack *h;
        -:10257:     POINTER obj;
        -:10258:{
        -:10259:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
        -:10260:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
        -:10261:
        -:10262:  lp = h->chunk;
        -:10263:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -:10264:     But there can be an empty object at that address
        -:10265:     at the end of another chunk.  */
        -:10266:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
        -:10267:    {
        -:10268:      plp = lp->prev;
        -:10269:      CALL_FREEFUN (h, lp);
        -:10270:      lp = plp;
        -:10271:      /* If we switch chunks, we can't tell whether the new current
        -:10272:	 chunk contains an empty object, so assume that it may.  */
        -:10273:      h->maybe_empty_object = 1;
        -:10274:    }
        -:10275:  if (lp)
        -:10276:    {
        -:10277:      h->object_base = h->next_free = (char *)(obj);
        -:10278:      h->chunk_limit = lp->limit;
        -:10279:      h->chunk = lp;
        -:10280:    }
        -:10281:  else if (obj != 0)
        -:10282:    /* obj is not in any of the chunks! */
        -:10283:    abort ();
        -:10284:}
        -:10285:
        -:10286:/* This function is used from ANSI code.  */
        -:10287:
        -:10288:void
        -:10289:obstack_free (h, obj)
        -:10290:     struct obstack *h;
        -:10291:     POINTER obj;
        -:10292:{
        -:10293:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
        -:10294:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
        -:10295:
        -:10296:  lp = h->chunk;
        -:10297:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -:10298:     But there can be an empty object at that address
        -:10299:     at the end of another chunk.  */
        -:10300:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
        -:10301:    {
        -:10302:      plp = lp->prev;
        -:10303:      CALL_FREEFUN (h, lp);
        -:10304:      lp = plp;
        -:10305:      /* If we switch chunks, we can't tell whether the new current
        -:10306:	 chunk contains an empty object, so assume that it may.  */
        -:10307:      h->maybe_empty_object = 1;
        -:10308:    }
        -:10309:  if (lp)
        -:10310:    {
        -:10311:      h->object_base = h->next_free = (char *)(obj);
        -:10312:      h->chunk_limit = lp->limit;
        -:10313:      h->chunk = lp;
        -:10314:    }
        -:10315:  else if (obj != 0)
        -:10316:    /* obj is not in any of the chunks! */
        -:10317:    abort ();
        -:10318:}
        -:10319:
        -:10320:#if 0
        -:10321:/* These are now turned off because the applications do not use it
        -:10322:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
        -:10323:
        -:10324:/* Now define the functional versions of the obstack macros.
        -:10325:   Define them to simply use the corresponding macros to do the job.  */
        -:10326:
        -:10327:#ifdef __STDC__
        -:10328:/* These function definitions do not work with non-ANSI preprocessors;
        -:10329:   they won't pass through the macro names in parentheses.  */
        -:10330:
        -:10331:/* The function names appear in parentheses in order to prevent
        -:10332:   the macro-definitions of the names from being expanded there.  */
        -:10333:
        -:10334:POINTER (obstack_base) (obstack)
        -:10335:     struct obstack *obstack;
        -:10336:{
        -:10337:  return obstack_base (obstack);
        -:10338:}
        -:10339:
        -:10340:POINTER (obstack_next_free) (obstack)
        -:10341:     struct obstack *obstack;
        -:10342:{
        -:10343:  return obstack_next_free (obstack);
        -:10344:}
        -:10345:
        -:10346:int (obstack_object_size) (obstack)
        -:10347:     struct obstack *obstack;
        -:10348:{
        -:10349:  return obstack_object_size (obstack);
        -:10350:}
        -:10351:
        -:10352:int (obstack_room) (obstack)
        -:10353:     struct obstack *obstack;
        -:10354:{
        -:10355:  return obstack_room (obstack);
        -:10356:}
        -:10357:
        -:10358:void (obstack_grow) (obstack, pointer, length)
        -:10359:     struct obstack *obstack;
        -:10360:     POINTER pointer;
        -:10361:     int length;
        -:10362:{
        -:10363:  obstack_grow (obstack, pointer, length);
        -:10364:}
        -:10365:
        -:10366:void (obstack_grow0) (obstack, pointer, length)
        -:10367:     struct obstack *obstack;
        -:10368:     POINTER pointer;
        -:10369:     int length;
        -:10370:{
        -:10371:  obstack_grow0 (obstack, pointer, length);
        -:10372:}
        -:10373:
        -:10374:void (obstack_1grow) (obstack, character)
        -:10375:     struct obstack *obstack;
        -:10376:     int character;
        -:10377:{
        -:10378:  obstack_1grow (obstack, character);
        -:10379:}
        -:10380:
        -:10381:void (obstack_blank) (obstack, length)
        -:10382:     struct obstack *obstack;
        -:10383:     int length;
        -:10384:{
        -:10385:  obstack_blank (obstack, length);
        -:10386:}
        -:10387:
        -:10388:void (obstack_1grow_fast) (obstack, character)
        -:10389:     struct obstack *obstack;
        -:10390:     int character;
        -:10391:{
        -:10392:  obstack_1grow_fast (obstack, character);
        -:10393:}
        -:10394:
        -:10395:void (obstack_blank_fast) (obstack, length)
        -:10396:     struct obstack *obstack;
        -:10397:     int length;
        -:10398:{
        -:10399:  obstack_blank_fast (obstack, length);
        -:10400:}
        -:10401:
        -:10402:POINTER (obstack_finish) (obstack)
        -:10403:     struct obstack *obstack;
        -:10404:{
        -:10405:  return obstack_finish (obstack);
        -:10406:}
        -:10407:
        -:10408:POINTER (obstack_alloc) (obstack, length)
        -:10409:     struct obstack *obstack;
        -:10410:     int length;
        -:10411:{
        -:10412:  return obstack_alloc (obstack, length);
        -:10413:}
        -:10414:
        -:10415:POINTER (obstack_copy) (obstack, pointer, length)
        -:10416:     struct obstack *obstack;
        -:10417:     POINTER pointer;
        -:10418:     int length;
        -:10419:{
        -:10420:  return obstack_copy (obstack, pointer, length);
        -:10421:}
        -:10422:
        -:10423:POINTER (obstack_copy0) (obstack, pointer, length)
        -:10424:     struct obstack *obstack;
        -:10425:     POINTER pointer;
        -:10426:     int length;
        -:10427:{
        -:10428:  return obstack_copy0 (obstack, pointer, length);
        -:10429:}
        -:10430:
        -:10431:#endif /* __STDC__ */
        -:10432:
        -:10433:#endif /* 0 */
        -:10434:
        -:10435:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
        -:10436:/* search.c - searching subroutines using dfa, kwset and regex for grep.
        -:10437:   Copyright (C) 1992 Free Software Foundation, Inc.
        -:10438:
        -:10439:   This program is free software; you can redistribute it and/or modify
        -:10440:   it under the terms of the GNU General Public License as published by
        -:10441:   the Free Software Foundation; either version 2, or (at your option)
        -:10442:   any later version.
        -:10443:
        -:10444:   This program is distributed in the hope that it will be useful,
        -:10445:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:10446:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:10447:   GNU General Public License for more details.
        -:10448:
        -:10449:   You should have received a copy of the GNU General Public License
        -:10450:   along with this program; if not, write to the Free Software
        -:10451:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
        -:10452:
        -:10453:   Written August 1992 by Mike Haertel. */
        -:10454:
        -:10455:/*#include <ctype.h>*/
        -:10456:
        -:10457:#ifdef STDC_HEADERS
        -:10458:#if flag_limits==0
        -:10459:#undef RE_DUP_MAX
        -:10460:#include <limits.h>
        -:10461:#define flag_limits 1
        -:10462:#endif
        -:10463:#if flag_stdlib==0
        -:10464:#include <stdlib.h>
        -:10465:#define flag_stdlib 1
        -:10466:#endif
        -:10467:#else
        -:10468:#define UCHAR_MAX 255
        -:10469:#if flag_systypes==0
        -:10470:#include <sys/types.h>
        -:10471:#define flag_systypes 1
        -:10472:#endif
        -:10473:extern char *malloc();
        -:10474:#endif
        -:10475:
        -:10476:#ifdef HAVE_MEMCHR
        -:10477:#if flag_string==0
        -:10478:#include <string.h>
        -:10479:#define flag_string 1
        -:10480:#endif
        -:10481:#ifdef NEED_MEMORY_H
        -:10482:#if flag_memory==0
        -:10483:#include <memory.h>
        -:10484:#define flag_memory 1
        -:10485:#endif
        -:10486:#endif
        -:10487:#else
        -:10488:#ifdef __STDC__
        -:10489:extern void *memchr();
        -:10490:#else
        -:10491:extern char *memchr();
        -:10492:#endif
        -:10493:#endif
        -:10494:
        -:10495:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
        -:10496:#undef bcopy
        -:10497:#define bcopy(s, d, n) memcpy((d), (s), (n))
        -:10498:#endif
        -:10499:
        -:10500:#ifdef isascii
        -:10501:#define ISALNUM(C) (isascii(C) && isalnum(C))
        -:10502:#define ISUPPER(C) (isascii(C) && isupper(C))
        -:10503:#else
        -:10504:#define ISALNUM(C) isalnum(C)
        -:10505:#define ISUPPER(C) isupper(C)
        -:10506:#endif
        -:10507:
        -:10508:#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
        -:10509:
        -:10510:/*#include "grep.h"*/
        -:10511:/*#include "dfa.h"*/
        -:10512:/*#include "kwset.h"*/
        -:10513:/*#include "regex.h"*/
        -:10514:
        -:10515:#define NCHAR (UCHAR_MAX + 1)
        -:10516:
        -:10517:#if __STDC__
        -:10518:static void Gcompile(char *, size_t);
        -:10519:static void Ecompile(char *, size_t);
        -:10520:static char *EGexecute(char *, size_t, char **);
        -:10521:static void Fcompile(char *, size_t);
        -:10522:static char *Fexecute(char *, size_t, char **);
        -:10523:#else
        -:10524:static void Gcompile();
        -:10525:static void Ecompile();
        -:10526:static char *EGexecute();
        -:10527:static void Fcompile();
        -:10528:static char *Fexecute();
        -:10529:#endif
        -:10530:
        -:10531:/* Here is the matchers vector for the main program. */
        -:10532:struct matcher matchers[] = {
        -:10533:  { "default", Gcompile, EGexecute },
        -:10534:  { "grep", Gcompile, EGexecute },
        -:10535:  { "ggrep", Gcompile, EGexecute },
        -:10536:  { "egrep", Ecompile, EGexecute },
        -:10537:  { "posix-egrep", Ecompile, EGexecute },
        -:10538:  { "gegrep", Ecompile, EGexecute },
        -:10539:  { "fgrep", Fcompile, Fexecute },
        -:10540:  { "gfgrep", Fcompile, Fexecute },
        -:10541:  { 0, 0, 0 },
        -:10542:};
        -:10543:
        -:10544:/* For -w, we also consider _ to be word constituent.  */
        -:10545:#define WCHAR(C) (ISALNUM(C) || (C) == '_')
        -:10546:
        -:10547:/* DFA compiled regexp. */
        -:10548:static struct dfa dfa_1;
        -:10549:
        -:10550:/* Regex compiled regexp. */
        -:10551:static struct re_pattern_buffer regex;
        -:10552:
        -:10553:/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
        -:10554:   a list of strings, at least one of which is known to occur in
        -:10555:   any string matching the regexp. */
        -:10556:static kwset_t kwset;
        -:10557:
        -:10558:/* Last compiled fixed string known to exactly match the regexp.
        -:10559:   If kwsexec() returns < lastexact, then we don't need to
        -:10560:   call the regexp matcher at all. */
        -:10561:static int lastexact;
        -:10562:
        -:10563:void
    #####:10564:dfaerror(mesg)
        -:10565:     char *mesg;
        -:10566:{
    #####:10567:  fatal(mesg, 0);
    #####:10568:}
        -:10569:
        -:10570:static void
    #####:10571:kwsinit()
        -:10572:{
        -:10573:  static char trans[NCHAR];
        -:10574:  int i;
        -:10575:
    #####:10576:  if (match_icase)
    #####:10577:    for (i = 0; i < NCHAR; ++i)
    #####:10578:      trans[i] = TOLOWER(i);
        -:10579:
    #####:10580:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
    #####:10581:    fatal("memory exhausted", 0);
    #####:10582:}  
        -:10583:
        -:10584:/* If the DFA turns out to have some set of fixed strings one of
        -:10585:   which must occur in the match, then we build a kwset matcher
        -:10586:   to find those strings, and thus quickly filter out impossible
        -:10587:   matches. */
        -:10588:static void
    #####:10589:kwsmusts()
        -:10590:{
        -:10591:  struct dfamust *dm;
        -:10592:  char *err;
        -:10593:
    #####:10594:  if (dfa_1.musts)
        -:10595:    {
    #####:10596:      kwsinit();
        -:10597:      /* First, we compile in the substrings known to be exact
        -:10598:	 matches.  The kwset matcher will return the index
        -:10599:	 of the matching string that it chooses. */
    #####:10600:      for (dm = dfa_1.musts; dm; dm = dm->next)
        -:10601:	{
    #####:10602:	  if (!dm->exact)
    #####:10603:	    continue;
    #####:10604:	  ++lastexact;
    #####:10605:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
    #####:10606:	    fatal(err, 0);
        -:10607:	}
        -:10608:      /* Now, we compile the substrings that will require
        -:10609:	 the use of the regexp matcher.  */
    #####:10610:      for (dm = dfa_1.musts; dm; dm = dm->next)
        -:10611:	{
    #####:10612:	  if (dm->exact)
    #####:10613:	    continue;
    #####:10614:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
    #####:10615:	    fatal(err, 0);
        -:10616:	}
    #####:10617:      if ((err = kwsprep(kwset)) != 0)
    #####:10618:	fatal(err, 0);
        -:10619:    }
    #####:10620:}
        -:10621:
        -:10622:static void
    #####:10623:Gcompile(pattern, size)
        -:10624:     char *pattern;
        -:10625:     size_t size;
        -:10626:{
        -:10627:#ifdef __STDC__
        -:10628:  const
        -:10629:#endif
        -:10630:  char *err;
        -:10631:
    #####:10632:  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
    #####:10633:  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
        -:10634:
    #####:10635:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    #####:10636:    fatal(err, 0);
        -:10637:
    #####:10638:  dfainit(&dfa_1);
        -:10639:
        -:10640:  /* In the match_words and match_lines cases, we use a different pattern
        -:10641:     for the DFA matcher that will quickly throw out cases that won't work.
        -:10642:     Then if DFA succeeds we do some hairy stuff using the regex matcher
        -:10643:     to decide whether the match should really count. */
    #####:10644:  if (match_words || match_lines)
    #####:10645:    {
        -:10646:      /* In the whole-word case, we use the pattern:
        -:10647:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
        -:10648:	 In the whole-line case, we use the pattern:
        -:10649:	 ^(userpattern)$.
        -:10650:	 BUG: Using [A-Za-z_] is locale-dependent!  */
        -:10651:
    #####:10652:      char *n = malloc(size + 50);
    #####:10653:      int i = 0;
        -:10654:
    #####:10655:      strcpy(n, "");
        -:10656:
    #####:10657:      if (match_lines)
    #####:10658:	strcpy(n, "^\\(");
    #####:10659:      if (match_words)
    #####:10660:	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
        -:10661:
    #####:10662:      i = strlen(n);
    #####:10663:      bcopy(pattern, n + i, size);
    #####:10664:      i += size;
        -:10665:
    #####:10666:      if (match_words)
    #####:10667:	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
    #####:10668:      if (match_lines)
    #####:10669:	strcpy(n + i, "\\)$");
        -:10670:
    #####:10671:      i += strlen(n + i);
    #####:10672:      dfacomp(n, i, &dfa_1, 1);
        -:10673:    }
        -:10674:  else
    #####:10675:    dfacomp(pattern, size, &dfa_1, 1);
        -:10676:
    #####:10677:  kwsmusts();
    #####:10678:}
        -:10679:
        -:10680:static void
    #####:10681:Ecompile(pattern, size)
        -:10682:     char *pattern;
        -:10683:     size_t size;
        -:10684:{
        -:10685:#ifdef __STDC__
        -:10686:  const
        -:10687:#endif
        -:10688:  char *err;
        -:10689:
    #####:10690:  if (strcmp(matcher, "posix-egrep") == 0)
        -:10691:    {
    #####:10692:      re_set_syntax(RE_SYNTAX_POSIX_EGREP);
    #####:10693:      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
        -:10694:    }
        -:10695:  else
        -:10696:    {
    #####:10697:      re_set_syntax(RE_SYNTAX_EGREP);
    #####:10698:      dfasyntax(RE_SYNTAX_EGREP, match_icase);
        -:10699:    }
        -:10700:
    #####:10701:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    #####:10702:    fatal(err, 0);
        -:10703:
    #####:10704:  dfainit(&dfa_1);
        -:10705:
        -:10706:  /* In the match_words and match_lines cases, we use a different pattern
        -:10707:     for the DFA matcher that will quickly throw out cases that won't work.
        -:10708:     Then if DFA succeeds we do some hairy stuff using the regex matcher
        -:10709:     to decide whether the match should really count. */
    #####:10710:  if (match_words || match_lines)
    #####:10711:    {
        -:10712:      /* In the whole-word case, we use the pattern:
        -:10713:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
        -:10714:	 In the whole-line case, we use the pattern:
        -:10715:	 ^(userpattern)$.
        -:10716:	 BUG: Using [A-Za-z_] is locale-dependent!  */
        -:10717:
    #####:10718:      char *n = malloc(size + 50);
    #####:10719:      int i = 0;
        -:10720:
    #####:10721:      strcpy(n, "");
        -:10722:
    #####:10723:      if (match_lines)
    #####:10724:	strcpy(n, "^(");
    #####:10725:      if (match_words)
    #####:10726:	strcpy(n, "(^|[^0-9A-Za-z_])(");
        -:10727:
    #####:10728:      i = strlen(n);
    #####:10729:      bcopy(pattern, n + i, size);
    #####:10730:      i += size;
        -:10731:
    #####:10732:      if (match_words)
    #####:10733:	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
    #####:10734:      if (match_lines)
    #####:10735:	strcpy(n + i, ")$");
        -:10736:
    #####:10737:      i += strlen(n + i);
    #####:10738:      dfacomp(n, i, &dfa_1, 1);
        -:10739:    }
        -:10740:  else
    #####:10741:    dfacomp(pattern, size, &dfa_1, 1);
        -:10742:
    #####:10743:  kwsmusts();
    #####:10744:}
        -:10745:
        -:10746:static char *
    #####:10747:EGexecute(buf, size, endp)
        -:10748:     char *buf;
        -:10749:     size_t size;
        -:10750:     char **endp;
        -:10751:{
        -:10752:  register char *buflim, *beg, *end, save;
        -:10753:  int backref, start, len;
        -:10754:  struct kwsmatch kwsm;
        -:10755:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
        -:10756:				    Q@#%!# library interface in regex.c.  */
        -:10757:
    #####:10758:  buflim = buf + size;
        -:10759:
    #####:10760:  for (beg = end = buf; end < buflim; beg = end + 1)
        -:10761:    {
    #####:10762:      if (kwset)
        -:10763:	{
        -:10764:	  /* Find a possible match using the KWset matcher. */
    #####:10765:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
    #####:10766:	  if (!beg)
    #####:10767:	    goto failure;
        -:10768:	  /* Narrow down to the line containing the candidate, and
        -:10769:	     run it through DFA. */
    #####:10770:	  end = memchr(beg, '\n', buflim - beg);
    #####:10771:	  if (!end)
    #####:10772:	    end = buflim;
    #####:10773:	  while (beg > buf && beg[-1] != '\n')
    #####:10774:	    --beg;
    #####:10775:	  save = *end;
    #####:10776:	  if (kwsm.index < lastexact)
    #####:10777:	    goto success;
    #####:10778:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
        -:10779:	    {
    #####:10780:	      *end = save;
    #####:10781:	      continue;
        -:10782:	    }
    #####:10783:	  *end = save;
        -:10784:	  /* Successful, no backreferences encountered. */
    #####:10785:	  if (!backref)
    #####:10786:	    goto success;
        -:10787:	}
        -:10788:      else
        -:10789:	{
        -:10790:	  /* No good fixed strings; start with DFA. */
    #####:10791:	  save = *buflim;
    #####:10792:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
    #####:10793:	  *buflim = save;
    #####:10794:	  if (!beg)
    #####:10795:	    goto failure;
        -:10796:	  /* Narrow down to the line we've found. */
    #####:10797:	  end = memchr(beg, '\n', buflim - beg);
    #####:10798:	  if (!end)
    #####:10799:	    end = buflim;
    #####:10800:	  while (beg > buf && beg[-1] != '\n')
    #####:10801:	    --beg;
        -:10802:	  /* Successful, no backreferences encountered! */
    #####:10803:	  if (!backref)
    #####:10804:	    goto success;
        -:10805:	}
        -:10806:      /* If we've made it to this point, this means DFA has seen
        -:10807:	 a probable match, and we need to run it through Regex. */
    #####:10808:      regex.not_eol = 0;
    #####:10809:      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
        -:10810:	{
    #####:10811:	  len = regs.end[0] - start;
    #####:10812:	  if (!match_lines && !match_words || match_lines && len == end - beg)
        -:10813:	    goto success;
        -:10814:	  /* If -w, check if the match aligns with word boundaries.
        -:10815:	     We do this iteratively because:
        -:10816:	     (a) the line may contain more than one occurence of the pattern, and
        -:10817:	     (b) Several alternatives in the pattern might be valid at a given
        -:10818:	     point, and we may need to consider a shorter one to find a word
        -:10819:	     boundary. */
    #####:10820:	  if (match_words)
    #####:10821:	    while (start >= 0)
        -:10822:	      {
    #####:10823:		if ((start == 0 || !WCHAR(beg[start - 1]))
    #####:10824:		    && (len == end - beg || !WCHAR(beg[start + len])))
        -:10825:		  goto success;
    #####:10826:		if (len > 0)
        -:10827:		  {
        -:10828:		    /* Try a shorter length anchored at the same place. */
    #####:10829:		    --len;
    #####:10830:		    regex.not_eol = 1;
    #####:10831:		    len = re_match(&regex, beg, start + len, start, &regs);
        -:10832:		  }
    #####:10833:		if (len <= 0)
        -:10834:		  {
        -:10835:		    /* Try looking further on. */
    #####:10836:		    if (start == end - beg)
    #####:10837:		      break;
    #####:10838:		    ++start;
    #####:10839:		    regex.not_eol = 0;
    #####:10840:		    start = re_search(&regex, beg, end - beg,
    #####:10841:				      start, end - beg - start, &regs);
    #####:10842:		    len = regs.end[0] - start;
        -:10843:		  }
        -:10844:	      }
        -:10845:	}
        -:10846:    }
        -:10847:
        -:10848: failure:
    #####:10849:  return 0;
        -:10850:
        -:10851: success:
    #####:10852:  *endp = end < buflim ? end + 1 : end;
    #####:10853:  return beg;
        -:10854:}
        -:10855:
        -:10856:static void
    #####:10857:Fcompile(pattern, size)
        -:10858:     char *pattern;
        -:10859:     size_t size;
        -:10860:{
        -:10861:  char *beg, *lim, *err;
        -:10862:
    #####:10863:  kwsinit();
    #####:10864:  beg = pattern;
        -:10865:  do
        -:10866:    {
    #####:10867:      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
        -:10868:	;
    #####:10869:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
    #####:10870:	fatal(err, 0);
    #####:10871:      if (lim < pattern + size)
    #####:10872:	++lim;
    #####:10873:      beg = lim;
        -:10874:    }
    #####:10875:  while (beg < pattern + size);
        -:10876:
    #####:10877:  if ((err = kwsprep(kwset)) != 0)
    #####:10878:    fatal(err, 0);
    #####:10879:}
        -:10880:
        -:10881:static char *
    #####:10882:Fexecute(buf, size, endp)
        -:10883:     char *buf;
        -:10884:     size_t size;
        -:10885:     char **endp;
        -:10886:{
        -:10887:  register char *beg, *try, *end;
        -:10888:  register size_t len;
        -:10889:  struct kwsmatch kwsmatch;
        -:10890:
    #####:10891:  for (beg = buf; beg <= buf + size; ++beg)
        -:10892:    {
    #####:10893:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
    #####:10894:	return 0;
    #####:10895:      len = kwsmatch.size[0];
    #####:10896:      if (match_lines)
        -:10897:	{
    #####:10898:	  if (beg > buf && beg[-1] != '\n')
    #####:10899:	    continue;
    #####:10900:	  if (beg + len < buf + size && beg[len] != '\n')
    #####:10901:	    continue;
    #####:10902:	  goto success;
        -:10903:	}
    #####:10904:      else if (match_words)
    #####:10905:	for (try = beg; len && try;)
        -:10906:	  {
    #####:10907:	    if (try > buf && WCHAR((unsigned char) try[-1]))
        -:10908:	      break;
    #####:10909:	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
        -:10910:	      {
    #####:10911:		try = kwsexec(kwset, beg, --len, &kwsmatch);
    #####:10912:		len = kwsmatch.size[0];
        -:10913:	      }
        -:10914:	    else
        -:10915:	      goto success;
        -:10916:	  }
        -:10917:      else
    #####:10918:	goto success;
        -:10919:    }
        -:10920:
    #####:10921:  return 0;
        -:10922:
        -:10923: success:
    #####:10924:  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
    #####:10925:    ++end;
        -:10926:  else
    #####:10927:    end = buf + size;
    #####:10928:  *endp = end;
    #####:10929:  while (beg > buf && beg[-1] != '\n')
    #####:10930:    --beg;
    #####:10931:  return beg;
        -:10932:}
