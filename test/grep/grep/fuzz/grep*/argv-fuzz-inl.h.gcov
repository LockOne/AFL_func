        -:    0:Source:/home/cheong/afl-2.52b/experimental/argv_fuzzing/argv-fuzz-inl.h
        -:    0:Graph:grep.gcno
        -:    0:Data:grep.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:   american fuzzy lop - sample argv fuzzing wrapper
        -:    3:   ------------------------------------------------
        -:    4:
        -:    5:   Written by Michal Zalewski <lcamtuf@google.com>
        -:    6:
        -:    7:   Copyright 2015 Google Inc. All rights reserved.
        -:    8:
        -:    9:   Licensed under the Apache License, Version 2.0 (the "License");
        -:   10:   you may not use this file except in compliance with the License.
        -:   11:   You may obtain a copy of the License at:
        -:   12:
        -:   13:     http://www.apache.org/licenses/LICENSE-2.0
        -:   14:
        -:   15:   This file shows a simple way to fuzz command-line parameters with stock
        -:   16:   afl-fuzz. To use, add:
        -:   17:
        -:   18:   #include "/path/to/argv-fuzz-inl.h"
        -:   19:
        -:   20:   ...to the file containing main(), ideally placing it after all the 
        -:   21:   standard includes. Next, put AFL_INIT_ARGV(); near the very beginning of
        -:   22:   main().
        -:   23:
        -:   24:   This will cause the program to read NUL-delimited input from stdin and
        -:   25:   put it in argv[]. Two subsequent NULs terminate the array. Empty
        -:   26:   params are encoded as a lone 0x02. Lone 0x02 can't be generated, but
        -:   27:   that shouldn't matter in real life.
        -:   28:
        -:   29:   If you would like to always preserve argv[0], use this instead:
        -:   30:   AFL_INIT_SET0("prog_name");
        -:   31:
        -:   32:*/
        -:   33:
        -:   34:#ifndef _HAVE_ARGV_FUZZ_INL
        -:   35:#define _HAVE_ARGV_FUZZ_INL
        -:   36:
        -:   37:#include <unistd.h>
        -:   38:
        -:   39:#define AFL_INIT_ARGV() do { argv = afl_init_argv(&argc); } while (0)
        -:   40:
        -:   41:#define AFL_INIT_SET0(_p) do { \
        -:   42:    argv = afl_init_argv(&argc); \
        -:   43:    argv[0] = (_p); \
        -:   44:    if (!argc) argc = 1; \
        -:   45:  } while (0)
        -:   46:
        -:   47:#define MAX_CMDLINE_LEN 100000
        -:   48:#define MAX_CMDLINE_PAR 1000
        -:   49:
    #####:   50:static char** afl_init_argv(int* argc) {
        -:   51:
        -:   52:  static char  in_buf[MAX_CMDLINE_LEN];
        -:   53:  static char* ret[MAX_CMDLINE_PAR];
        -:   54:
    #####:   55:  char* ptr = in_buf;
        -:   56:  //int   rc  = 0;
    #####:   57:  int   rc  = 1;
        -:   58:
    #####:   59:  if (read(0, in_buf, MAX_CMDLINE_LEN - 2) < 0);
        -:   60:
    #####:   61:  while (*ptr) {
        -:   62:
    #####:   63:    ret[rc] = ptr;
    #####:   64:    if (ret[rc][0] == 0x02 && !ret[rc][1]) ret[rc]++;
    #####:   65:    rc++;
        -:   66:
    #####:   67:    while (*ptr) ptr++;
    #####:   68:    ptr++;
        -:   69:
        -:   70:  }
        -:   71:
    #####:   72:  *argc = rc;
        -:   73:
    #####:   74:  return ret;
        -:   75:
        -:   76:}
        -:   77:
        -:   78:#undef MAX_CMDLINE_LEN
        -:   79:#undef MAX_CMDLINE_PAR
        -:   80:
        -:   81:#endif /* !_HAVE_ARGV_FUZZ_INL */
